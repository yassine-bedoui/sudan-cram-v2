### ./README.md ###
Sudan CRAM v2 - Conflict Risk Analysis & Monitoring
A comprehensive conflict risk analysis and monitoring system for Sudan providing real-time analytics, visualizations, and predictive insights based on ACLED data.

Features
Implemented (V1)
Analytics Dashboard with interactive charts

Monthly conflict trends

Regional comparison

Risk distribution

Top 10 high-risk regions

Summary KPIs (events, fatalities, risk scores)

Backend API (FastAPI)

/api/analytics for comprehensive data

/api/monthly-trend for monthly aggregated trends

Processes real ACLED data with risk scoring

Frontend (Next.js 14 + TypeScript)

Responsive, mobile-first design

Dark theme UI

Visualizations with Recharts

Real-time data fetching

Planned Enhancements
Export options (CSV, JSON, PDF)

Interactive maps and date filters

Real-time updates and advanced visuals

User authentication

Historical trend predictions

Data
ACLED dataset: acled_with_causes.csv covering Nov 2024 - Oct 2025

Includes 2,451 events, 18,489 fatalities across 19 regions

Architecture Overview
text
sudan-cram-v2/
â”œâ”€â”€ backend/          # FastAPI backend & data processing
â””â”€â”€ frontend/         # Next.js frontend UI with visualizations
Quick Start
Clone repo:
git clone https://github.com/your-org/sudan-cram-v2.git && cd sudan-cram-v2

Backend:

text
cd backend
python -m venv venv
source venv/bin/activate  # Windows: venv\Scripts\activate
pip install -r requirements.txt
uvicorn app.main:app --reload --port 8000
Frontend (new terminal):

text
cd frontend
npm install
export NEXT_PUBLIC_BACKEND_URL=http://localhost:8000  # Windows CMD: set NEXT_PUBLIC_BACKEND_URL=http://localhost:8000
npm run dev
Access frontend dashboard at http://localhost:3000.

API Examples
/api/analytics returns dashboard data

/api/monthly-trend returns monthly event and fatality trends

Development Notes
Backend uses FastAPI and Pandas.

Frontend built with Next.js, TypeScript, Tailwind CSS, and Recharts.

Troubleshooting
Backend module errors: Confirm virtual env active and dependencies installed.

Frontend API access errors: Ensure NEXT_PUBLIC_BACKEND_URL is correctly set.

Port conflicts: Kill existing processes using ports 8000 (backend) or 3000 (frontend).

Planned for V2
Export functionality (CSV, JSON, PDF).

Interactive maps and date-based filtering.

Real-time data updates and advanced visualizations.

User authentication.

Historical trend predictions using multi-agent AI.
### ./backend/__init__.py ###

### ./backend/app/__init__.py ###

### ./backend/app/agents/__init__.py ###

### ./backend/app/agents/event_extraction_agent.py ###
import uuid
from typing import List, Optional

from app.api.models.event_models import AnnotatedEvent, Actor
from app.core.state_name_normalizer import normalize_state_name
from app.core.actor_normalizer import normalize_actor
from app.services.vector_store import VectorStore

class EventExtractionAgent:
    """
    Agent responsible for extracting and annotating conflict events from raw input data.
    """

    def __init__(self):
        self.vector_store = VectorStore()
        self.scratchpad = []  # To hold iterative corrections or notes
        self.raw_events: Optional[List[dict]] = None

    def ingest(self, raw_events: List[dict]) -> None:
        """
        Ingest a list of raw event dictionaries for processing.

        :param raw_events: List of raw event data dicts
        """
        self.raw_events = raw_events

    def extract_events(self) -> List[AnnotatedEvent]:
        """
        Parse and normalize raw events into structured AnnotatedEvent objects.

        :return: List of AnnotatedEvent instances
        """
        if self.raw_events is None:
            return []

        extracted = []
        for raw in self.raw_events:
            event_id = str(uuid.uuid4())
            date = raw.get('date')
            loc_raw = raw.get('location', '')
            location = normalize_state_name(loc_raw)

            actors_raw = raw.get('actors', [])
            if not isinstance(actors_raw, list):
                # Defensive: if a single actor string, convert to list
                actors_raw = [actors_raw]

            actors = [Actor(name=normalize_actor(a)) for a in actors_raw if a]

            event_type = raw.get('event_code', 'UNKNOWN')
            severity = raw.get('severity', None)
            sources = raw.get('sources', None)
            annotations = raw.get('annotations', {})

            event = AnnotatedEvent(
                event_id=event_id,
                date=date,
                location=location,
                actors=actors,
                event_type=event_type,
                severity=severity,
                sources=sources,
                annotations=annotations
            )
            extracted.append(event)

        return extracted

    def annotate_events(self, events: List[AnnotatedEvent]) -> List[AnnotatedEvent]:
        """
        Placeholder for further event annotation or enrichment.
        Extend this method to add metadata such as event cause, sentiment, or links.

        :param events: List of AnnotatedEvent to enhance
        :return: Updated list of AnnotatedEvent
        """
        # For now, return as-is
        return events

    def self_correct(self, events: List[AnnotatedEvent]) -> List[AnnotatedEvent]:
        """
        Implement iterative self-correction logic using AI or rule-based methods.
        Adds events to scratchpad.

        :param events: AnnotatedEvent list to review and correct
        :return: Corrected list of AnnotatedEvent
        """
        self.scratchpad.append(events)
        # Future: implement AI feedback loop here
        return events

    def output(self, events: List[AnnotatedEvent]) -> None:
        """
        Store annotated events into vector store for semantic search and retrieval.

        :param events: List of AnnotatedEvent to save
        """
        for event in events:
            # Convert event to a summary text or JSON string for embedding
            event_text = f"{event.date} {event.location} {event.event_type} " \
                         f"{', '.join([actor.name for actor in event.actors])} " \
                         f"Severity: {event.severity}"
            
            vector = self.vector_store.embed_text(event_text)
            self.vector_store.upsert_event(event.event_id, vector, event.dict())


### ./backend/app/agents/langgraph_agents.py ###
from datetime import datetime
import json
import os

from langchain_ollama import ChatOllama
from langchain_core.messages import HumanMessage, SystemMessage

from app.agents.state import SudanCRAMState
from app.services.vector_store import VectorStore


# ---- 1. LLM + Vector Store setup ----

llm = ChatOllama(
    model=os.getenv("OLLAMA_MODEL", "llama3.2:8b"),
    base_url=os.getenv("OLLAMA_BASE_URL", "http://localhost:11434"),
    temperature=0.7,
)

vector_store = VectorStore()


# ---- 2. Nodes ----

def rag_retrieval_node(state: SudanCRAMState) -> SudanCRAMState:
    """Retrieve relevant events from Qdrant for the given region, with fallback."""
    print("\nðŸ” RAG Retrieval...")

    region = (state.get("region") or "").strip()

    # Base query text
    if region:
        base_query = f"conflict events in {region}"
    else:
        base_query = "conflict events in Sudan"

    results = []

    # 1ï¸âƒ£ Try region-filtered search first (if we have a region string)
    try:
        filters = {"region": region} if region else None
        results = vector_store.semantic_search(
            query=base_query,
            filters=filters,
            top_k=20,
        )
    except Exception as e:
        state["messages"].append(f"âš ï¸ RAG search error: {e}")
        results = []

    # 2ï¸âƒ£ Fallback: if no region-specific hits, broaden to Sudan-wide context
    if not results:
        print("â„¹ï¸ No region-specific matches, falling back to national context")
        if region:
            fallback_query = f"sudan conflict events related to {region}"
        else:
            fallback_query = "recent conflict events in Sudan"

        try:
            results = vector_store.semantic_search(
                query=fallback_query,
                filters=None,
                top_k=20,
            )
            if results:
                state["messages"].append(
                    "No region-specific matches; used Sudan-wide context instead"
                )
        except Exception as e:
            state["messages"].append(f"âš ï¸ Fallback RAG search error: {e}")
            results = []

    target_label = region or "Sudan (all)"
    state["retrieved_events"] = results
    state["messages"].append(
        f"Retrieved {len(results)} events for region {target_label}"
    )

    return state


def event_extractor_node(state: SudanCRAMState) -> SudanCRAMState:
    """Extract structured events from raw text, using retrieved events as context."""
    print("\nðŸ“ Event Extractor...")

    raw = state.get("raw_data")
    if not raw:
        state["extracted_events"] = None
        state["messages"].append("No raw_data provided; skipping event extraction")
        return state

    # Use a few retrieved events as context for the LLM
    context_lines = []
    for e in state.get("retrieved_events", [])[:5]:
        meta = e.get("metadata", {})
        event_type = meta.get("event_type", "unknown")
        actors = meta.get("actors", [])
        context_lines.append(f"- {event_type}: {actors}")

    context = "\n".join(context_lines)

    prompt = f"""
You are an analyst extracting conflict events from reports.

CONTEXT (recent similar events):
{context}

TEXT TO ANALYZE:
{raw}

Extract events as JSON. Use this exact schema:

{{
  "events": [
    {{
      "event_type": "string",
      "date": "YYYY-MM-DD or null",
      "location": "string or null",
      "actors": ["Actor A", "Actor B"],
      "fatalities": 0
    }}
  ],
  "confidence": 0.0
}}
"""

    response = llm.invoke([
        SystemMessage(content="Extract conflict events from the text. Output JSON ONLY."),
        HumanMessage(content=prompt),
    ])

    try:
        result = json.loads(response.content)
        state["extracted_events"] = result
        n = len(result.get("events", []))
        state["messages"].append(f"Extracted {n} events from raw_data")
    except Exception as e:
        state["extracted_events"] = {"error": "parse_failed", "raw": response.content}
        state["messages"].append(f"âš ï¸ Event extraction JSON parse failed: {e}")

    return state


def trend_analyst_node(state: SudanCRAMState) -> SudanCRAMState:
    """Analyze trends using the retrieved events timeline."""
    print("\nðŸ“Š Trend Analyst...")

    # Build a simple timeline summary
    timeline_lines = []
    for e in sorted(
        state.get("retrieved_events", []),
        key=lambda x: x.get("metadata", {}).get("date", ""),
    )[:15]:
        meta = e.get("metadata", {})
        date = meta.get("date", "unknown_date")
        event_type = meta.get("event_type", "unknown_type")
        fatalities = meta.get("fatalities", 0)
        timeline_lines.append(f"{date}: {event_type} ({fatalities} fatalities)")

    timeline = "\n".join(timeline_lines)

    prompt = f"""
You are a conflict trend analyst for Sudan.

REGION: {state['region']}

EVENT TIMELINE:
{timeline}

Analyze trends and produce JSON ONLY in this schema:

{{
  "trend_classification": "ESCALATING" | "STABLE" | "DEESCALATING" | "VOLATILE",
  "drivers": ["short bullet point string", "..."],
  "forecast_7_days": {{
    "armed_clash_likelihood": 0-100,
    "civilian_targeting_likelihood": 0-100
  }},
  "confidence": "LOW" | "MEDIUM" | "HIGH"
}}
"""

    response = llm.invoke([
        SystemMessage(content="Analyze conflict trends and output JSON ONLY."),
        HumanMessage(content=prompt),
    ])

    try:
        result = json.loads(response.content)
        state["trend_analysis"] = result
        state["messages"].append(
            f"Trend classification: {result.get('trend_classification', 'UNKNOWN')}"
        )
    except Exception as e:
        state["trend_analysis"] = {"error": "parse_failed", "raw": response.content}
        state["messages"].append(f"âš ï¸ Trend analysis JSON parse failed: {e}")

    return state


def scenario_generator_node(state: SudanCRAMState) -> SudanCRAMState:
    """Generate intervention scenarios."""
    print("\nðŸ”® Scenario Generator...")

    interventions = state.get("interventions")
    if not interventions:
        state["scenarios"] = None
        state["messages"].append("No interventions provided; skipping scenario generation")
        return state

    trend = state.get("trend_analysis")

    prompt = f"""
You are advising on conflict response options in {state['region']}.

CURRENT TREND (may be null):
{json.dumps(trend, ensure_ascii=False, indent=2)}

INTERVENTIONS TO EVALUATE:
{chr(10).join(f"- {i}" for i in interventions)}

Return JSON ONLY with this schema:

{{
  "scenarios": [
    {{
      "intervention": "string",
      "optimistic": {{
        "description": "string",
        "success_probability": 0-100
      }},
      "pessimistic": {{
        "description": "string",
        "risk_probability": 0-100
      }},
      "recommendation": "PROCEED" | "MODIFY" | "AVOID"
    }}
  ]
}}
"""

    response = llm.invoke([
        SystemMessage(content="Generate policy scenarios and output JSON ONLY."),
        HumanMessage(content=prompt),
    ])

    try:
        result = json.loads(response.content)
        state["scenarios"] = result
        n = len(result.get("scenarios", []))
        state["messages"].append(f"Generated {n} scenarios")
    except Exception as e:
        state["scenarios"] = {"error": "parse_failed", "raw": response.content}
        state["messages"].append(f"âš ï¸ Scenario generation JSON parse failed: {e}")

    return state


def consistency_checker_node(state: SudanCRAMState) -> SudanCRAMState:
    """Check for contradictions and produce an overall confidence score."""
    print("\nâœ… Consistency Checker...")

    payload = {
        "events": state.get("extracted_events"),
        "trends": state.get("trend_analysis"),
        "scenarios": state.get("scenarios"),
    }

    prompt = f"""
You are checking internal consistency of an analysis.

DATA:
{json.dumps(payload, ensure_ascii=False, indent=2)}

Identify contradictions or weak assumptions.

Return JSON ONLY:

{{
  "validation_status": "PASSED" | "WARNING" | "FAILED",
  "issues": [
    {{
      "type": "INCONSISTENCY" | "DATA_GAP",
      "description": "string",
      "severity": "LOW" | "MEDIUM" | "HIGH"
    }}
  ],
  "overall_confidence": 0.0-1.0
}}
"""

    response = llm.invoke([
        SystemMessage(content="Validate consistency and output JSON ONLY."),
        HumanMessage(content=prompt),
    ])

    try:
        result = json.loads(response.content)
        state["validation"] = result
        state["confidence_score"] = float(result.get("overall_confidence", 0.5))
        state["messages"].append(
            f"Validation: {result.get('validation_status', 'UNKNOWN')} "
            f"(confidence={state['confidence_score']:.2f})"
        )
    except Exception as e:
        state["validation"] = {"error": "parse_failed", "raw": response.content}
        state["confidence_score"] = 0.5
        state["messages"].append(f"âš ï¸ Validation JSON parse failed: {e}")

    return state


def human_approval_node(state: SudanCRAMState) -> SudanCRAMState:
    """Decide if human approval is required based on confidence."""
    print("\nðŸ‘¤ Human Approval Check...")

    conf = state.get("confidence_score", 0.0)

    if conf < 0.7:
        state["human_approval_required"] = True
        state["approval_status"] = "pending"
        state["messages"].append(
            f"âš ï¸ Human approval required (confidence={conf:.2f})"
        )
    else:
        state["human_approval_required"] = False
        state["approval_status"] = "auto-approved"
        state["messages"].append(
            f"âœ… Auto-approved (confidence={conf:.2f})"
        )

    return state


def should_request_human_input(state: SudanCRAMState) -> str:
    """Routing function for LangGraph conditional edge."""
    return "request_approval" if state.get("human_approval_required") else "finalize"

### ./backend/app/agents/state.py ###
from typing import TypedDict, List, Dict, Optional, Annotated
from operator import add

class SudanCRAMState(TypedDict):
    # Input
    region: str
    raw_data: Optional[str]
    interventions: Optional[List[str]]

    # RAG Context
    retrieved_events: List[Dict]

    # Agent Outputs
    extracted_events: Optional[Dict]
    trend_analysis: Optional[Dict]
    scenarios: Optional[Dict]
    validation: Optional[Dict]

    # Control
    human_approval_required: bool
    approval_status: Optional[str]

    # Metadata
    messages: Annotated[List[str], add]
    confidence_score: float
    timestamp: str

    # NEW: lightweight explainability snapshot for frontend / analysts
    explainability: Optional[Dict]

### ./backend/app/agents/trend_forecasting_agent.py ###
from typing import List, Optional
from sqlalchemy.orm import Session
import logging

from app.api.models.trend_models import EscalationRiskSummary
from app.core import trend_analysis
from app.core.prophet_preparation import prepare_time_series_for_prophet
from app.core.forecasting import ProphetForecaster


class TrendForecastingAgent:
    def __init__(self, db_session: Session):
        self.db = db_session
        self.historical_df = None
        self.forecasters = {}

    def ingest(self, region: Optional[str] = None):
        self.historical_df = trend_analysis.load_events_from_db(self.db, region=region)

    def calculate_escalation_risk(self) -> List[EscalationRiskSummary]:
        if self.historical_df is None or self.historical_df.empty:
            raise RuntimeError("No historical data ingested.")

        risk_df = trend_analysis.calculate_escalation_risk(self.historical_df)

        risk_summaries = []
        for _, row in risk_df.iterrows():
            summary = EscalationRiskSummary(
                region=row['location'],
                risk_score=row['escalation_risk'],
                risk_level=row['risk_level'],
                explanation=(
                    f"Risk score based on avg Goldstein {row['avg_goldstein']:.2f}, "
                    f"Goldstein trend {row['goldstein_trend']:.2f}, "
                    f"event count {row['event_count']} and media mentions {row['media_mentions']}."
                ),
                forecasted_trend=None,
                confidence_interval=None
            )
            risk_summaries.append(summary)
        return risk_summaries

    def train_forecast_model(self, region: str):
        logging.info(f"Training forecast model for region: {region}")

        ts_df = prepare_time_series_for_prophet(self.db, region=region, time_freq='D')
        if ts_df.empty:
            raise RuntimeError(f"No time series data for Prophet training in region {region}")

        prophet_model = ProphetForecaster()
        prophet_model.train(ts_df)

        self.forecasters[region] = prophet_model
        logging.info(f"Model trained for region: {region}")

    def predict_trends(self, region: str, periods: int = 30) -> Optional[dict]:
        if region not in self.forecasters:
            logging.info(f"No Prophet model for {region}, training now.")
            self.train_forecast_model(region)

        prophet_model = self.forecasters.get(region)
        if not prophet_model:
            logging.warning(f"Prophet model not found for {region}")
            return None

        forecast_df = prophet_model.predict(periods=periods)
        last_forecast = forecast_df.iloc[-1]

        forecasted_trend = last_forecast['yhat']
        confidence_interval = (last_forecast['yhat_lower'], last_forecast['yhat_upper'])

        return {
            'forecasted_trend': forecasted_trend,
            'confidence_interval': confidence_interval
        }

    def output_with_forecast(self, region: Optional[str] = None, forecast_periods: int = 30) -> List[EscalationRiskSummary]:
        self.ingest(region=region)
        risk_summaries = self.calculate_escalation_risk()

        if region:
            region_lower = region.lower()
            risk_summaries = [rs for rs in risk_summaries if region_lower in rs.region.lower()]

        for summary in risk_summaries:
            region_name = summary.region
            try:
                forecast_data = self.predict_trends(region_name, periods=forecast_periods)
                if forecast_data:
                    summary.forecasted_trend = forecast_data['forecasted_trend']
                    summary.confidence_interval = forecast_data['confidence_interval']
            except Exception as e:
                print(f"Forecast error for {region_name}: {e}")
                summary.forecasted_trend = None
                summary.confidence_interval = None

        return risk_summaries


### ./backend/app/agents/workflow.py ###
from datetime import datetime
import json
import os
from typing import Any, Dict, List, Optional

from langchain_ollama import ChatOllama
from langchain_core.messages import HumanMessage, SystemMessage
from langgraph.graph import StateGraph, END

from app.agents.state import SudanCRAMState
from app.services.vector_store import VectorStore


# ---- 1. LLM + Vector Store setup (LAZY, for fast startup) ----
# We keep *only* lightweight globals at import time. Heavy objects are created on-demand.

_llm: Optional[ChatOllama] = None
_vector_store: Optional[VectorStore] = None


def _get_llm() -> ChatOllama:
    """
    Lazily initialize the LLM client.

    This avoids hitting the Ollama server at import time, which can slow down or
    break startup on platforms like Render if the model server is slow/unavailable.
    """
    global _llm
    if _llm is None:
        print("ðŸ§  Initializing LLM client (lazy)...")
        _llm = ChatOllama(
            model=os.getenv("OLLAMA_MODEL", "qwen2.5:14b"),
            base_url=os.getenv("OLLAMA_BASE_URL", "http://localhost:11434"),
            temperature=0.7,
        )
    return _llm


def _get_vector_store() -> VectorStore:
    """
    Lazily initialize the VectorStore.

    This avoids heavy embedding/model loading at import time, which can cause
    cloud platforms like Render to think the service isn't listening on a port yet.
    """
    global _vector_store
    if _vector_store is None:
        print("ðŸ”§ Initializing Vector Store (lazy)...")
        _vector_store = VectorStore()
    return _vector_store


# ---- Small helper: build canonical events timeline ----

def _build_events_timeline_from_retrieved(
    retrieved_events: List[Dict[str, Any]]
) -> List[Dict[str, Any]]:
    """Turn raw vector-store hits into a canonical events timeline."""
    events_timeline: List[Dict[str, Any]] = []
    for e in sorted(
        retrieved_events,
        key=lambda x: x.get("metadata", {}).get("date", ""),
    ):
        meta = e.get("metadata", {})
        events_timeline.append(
            {
                "date": meta.get("date"),
                "source": meta.get("source", "GDELT"),
                "region": meta.get("region"),
                "event_type": meta.get("event_type"),
                "actors": meta.get("actors", []),
                "fatalities": meta.get("fatalities"),
            }
        )
    return events_timeline


# ---- 2. Nodes ----

def rag_retrieval_node(state: SudanCRAMState) -> SudanCRAMState:
    """Retrieve relevant events from Qdrant for the given region."""
    print("\nðŸ” RAG Retrieval...")

    vs = _get_vector_store()
    region = state["region"]

    # First: try region-focused search
    region_query = f"conflict events in {region}"
    region_results = vs.semantic_search(
        query=region_query,
        filters={"region": region},
        top_k=20,
    )

    if region_results:
        results = region_results
        state["messages"].append(
            f"Retrieved {len(results)} region-focused events for {region}"
        )
    else:
        # Fallback: national context if nothing region-specific is found
        results = vs.semantic_search(
            query=region_query,
            filters=None,
            top_k=20,
        )
        state["messages"].append(
            "No region-specific matches; used Sudan-wide context instead"
        )
        state["messages"].append(
            f"Retrieved {len(results)} events for region {region}"
        )

    state["retrieved_events"] = results

    # âœ… Build canonical events timeline early so all downstream nodes see it
    state["events"] = _build_events_timeline_from_retrieved(results)

    return state


def event_extractor_node(state: SudanCRAMState) -> SudanCRAMState:
    """Extract structured events from raw text, using retrieved events as context."""
    print("\nðŸ“ Event Extractor...")

    raw = state.get("raw_data")
    if not raw:
        state["extracted_events"] = None
        state["messages"].append("No raw_data provided; skipping event extraction")
        return state

    llm = _get_llm()

    # Use a few retrieved events as context for the LLM
    context_lines = []
    for e in state.get("retrieved_events", [])[:5]:
        meta = e.get("metadata", {})
        event_type = meta.get("event_type", "unknown")
        actors = meta.get("actors", [])
        context_lines.append(f"- {event_type}: {actors}")

    context = "\n".join(context_lines)

    prompt = f"""
You are an analyst extracting conflict events from reports.

CONTEXT (recent similar events):
{context}

TEXT TO ANALYZE:
{raw}

Extract events as JSON. Use this exact schema:

{{
  "events": [
    {{
      "event_type": "string",
      "date": "YYYY-MM-DD or null",
      "location": "string or null",
      "actors": ["Actor A", "Actor B"],
      "fatalities": 0
    }}
  ],
  "confidence": 0.0
}}
"""

    response = llm.invoke(
        [
            SystemMessage(content="Extract conflict events from the text. Output JSON ONLY."),
            HumanMessage(content=prompt),
        ]
    )

    try:
        result = json.loads(response.content)
        state["extracted_events"] = result
        n = len(result.get("events", []))
        state["messages"].append(f"Extracted {n} events from raw_data")
    except Exception as e:
        state["extracted_events"] = {"error": "parse_failed", "raw": response.content}
        state["messages"].append(f"âš ï¸ Event extraction JSON parse failed: {e}")

    return state


def trend_analyst_node(state: SudanCRAMState) -> SudanCRAMState:
    """Analyze trends using the retrieved events timeline."""
    print("\nðŸ“Š Trend Analyst...")

    llm = _get_llm()

    # Build a simple timeline summary directly from retrieved_events
    timeline_lines: List[str] = []
    for e in sorted(
        state.get("retrieved_events", []),
        key=lambda x: x.get("metadata", {}).get("date", ""),
    )[:15]:
        meta = e.get("metadata", {})
        date = meta.get("date", "unknown_date")
        event_type = meta.get("event_type", "unknown_type")
        fatalities = meta.get("fatalities")
        if fatalities is None:
            fat_str = "fatalities unknown"
        else:
            fat_str = f"{fatalities} fatalities"
        timeline_lines.append(f"{date}: {event_type} ({fat_str})")

    timeline = "\n".join(timeline_lines)

    prompt = f"""
You are a conflict trend analyst for Sudan.

REGION: {state['region']}

EVENT TIMELINE:
{timeline}

Analyze trends and produce JSON ONLY in this schema:

{{
  "trend_classification": "ESCALATING" | "STABLE" | "DEESCALATING" | "VOLATILE",
  "drivers": ["short bullet point string", "..."],
  "forecast_7_days": {{
    "armed_clash_likelihood": 0-100,
    "civilian_targeting_likelihood": 0-100
  }},
  "confidence": "LOW" | "MEDIUM" | "HIGH"
}}
"""

    response = llm.invoke(
        [
            SystemMessage(content="Analyze conflict trends and output JSON ONLY."),
            HumanMessage(content=prompt),
        ]
    )

    try:
        result = json.loads(response.content)
        state["trend_analysis"] = result
        state["messages"].append(
            f"Trend classification: {result.get('trend_classification', 'UNKNOWN')}"
        )
    except Exception as e:
        state["trend_analysis"] = {"error": "parse_failed", "raw": response.content}
        state["messages"].append(f"âš ï¸ Trend analysis JSON parse failed: {e}")

    return state


def scenario_generator_node(state: SudanCRAMState) -> SudanCRAMState:
    """Generate intervention scenarios."""
    print("\nðŸ”® Scenario Generator...")

    interventions = state.get("interventions")
    if not interventions:
        state["scenarios"] = None
        state["messages"].append(
            "No interventions provided; skipping scenario generation"
        )
        return state

    llm = _get_llm()
    trend = state.get("trend_analysis")

    prompt = f"""
You are advising on conflict response options in {state['region']}.

CURRENT TREND (may be null):
{json.dumps(trend, ensure_ascii=False, indent=2)}

INTERVENTIONS TO EVALUATE:
{chr(10).join(f"- {i}" for i in interventions)}

Return JSON ONLY with this schema:

{{
  "scenarios": [
    {{
      "intervention": "string",
      "optimistic": {{
        "description": "string",
        "success_probability": 0-100
      }},
      "pessimistic": {{
        "description": "string",
        "risk_probability": 0-100
      }},
      "recommendation": "PROCEED" | "MODIFY" | "AVOID"
    }}
  ]
}}
"""

    response = llm.invoke(
        [
            SystemMessage(content="Generate policy scenarios and output JSON ONLY."),
            HumanMessage(content=prompt),
        ]
    )

    try:
        result = json.loads(response.content)
        state["scenarios"] = result
        n = len(result.get("scenarios", []))
        state["messages"].append(f"Generated {n} scenarios")
    except Exception as e:
        state["scenarios"] = {"error": "parse_failed", "raw": response.content}
        state["messages"].append(f"âš ï¸ Scenario generation JSON parse failed: {e}")

    return state


def consistency_checker_node(state: SudanCRAMState) -> SudanCRAMState:
    """Check for contradictions and produce an overall confidence score."""
    print("\nâœ… Consistency Checker...")

    llm = _get_llm()

    events = state.get("events") or []
    trends = state.get("trend_analysis") or {}
    scenarios = state.get("scenarios") or {}

    # ---- Heuristic: detect "STABLE trend + high escalation risk" ----
    max_escalation_prob: Optional[float] = None

    # 1) From trend forecast (armed clashes / civilian targeting)
    forecast = (trends or {}).get("forecast_7_days") or {}
    for key in ("armed_clash_likelihood", "civilian_targeting_likelihood"):
        v = forecast.get(key)
        if isinstance(v, (int, float)):
            max_escalation_prob = (
                v if max_escalation_prob is None else max(max_escalation_prob, v)
            )

    # 2) From pessimistic scenario risk probabilities
    for s in (scenarios.get("scenarios") or []):
        pess = (s or {}).get("pessimistic") or {}
        rp = pess.get("risk_probability")
        if isinstance(rp, (int, float)):
            max_escalation_prob = (
                rp if max_escalation_prob is None else max(max_escalation_prob, rp)
            )

    trend_label = trends.get("trend_classification")
    escalation_flag_threshold = 60  # can be tuned later

    stable_with_high_escalation = (
        trend_label == "STABLE"
        and max_escalation_prob is not None
        and max_escalation_prob >= escalation_flag_threshold
    )

    consistency_hints: Dict[str, Any] = {
        "trend_classification": trend_label,
        "max_escalation_probability": max_escalation_prob,
        "stable_with_high_escalation": stable_with_high_escalation,
        "escalation_flag_threshold": escalation_flag_threshold,
        "num_events": len(events),
    }

    payload = {
        "events": events,
        "trends": trends,
        "scenarios": scenarios,
        "consistency_hints": consistency_hints,
    }

    prompt = f"""
You are checking internal consistency of a conflict risk analysis.

DATA (JSON):
{json.dumps(payload, ensure_ascii=False, indent=2)}

Guidelines (important):

1) About the events list:
- If "events" is null or an empty list, you may treat this as a DATA_GAP.
- If "events" contains items, DO NOT say it is null or missing. Instead, treat it as observed data.

2) About escalation vs trend:
- The field "consistency_hints.stable_with_high_escalation" indicates whether the system detected:
  â€¢ trend_classification == "STABLE"
  â€¢ AND a high max escalation probability (>= consistency_hints.escalation_flag_threshold)
- If this flag is true, you MUST treat this as a likely inconsistency between:
  â€¢ the trend label ("STABLE"), and
  â€¢ the escalation probabilities (forecast and/or scenario risk probabilities).
- In that case, explicitly state in "issues" whether:
  â€¢ the trend label is probably too mild and should be closer to "VOLATILE" or "ESCALATING", OR
  â€¢ the escalation probabilities (forecast and/or scenarios) are probably too high for a truly "STABLE" trend.

3) General rules:
- Base your reasoning strictly on the DATA above (do not invent fields).
- Focus on mismatches between:
  â€¢ events (if present),
  â€¢ trend classification and probabilities,
  â€¢ scenario success / risk probabilities.
- If everything is internally coherent, you may return "PASSED" with no issues.

Return JSON ONLY:

{{
  "validation_status": "PASSED" | "WARNING" | "FAILED",
  "issues": [
    {{
      "type": "INCONSISTENCY" | "DATA_GAP",
      "description": "string",
      "severity": "LOW" | "MEDIUM" | "HIGH"
    }}
  ],
  "overall_confidence": 0.0-1.0
}}
"""

    response = llm.invoke(
        [
            SystemMessage(content="Validate consistency and output JSON ONLY."),
            HumanMessage(content=prompt),
        ]
    )

    try:
        result = json.loads(response.content)
        state["validation"] = result
        state["confidence_score"] = float(result.get("overall_confidence", 0.5))
        state["messages"].append(
            f"Validation: {result.get('validation_status', 'UNKNOWN')} "
            f"(confidence={state['confidence_score']:.2f})"
        )
    except Exception as e:
        state["validation"] = {"error": "parse_failed", "raw": response.content}
        state["confidence_score"] = 0.5
        state["messages"].append(f"âš ï¸ Validation JSON parse failed: {e}")

    return state


def human_approval_node(state: SudanCRAMState) -> SudanCRAMState:
    """Decide if human approval is required based on confidence."""
    print("\nðŸ‘¤ Human Approval Check...")

    conf = state.get("confidence_score", 0.0)

    if conf < 0.7:
        state["human_approval_required"] = True
        state["approval_status"] = "pending"
        state["messages"].append(
            f"âš ï¸ Human approval required (confidence={conf:.2f})"
        )
    else:
        state["human_approval_required"] = False
        state["approval_status"] = "auto-approved"
        state["messages"].append(f"âœ… Auto-approved (confidence={conf:.2f})")

    return state


def should_request_human_input(state: SudanCRAMState) -> str:
    """
    Routing function for LangGraph conditional edge.

    Use the same confidence threshold as human_approval_node.
    """
    conf = state.get("confidence_score", 0.0)
    return "request_approval" if conf < 0.7 else "finalize"


# ---- 3. Graph wiring ----

builder = StateGraph(SudanCRAMState)

builder.add_node("rag_retrieval", rag_retrieval_node)
builder.add_node("event_extractor", event_extractor_node)
builder.add_node("trend_analyst", trend_analyst_node)
builder.add_node("scenario_generator", scenario_generator_node)
builder.add_node("consistency_checker", consistency_checker_node)
builder.add_node("human_approval", human_approval_node)

builder.set_entry_point("rag_retrieval")
builder.add_edge("rag_retrieval", "event_extractor")
builder.add_edge("event_extractor", "trend_analyst")
builder.add_edge("trend_analyst", "scenario_generator")
builder.add_edge("scenario_generator", "consistency_checker")

builder.add_conditional_edges(
    "consistency_checker",
    should_request_human_input,
    {
        "request_approval": "human_approval",
        "finalize": END,
    },
)

app = builder.compile()


# ---- 4. Explainability helper ----

def _build_explainability_payload(state: SudanCRAMState) -> Dict[str, Any]:
    events = state.get("events") or []
    trends = state.get("trend_analysis") or {}
    scenarios = state.get("scenarios") or {}
    validation = state.get("validation") or {}

    # Time span in days based on events
    if events:
        dates = [e.get("date") for e in events if e.get("date")]
        try:
            parsed = [datetime.fromisoformat(d) for d in dates]
            time_span_days = (max(parsed) - min(parsed)).days
        except Exception:
            time_span_days = None
    else:
        time_span_days = None

    # Scenario stats
    scenario_list = scenarios.get("scenarios") or []
    max_success = None
    max_risk = None
    recs: List[str] = []
    for s in scenario_list:
        optimistic = (s or {}).get("optimistic") or {}
        pessimistic = (s or {}).get("pessimistic") or {}
        success_prob = optimistic.get("success_probability")
        risk_prob = pessimistic.get("risk_probability")
        if success_prob is not None:
            max_success = (
                success_prob
                if max_success is None
                else max(max_success, success_prob)
            )
        if risk_prob is not None:
            max_risk = (
                risk_prob if max_risk is None else max(max_risk, risk_prob)
            )
        rec = (s or {}).get("recommendation")
        if rec:
            recs.append(rec)

    explainability: Dict[str, Any] = {
        "input": {
            "region": state.get("region"),
            "has_raw_data": bool(state.get("raw_data")),
            "interventions_count": len(state.get("interventions") or []),
            "interventions": state.get("interventions") or [],
        },
        "retrieval": {
            "total_events_considered": len(events),
            "sources": {
                "GDELT": len(events),
            },
            "time_span_days": time_span_days,
        },
        "trend": {
            "trend_classification": trends.get("trend_classification"),
            "confidence_label": trends.get("confidence"),
            "drivers": trends.get("drivers") or [],
            "forecast_7_days": trends.get("forecast_7_days") or {},
        },
        "scenarios": {
            "num_scenarios": len(scenario_list),
            "recommendations": recs,
            "max_success_probability": max_success,
            "max_risk_probability": max_risk,
        },
        "validation": {
            "status": validation.get("validation_status"),
            "issue_count": len(validation.get("issues") or []),
            "issues": validation.get("issues") or [],
            "overall_confidence": validation.get("overall_confidence"),
        },
        "meta": {
            "pipeline_confidence_score": state.get("confidence_score"),
            "timestamp": datetime.utcnow().isoformat(),
        },
    }

    return explainability


# ---- 5. Public API ----

def run_analysis(
    region: str,
    raw_data: Optional[str] = None,
    interventions: Optional[List[str]] = None,
) -> Dict[str, Any]:
    """Entry point used by both CLI and FastAPI to run the workflow."""
    print("\n" + "=" * 60)
    print(f"ðŸš€ LANGGRAPH WORKFLOW START: {region}")
    print("=" * 60)

    initial_state: SudanCRAMState = {
        "region": region,
        "raw_data": raw_data,
        "interventions": interventions or [],
        "retrieved_events": [],
        "events": [],
        "extracted_events": None,
        "trend_analysis": None,
        "scenarios": None,
        "validation": None,
        "human_approval_required": False,
        "approval_status": None,
        "messages": [],
        "confidence_score": 0.0,
    }

    final_state = app.invoke(initial_state)

    # Ensure events timeline is set from retrieved_events (authoritative)
    retrieved_events = final_state.get("retrieved_events") or []
    final_state["events"] = _build_events_timeline_from_retrieved(retrieved_events)

    print("\n" + "=" * 60)
    print("âœ… WORKFLOW COMPLETE")
    print("=" * 60)

    # Deduplicate messages while preserving order
    seen = set()
    dedup_messages: List[str] = []
    for m in final_state.get("messages", []):
        if m not in seen:
            seen.add(m)
            dedup_messages.append(m)

    explainability = _build_explainability_payload(final_state)
    timestamp = explainability["meta"]["timestamp"]

    return {
        "region": final_state["region"],
        "raw_data": final_state.get("raw_data"),
        "interventions": final_state.get("interventions") or [],
        "retrieved_events": retrieved_events,
        "events": final_state.get("events") or [],
        "trend_analysis": final_state.get("trend_analysis"),
        "scenarios": final_state.get("scenarios"),
        "validation": final_state.get("validation"),
        "approval_status": final_state.get("approval_status"),
        "confidence_score": final_state.get("confidence_score", 0.0),
        "messages": dedup_messages,
        "timestamp": timestamp,
        "explainability": explainability,
    }

### ./backend/app/api/__init__.py ###

### ./backend/app/api/models/__init__.py ###

### ./backend/app/api/models/event_models.py ###
from typing import List, Optional
from pydantic import BaseModel

class Actor(BaseModel):
    name: str
    role: Optional[str] = None

class AnnotatedEvent(BaseModel):
    event_id: str
    date: str  # ISO 8601 date string (e.g., "2025-10-01T00:00:00Z")
    location: str  # Normalized location name
    actors: List[Actor]
    event_type: str  # Event code or category
    severity: Optional[float] = None  # e.g., Goldstein scale score
    sources: Optional[List[str]] = None  # Source URLs or references
    annotations: Optional[dict] = None  # Additional metadata or tags

### ./backend/app/api/models/trend_models.py ###
from pydantic import BaseModel, Field
from typing import Optional, Tuple


class EscalationRiskSummary(BaseModel):
    region: str
    risk_score: float
    risk_level: str
    explanation: str
    forecasted_trend: Optional[float] = None
    confidence_interval: Optional[Tuple[float, float]] = None


class ForecastResponse(BaseModel):
    region: str = Field(..., description="Region name for the forecast")
    forecast_periods: int = Field(..., description="Number of forecast periods")
    forecasted_trend: float = Field(..., description="Predicted trend value at the end of forecast period")
    confidence_interval: Tuple[float, float] = Field(..., description="Lower and upper confidence interval bounds")

    class Config:
        json_schema_extra = {
            "example": {
                "region": "Khartoum, Al Khartum, Sudan",
                "forecast_periods": 30,
                "forecasted_trend": 5.2,
                "confidence_interval": [3.1, 7.3]
            }
        }

### ./backend/app/api/routes/__init__.py ###

### ./backend/app/api/routes/trend_routes.py ###
from typing import List, Optional

from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy.orm import Session

from database import get_db
from app.agents.trend_forecasting_agent import TrendForecastingAgent
from app.api.models.trend_models import EscalationRiskSummary, ForecastResponse

router = APIRouter(
    prefix="/trend",
    tags=["Trend Analysis"]
)


@router.get(
    "/risk",
    response_model=List[EscalationRiskSummary],
    summary="Get escalation risk summaries by region",
    description="Calculate and retrieve escalation risk scores and levels for conflict regions. Optionally filter by region name."
)
def get_trend_risk(
    region: Optional[str] = Query(None, description="Filter risk by region name"),
    include_forecast: bool = Query(False, description="Include forecast data in response"),
    forecast_periods: int = Query(30, description="Number of periods to forecast (if include_forecast=True)"),
    db: Session = Depends(get_db)
):
    """
    Endpoint to retrieve escalation risk summaries for conflict events.
    Optionally includes forecast data with confidence intervals.

    Args:
        region (str, optional): Region name to filter risk calculation.
        include_forecast (bool): Whether to include forecast predictions.
        forecast_periods (int): Number of forecast periods (default 30 days).
        db (Session): Database session injected by FastAPI dependency.

    Returns:
        List[EscalationRiskSummary]: List of risk summaries per region with optional forecasts.
    """
    agent = TrendForecastingAgent(db_session=db)

    try:
        if include_forecast:
            # Use the forecast-enhanced output
            risks = agent.output_with_forecast(region=region, forecast_periods=forecast_periods)
        else:
            # Standard risk calculation without forecasts
            agent.ingest(region=region)
            risks = agent.calculate_escalation_risk()
        
        return risks
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error calculating escalation risk: {str(e)}"
        )


@router.get(
    "/forecast",
    response_model=ForecastResponse,
    summary="Get time-series forecast for a specific region",
    description="Generate Prophet-based forecasts with confidence intervals for event trends in a specific region."
)
def get_forecast(
    region: str = Query(..., description="Region name for forecasting (required)"),
    periods: int = Query(30, ge=1, le=365, description="Number of forecast periods (1-365 days)"),
    db: Session = Depends(get_db)
):
    """
    Endpoint to generate and retrieve time-series forecasts for a specific region.

    Args:
        region (str): Region name (required).
        periods (int): Number of periods to forecast (1-365, default 30).
        db (Session): Database session injected by FastAPI dependency.

    Returns:
        ForecastResponse: Forecast data with predictions and confidence intervals.
    """
    agent = TrendForecastingAgent(db_session=db)

    try:
        forecast_data = agent.predict_trends(region=region, periods=periods)
        
        if not forecast_data:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Unable to generate forecast for region: {region}"
            )

        return ForecastResponse(
            region=region,
            forecast_periods=periods,
            forecasted_trend=forecast_data['forecasted_trend'],
            confidence_interval=forecast_data['confidence_interval']
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Error generating forecast: {str(e)}"
        )

### ./backend/app/core/__init__.py ###
"""
Utility modules for Sudan CRAM Dashboard
"""

from .data_loader import (
    load_conflict_proneness,
    load_acled_events,
    load_causes_by_state,
    get_summary_stats,
    get_events_by_month
)

__all__ = [
    'load_conflict_proneness',
    'load_acled_events', 
    'load_causes_by_state',
    'get_summary_stats',
    'get_events_by_month'
]

### ./backend/app/core/actor_normalizer.py ###
"""
Actor Name Normalization Utility
Ensures consistent and standardized naming of actors (armed groups, political entities)
across all conflict event annotations.
"""

# Mapping of common actor name variants to canonical names
ACTOR_MAPPINGS = {
    'SPLA': 'Sudan Peopleâ€™s Liberation Army',
    'JEM': 'Justice and Equality Movement',
    'RSF': 'Rapid Support Forces',
    'SPLM-N': 'Sudan Peopleâ€™s Liberation Movement-North',
    'SPLM': 'Sudan Peopleâ€™s Liberation Movement',
    'SAF': 'Sudanese Armed Forces',
    'NCP': 'National Congress Party',
    # Add more known mappings based on your domain knowledge
}

def normalize_actor(name: str) -> str:
    """
    Normalize actor name to a canonical form.

    Args:
        name (str): Raw actor name (may contain abbreviations or variants)

    Returns:
        str: Normalized actor name or original if no mapping found
    """
    if not name or not isinstance(name, str):
        return name

    candidate = name.strip().upper()
    normalized = ACTOR_MAPPINGS.get(candidate) or ACTOR_MAPPINGS.get(name.strip()) or name.strip()

    return normalized

### ./backend/app/core/forecasting.py ###
import logging
from typing import Optional, Tuple
import pandas as pd
from prophet import Prophet
from prophet.diagnostics import cross_validation, performance_metrics


class ProphetForecaster:
    def __init__(self):
        self.model: Optional[Prophet] = None
        self.is_trained: bool = False

    def train(self, ts_df: pd.DataFrame, yearly_seasonality: bool = True, weekly_seasonality: bool = True, daily_seasonality: bool = False,
              changepoint_prior_scale: float = 0.05, holidays: Optional[pd.DataFrame] = None) -> None:
        if ts_df.empty:
            raise ValueError("Training dataframe is empty.")
        
        logging.info(f"Training Prophet model on {len(ts_df)} records.")

        self.model = Prophet(
            yearly_seasonality=yearly_seasonality,
            weekly_seasonality=weekly_seasonality,
            daily_seasonality=daily_seasonality,
            changepoint_prior_scale=changepoint_prior_scale,
            holidays=holidays
        )
        self.model.fit(ts_df)
        self.is_trained = True
        logging.info("Prophet model trained successfully.")

    def predict(self, periods: int = 30, freq: str = 'D') -> pd.DataFrame:
        if not self.is_trained or self.model is None:
            raise RuntimeError("Model has not been trained yet.")

        logging.info(f"Generating forecast for next {periods} periods with frequency '{freq}'.")

        future = self.model.make_future_dataframe(periods=periods, freq=freq)
        forecast = self.model.predict(future)

        results = forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']]
        return results

    def cross_validate(self, initial: str = '365 days', period: str = '30 days', horizon: str = '90 days') -> Tuple[pd.DataFrame, pd.DataFrame]:
        if not self.is_trained or self.model is None:
            raise RuntimeError("Model has not been trained yet.")

        logging.info(f"Performing cross-validation with initial={initial}, period={period}, horizon={horizon}.")
        
        cv_results = cross_validation(self.model, initial=initial, period=period, horizon=horizon)
        perf_metrics = performance_metrics(cv_results)

        return cv_results, perf_metrics

### ./backend/app/core/forecasting.py.old ###
import logging
from typing import Optional, Tuple
import pandas as pd
from prophet import Prophet
from prophet.diagnostics import cross_validation, performance_metrics


class ProphetForecaster:
    """
    Encapsulates training and forecasting functionality using the Prophet model.
    """

    def __init__(self):
        self.model: Optional[Prophet] = None
        self.is_trained: bool = False

    def train(self, ts_df: pd.DataFrame, yearly_seasonality: bool = True, weekly_seasonality: bool = True, daily_seasonality: bool = False,
              changepoint_prior_scale: float = 0.05, holidays: Optional[pd.DataFrame] = None) -> None:
        """
        Train the Prophet model on historical time series data.

        Args:
            ts_df (pd.DataFrame): DataFrame with columns ['ds', 'y'] for training.
            yearly_seasonality (bool): Whether to include yearly seasonality.
            weekly_seasonality (bool): Whether to include weekly seasonality.
            daily_seasonality (bool): Whether to include daily seasonality.
            changepoint_prior_scale (float): Flexibility of automatic changepoint detection.
            holidays (pd.DataFrame, optional): DataFrame specifying holidays.
        """
        if ts_df.empty:
            raise ValueError("Training dataframe is empty.")
        
        logging.info(f"Training Prophet model on {len(ts_df)} records.")

        self.model = Prophet(
            yearly_seasonality=yearly_seasonality,
            weekly_seasonality=weekly_seasonality,
            daily_seasonality=daily_seasonality,
            changepoint_prior_scale=changepoint_prior_scale,
            holidays=holidays
        )
        self.model.fit(ts_df)
        self.is_trained = True
        logging.info("Prophet model trained successfully.")

    def predict(self, periods: int = 30, freq: str = 'D') -> pd.DataFrame:
        """
        Generate forecasts for a given number of periods beyond the training data.

        Args:
            periods (int): Number of periods to forecast into the future.
            freq (str): Frequency string compatible with pandas offset aliases (e.g., 'D' for days).

        Returns:
            pd.DataFrame: Forecast results including 'ds', 'yhat', 'yhat_lower', 'yhat_upper'.
        """
        if not self.is_trained or self.model is None:
            raise RuntimeError("Model has not been trained yet.")

        logging.info(f"Generating forecast for next {periods} periods with frequency '{freq}'.")

        future = self.model.make_future_dataframe(periods=periods, freq=freq)
        forecast = self.model.predict(future)

        # Select relevant columns for output
        results = forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']]
        return results

    def cross_validate(self, initial: str = '365 days', period: str = '30 days', horizon: str = '90 days') -> Tuple[pd.DataFrame, pd.DataFrame]:
        """
        Perform cross-validation to assess forecasting performance.

        Args:
            initial (str): The size of the initial training period.
            period (str): The spacing between cutoff dates.
            horizon (str): The forecast horizon.

        Returns:
            Tuple[pd.DataFrame, pd.DataFrame]: Cross-validation results and performance metrics.
        """
        if not self.is_trained or self.model is None:
            raise RuntimeError("Model has not been trained yet.")

        logging.info(f"Performing cross-validation with initial={initial}, period={period}, horizon={horizon}.")
        
        cv_results = cross_validation(self.model, initial=initial, period=period, horizon=horizon)
        perf_metrics = performance_metrics(cv_results)

        return cv_results, perf_metrics

### ./backend/app/core/prophet_preparation.py ###
import pandas as pd
from sqlalchemy.orm import Session
from typing import Optional

from app.models.gdelt import GDELTEvent


def prepare_time_series_for_prophet(
    db: Session,
    region: Optional[str] = None,
    target_col: str = 'event_id',
    time_freq: str = 'D'
) -> pd.DataFrame:
    """
    Load historical events from the DB and prepare aggregated time series data
    for Prophet forecasting.

    Args:
        db (Session): SQLAlchemy DB session.
        region (Optional[str]): Region filter (partial match, case-insensitive).
        target_col (str): Column to use as forecast target ('event_id' count by default).
        time_freq (str): Time frequency for aggregation ('D'=daily, 'W'=weekly, 'M'=monthly).

    Returns:
        pd.DataFrame: Prepared DataFrame with columns ['ds', 'y'] suitable for Prophet.
    """
    # Step 1: Query raw events filtered by region
    query = db.query(GDELTEvent)
    if region:
        query = query.filter(GDELTEvent.region.ilike(f"%{region}%"))
    events = query.all()

    # Step 2: Convert to list of dict and then DataFrame
    data = []
    for e in events:
        d = e.__dict__.copy()
        d.pop('_sa_instance_state', None)
        data.append(d)

    df = pd.DataFrame(data)

    if df.empty:
        # Return empty DataFrame with expected columns
        return pd.DataFrame(columns=['ds', 'y'])

    # Step 3: Ensure date column is datetime
    if 'event_date' not in df.columns:
        raise ValueError("GDELTEvent objects must have 'event_date' field")

    df['event_date'] = pd.to_datetime(df['event_date'], errors='coerce')
    df = df[df['event_date'].notna()]

    # Step 4: Aggregate by period and region
    df['ds'] = df['event_date'].dt.to_period(time_freq).dt.to_timestamp()

    # Step 5: Aggregate target column
    if target_col == 'event_id':
        agg_series = df.groupby('ds').size()
    else:
        agg_series = df.groupby('ds')[target_col].sum()

    agg_df = agg_series.reset_index()
    agg_df.rename(columns={agg_df.columns[0]: "ds", agg_df.columns[1]: "y"}, inplace=True)

    # Step 6: Fill missing dates in the time series with zeros
    full_date_index = pd.date_range(start=agg_df['ds'].min(), end=agg_df['ds'].max(), freq=time_freq)
    agg_df = agg_df.set_index('ds').reindex(full_date_index, fill_value=0).rename_axis('ds').reset_index()

    return agg_df

### ./backend/app/core/state_name_normalizer.py ###
"""
State Name Normalization Utility
Ensures consistent spelling across all visualizations
"""

# State name mappings - normalize all variations to official spelling
STATE_NAME_MAPPINGS = {
    # Al Jazirah variations
    'Aj Jazirah': 'Al Jazirah',
    'Al-Jazirah': 'Al Jazirah',
    'Gezira': 'Al Jazirah',
    'Al Gezira': 'Al Jazirah',

    # Add other known variations if needed
    'River Nile': 'River Nile',
    'Northern': 'Northern',
    # Add lowercase variants for robustness
    'aj jazirah': 'Al Jazirah',
    'al-jazirah': 'Al Jazirah',
    'gezira': 'Al Jazirah',
    'al gezira': 'Al Jazirah',
}

# Official state names (18 states)
OFFICIAL_STATE_NAMES = [
    'Al Jazirah',
    'Blue Nile',
    'Central Darfur',
    'East Darfur',
    'Gedaref',
    'Kassala',
    'Khartoum',
    'North Darfur',
    'North Kordofan',
    'Northern',
    'Red Sea',
    'River Nile',
    'Sennar',
    'South Darfur',
    'South Kordofan',
    'West Darfur',
    'West Kordofan',
    'White Nile'
]

def normalize_state_name(state_name):
    """
    Normalize state name to official spelling

    Args:
        state_name (str): Input state name (any variation)

    Returns:
        str: Normalized state name
    """
    if not state_name or not isinstance(state_name, str):
        return state_name

    # Strip whitespace and lowercase for matching
    state_name_clean = state_name.strip()
    state_name_lower = state_name_clean.lower()

    # Check if already normalized (case-insensitive)
    for official in OFFICIAL_STATE_NAMES:
        if official.lower() == state_name_lower:
            return official

    # Apply mapping (case-insensitive)
    normalized = STATE_NAME_MAPPINGS.get(state_name_clean)
    if not normalized:
        normalized = STATE_NAME_MAPPINGS.get(state_name_lower)

    return normalized or state_name_clean

def normalize_dataframe_states(df, state_column):
    """
    Normalize all state names in a dataframe

    Args:
        df (pd.DataFrame): Input dataframe
        state_column (str): Name of column containing state names

    Returns:
        pd.DataFrame: Dataframe with normalized state names
    """
    import pandas as pd
    df = df.copy()

    if state_column in df.columns:
        df[state_column] = df[state_column].apply(normalize_state_name)

    return df

### ./backend/app/core/trend_analysis.py ###
import pandas as pd
from sqlalchemy.orm import Session
from typing import Optional

from app.models.gdelt import GDELTEvent  # Ensure this import matches your structure


def load_events_from_db(db: Session, region: Optional[str] = None) -> pd.DataFrame:
    """
    Load historical GDELT events from database, optionally filtered by region (partial case-insensitive match).

    Args:
        db (Session): SQLAlchemy DB session.
        region (str, optional): Partial region name to filter events.

    Returns:
        pd.DataFrame: DataFrame containing the event records.
    """
    query = db.query(GDELTEvent)
    if region:
        # Case-insensitive partial match on region
        query = query.filter(GDELTEvent.region.ilike(f'%{region}%'))

    events = query.all()

    # Convert ORM objects to dicts, excluding SQLAlchemy internal keys
    data = []
    for e in events:
        d = e.__dict__.copy()
        d.pop('_sa_instance_state', None)
        data.append(d)

    df = pd.DataFrame(data)

    if not df.empty and 'event_date' in df.columns:
        df['event_date'] = pd.to_datetime(df['event_date'], errors='coerce')

    return df


def calculate_escalation_risk(df: pd.DataFrame) -> pd.DataFrame:
    """
    Calculate escalation risk scores grouped by location using Goldstein scale trends and event counts.

    Returns a DataFrame with columns:
    ['location', 'escalation_risk', 'risk_level', 'avg_goldstein', 'goldstein_trend', 'event_count',
    'media_mentions', 'recent_change', 'first_seen', 'last_seen']

    Args:
        df (pd.DataFrame): DataFrame of event data.

    Returns:
        pd.DataFrame: DataFrame with risk assessment results.
    """
    if df.empty:
        return pd.DataFrame()

    df['location_clean'] = df['region'].str.strip()

    location_stats = []

    for location in df['location_clean'].unique():
        loc_data = df[df['location_clean'] == location].sort_values('event_date')

        if len(loc_data) < 2:
            continue

        avg_goldstein = loc_data['goldstein_scale'].mean()
        event_count = len(loc_data)
        media_mentions = loc_data['num_mentions'].sum() if 'num_mentions' in loc_data else 0
        goldstein_trend = loc_data['goldstein_scale'].diff().mean()

        split_point = len(loc_data) // 2
        recent_avg = loc_data.iloc[split_point:]['goldstein_scale'].mean()
        older_avg = loc_data.iloc[:split_point]['goldstein_scale'].mean()
        recent_change = recent_avg - older_avg

        risk_score = (
            max(0, -avg_goldstein) * 0.4 +
            max(0, -goldstein_trend) * 0.3 +
            min(10, event_count / 5) * 0.2 +
            max(0, -recent_change) * 0.1
        )

        risk_score = min(risk_score, 10)

        if risk_score >= 7:
            risk_level = "CRITICAL"
        elif risk_score >= 5:
            risk_level = "HIGH"
        elif risk_score >= 3:
            risk_level = "MODERATE"
        else:
            risk_level = "LOW"

        location_stats.append({
            'location': location,
            'escalation_risk': risk_score,
            'risk_level': risk_level,
            'avg_goldstein': avg_goldstein,
            'goldstein_trend': goldstein_trend,
            'event_count': event_count,
            'media_mentions': media_mentions,
            'recent_change': recent_change,
            'first_seen': loc_data['event_date'].min(),
            'last_seen': loc_data['event_date'].max(),
        })

    risk_df = pd.DataFrame(location_stats).sort_values('escalation_risk', ascending=False)
    return risk_df


def generate_hourly_timeline(df: pd.DataFrame) -> pd.DataFrame:
    """
    Generate hourly Goldstein scale timeline for visualization purposes.

    Returns a DataFrame with columns: ['timestamp', 'avg_goldstein', 'event_count', 'mentions']

    Args:
        df (pd.DataFrame): DataFrame containing events with 'event_date' and related fields.

    Returns:
        pd.DataFrame: Hourly aggregated timeline.
    """
    if df.empty:
        return pd.DataFrame()

    df['hour'] = df['event_date'].dt.floor('H')

    end_time = pd.Timestamp.now().floor('H')
    start_time = end_time - pd.Timedelta(hours=24)
    all_hours = pd.date_range(start=start_time, end=end_time, freq='H')

    agg_dict = {
        'goldstein_scale': 'mean',
        'event_code': 'count',
    }
    if 'num_mentions' in df.columns:
        agg_dict['num_mentions'] = 'sum'

    hourly = df[df['hour'] >= start_time].groupby('hour').agg(agg_dict).reset_index()

    hourly_complete = pd.DataFrame({'hour': all_hours})
    hourly_complete = hourly_complete.merge(hourly, on='hour', how='left')

    hourly_complete['goldstein_scale'] = hourly_complete['goldstein_scale'].fillna(0)
    hourly_complete['event_code'] = hourly_complete['event_code'].fillna(0).astype(int)

    if 'num_mentions' in hourly_complete.columns:
        hourly_complete['num_mentions'] = hourly_complete['num_mentions'].fillna(0).astype(int)
    else:
        hourly_complete['num_mentions'] = 0

    hourly_complete.columns = ['timestamp', 'avg_goldstein', 'event_count', 'mentions']

    return hourly_complete

### ./backend/app/groq_brief.py ###
"""
AI Brief Generator - CRAM Data Only
Generates conflict analysis summaries using Groq AI
"""
import os
import logging
from datetime import datetime
from groq import Groq
from dotenv import load_dotenv

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Available Groq models in priority order
AVAILABLE_MODELS = [
    "gemma2-9b-it",
    "mixtral-8x7b-32768",
    "llama-3.1-70b-versatile",
    "llama-3.1-8b-instant",
]

def get_available_model(client: Groq) -> str:
    """Find first available Groq model"""
    logger.info("Checking available Groq models...")
    
    for model in AVAILABLE_MODELS:
        try:
            response = client.chat.completions.create(
                model=model,
                messages=[{"role": "user", "content": "test"}],
                max_tokens=5
            )
            logger.info(f"âœ… Using model: {model}")
            return model
        except Exception as e:
            logger.warning(f"âŒ Model {model} unavailable: {str(e)[:50]}")
            continue
    
    logger.warning("Using fallback model")
    return "gemma2-9b-it"

def generate_daily_brief(cram_data: dict) -> str:
    """
    Generate AI brief from CRAM conflict data
    
    Args:
        cram_data: Dict with regional risk scores, events, fatalities
    
    Returns:
        Markdown formatted brief
    """
    load_dotenv()
    today = datetime.now().strftime('%Y-%m-%d')
    
    # Build prompt for AI
    prompt = f"""You are a Sudan conflict analyst. Today is {today}.

CONFLICT RISK DATA (CRAM Analysis):
{format_cram_data(cram_data)}

Generate a professional conflict analysis brief with these sections:

## Executive Summary
2-3 key findings highlighting highest risk areas

## Regional Risk Assessment
Organize by risk level (SEVERE â†’ HIGH â†’ MEDIUM â†’ LOW)
For each region, mention event count, fatalities, and trends

## Humanitarian Implications
Based on conflict intensity and fatality data, what are the humanitarian concerns?

## Key Recommendations
3-5 actionable steps for field operations and response teams

Keep it factual, concise, and actionable. Focus on what decision-makers need to know."""
    
    try:
        api_key = os.getenv("GROQ_API_KEY")
        if not api_key:
            return f"# Sudan Daily Brief â€“ {today}\n\nâŒ Error: GROQ_API_KEY not configured in .env"
        
        client = Groq(api_key=api_key)
        model = get_available_model(client)
        
        # Generate brief
        response = client.chat.completions.create(
            model=model,
            messages=[{"role": "user", "content": prompt}],
            max_tokens=1500,
            temperature=0.3
        )
        
        brief = response.choices[0].message.content
        header = f"# Sudan Daily Brief â€“ {today}\n\n*Generated using Groq AI ({model})*\n\n---\n\n"
        
        logger.info(f"âœ… Brief generated with {model}")
        return header + brief
    
    except Exception as e:
        logger.error(f"Error: {e}")
        return f"# Sudan Daily Brief â€“ {today}\n\nâŒ Error: {str(e)}"

def format_cram_data(cram_data: dict) -> str:
    """Format CRAM data for AI prompt"""
    if not cram_data:
        return "No data available"
    
    formatted = ""
    for region, data in cram_data.items():
        risk = data.get('risk_score', 0)
        events = data.get('events', 0)
        fatalities = data.get('fatalities', 0)
        category = data.get('category', 'UNKNOWN')
        trend = data.get('trend', 'stable')
        
        formatted += f"\n- **{region}** [{category}]: Risk {risk}/10 | {events} events | {fatalities} fatalities | Trend: {trend}"
    
    return formatted

### ./backend/app/main.py ###
# app/main.py
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

from app.routers import alerts, analytics, reports, dashboard, goldstein, intelligence
from app.api.routes import trend_routes


app = FastAPI(
    title="Sudan CRAM API",
    description="Conflict Risk Analysis & Monitoring System - Bivariate Climate + Conflict",
    version="2.0",
)

# CORS - Allow local development and your frontend
app.add_middleware(
    CORSMiddleware,
    allow_origins=[
        "http://localhost:3000",
        "http://127.0.0.1:3000",
        "https://localhost:3000",
        "https://sudan-cram-v2.onrender.com",
    ],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Register routers
app.include_router(analytics.router, prefix="/api", tags=["analytics"])
app.include_router(reports.router, prefix="/api", tags=["reports"])
app.include_router(alerts.router, prefix="/api", tags=["alerts"])
app.include_router(dashboard.router, prefix="/api", tags=["dashboard"])
app.include_router(goldstein.router)  # has its own prefix="/api/goldstein"
app.include_router(intelligence.router)  # prefix="/api/intelligence" inside

# Include new trend analysis router
app.include_router(trend_routes.router, prefix="/api", tags=["trend-analysis"])


@app.get("/")
async def root():
    return {
        "message": "Sudan CRAM API v2.0 - Bivariate Risk Analysis + GDELT Goldstein + Multi-Agent Intelligence",
        "status": "online",
        "endpoints": [
            "/api/dashboard",
            "/api/analytics",
            "/api/conflict-proneness",
            "/api/regions",
            "/api/monthly-trend",
            "/api/map-data",
            "/api/generate-brief",
            "/api/alerts",
            "/api/goldstein/escalation-risk",
            "/api/goldstein/timeline",
            "/api/goldstein/top-risks",
            "/api/intelligence/health",
            "/api/intelligence/analyze",
            "/api/trend/risk",  # Added for new trend API endpoint
            "/docs",
        ],
    }


@app.get("/health")
async def health():
    return {"status": "healthy"}

### ./backend/app/models/__init__.py ###

### ./backend/app/models/acled.py ###
# backend/app/models/acled.py
from sqlalchemy import Column, Integer, String, Float, Date, DateTime, Text
from sqlalchemy.sql import func

try:
    from database import Base
except ModuleNotFoundError:
    from backend.database import Base  # type: ignore


class ACLEDEvent(Base):
    __tablename__ = "acled_events"

    id = Column(Integer, primary_key=True, index=True)
    event_id = Column(String(50), unique=True, nullable=False)
    event_date = Column(Date, nullable=False, index=True)
    event_type = Column(String(100))

    region = Column(String(100), index=True)
    latitude = Column(Float)
    longitude = Column(Float)

    actor1 = Column(String(200))
    actor2 = Column(String(200))

    fatalities = Column(Integer)
    notes = Column(Text)

    created_at = Column(DateTime, server_default=func.now())

### ./backend/app/models/analysis.py ###
from sqlalchemy import (
    Column,
    Integer,
    String,
    Boolean,
    Float,
    Text,
    DateTime,
    ForeignKey,
)
from sqlalchemy.dialects.postgresql import JSONB
from sqlalchemy.sql import func

from database import Base


class AnalysisRun(Base):
    __tablename__ = "analysis_runs"

    id = Column(Integer, primary_key=True, index=True)

    # Basic input context
    region = Column(String(100), index=True)
    has_raw_data = Column(Boolean, default=False)
    # Stored as JSON string (e.g. '["UN mediation"]')
    interventions = Column(Text)

    # Trend summary
    trend_classification = Column(String(50))
    trend_confidence_label = Column(String(20))
    forecast_armed_clash = Column(Integer)
    forecast_civilian_targeting = Column(Integer)

    # Scenario summary
    recommendation_summary = Column(String(50))  # e.g. "PROCEED"
    max_success_probability = Column(Integer)
    max_risk_probability = Column(Integer)

    # Validation summary
    validation_status = Column(String(20))
    issue_count = Column(Integer)
    overall_confidence = Column(Float)

    # Full explainability payload (JSONB in Postgres)
    explainability = Column(JSONB)

    created_at = Column(DateTime(timezone=True), server_default=func.now())


class AnalysisFeedback(Base):
    """
    Simple feedback / approval per run.
    One run can have multiple feedback entries over time.
    """

    __tablename__ = "analysis_feedback"

    id = Column(Integer, primary_key=True, index=True)

    # Link back to the run
    run_id = Column(Integer, ForeignKey("analysis_runs.id"), index=True, nullable=False)

    # "approved" | "rejected"
    status = Column(String(20), nullable=False)

    # Optional analyst comment
    comment = Column(Text, nullable=True)

    # Optional "who" left the feedback (email, name, etc.)
    user = Column(String(100), nullable=True)

    created_at = Column(DateTime(timezone=True), server_default=func.now())

### ./backend/app/models/gdelt.py ###
# backend/app/models/gdelt.py
from sqlalchemy import Column, Integer, String, Float, DateTime, Text
from sqlalchemy.sql import func

# Make this work both when running from /backend and via "python -m backend..."
try:
    from database import Base  # when working directory is backend/
except ModuleNotFoundError:    # when imported as backend.app.models.gdelt
    from backend.database import Base  # type: ignore


class GDELTEvent(Base):
    __tablename__ = "gdelt_events"

    id = Column(Integer, primary_key=True, index=True)
    event_id = Column(String(50), unique=True, nullable=False)
    event_date = Column(DateTime, nullable=False, index=True)

    region = Column(String(100), index=True)
    latitude = Column(Float)
    longitude = Column(Float)

    event_code = Column(String(10))
    quad_class = Column(Integer)

    actor1_name = Column(String(200))
    actor2_name = Column(String(200))

    goldstein_scale = Column(Float)
    avg_tone = Column(Float)

    created_at = Column(DateTime, server_default=func.now())

### ./backend/app/models/risk_score.py ###
from sqlalchemy import Column, Integer, String, Float, Date, DateTime
from sqlalchemy.sql import func
from app.database import Base

class RiskScore(Base):
    __tablename__ = "risk_scores"
    
    id = Column(Integer, primary_key=True, index=True)
    region = Column(String(100), nullable=False, index=True)
    date = Column(Date, nullable=False, index=True)
    
    conflict_risk_score = Column(Float)
    gdelt_event_count = Column(Integer)
    
    flood_risk_score = Column(Float)
    drought_risk_score = Column(Float)
    climate_risk_score = Column(Float)
    
    overall_risk_score = Column(Float)
    risk_level = Column(String(20))
    
    last_updated = Column(DateTime, server_default=func.now())

### ./backend/app/routers/__init__.py ###

### ./backend/app/routers/alerts.py ###
from fastapi import APIRouter, HTTPException
from datetime import datetime
import pandas as pd
from pathlib import Path

router = APIRouter(prefix="/api/alerts", tags=["alerts"])

PROJECT_ROOT = Path(__file__).parent.parent.parent
DATA_DIR = PROJECT_ROOT / "data" / "processed"
ACLED_FILE = DATA_DIR / "acled_with_causes.csv"
CP_FILE = DATA_DIR / "conflict_proneness_v2.csv"

_acled_cache = None
_cp_cache = None

def load_acled_data():
    """Load ACLED data with causes"""
    global _acled_cache
    if _acled_cache is not None:
        return _acled_cache

    if not ACLED_FILE.exists():
        raise FileNotFoundError(f"Data not found at {ACLED_FILE}")

    df = pd.read_csv(ACLED_FILE)
    _acled_cache = df
    return df

def load_cp_data():
    """Load Conflict Proneness data"""
    global _cp_cache
    if _cp_cache is not None:
        return _cp_cache

    if not CP_FILE.exists():
        raise FileNotFoundError(f"Data not found at {CP_FILE}")

    df = pd.read_csv(CP_FILE)
    _cp_cache = df
    return df

@router.get("", include_in_schema=True)
async def get_alerts(severity: str = "ALL", limit: int = 100):
    """Get alerts from Conflict Proneness data"""
    try:
        df = load_cp_data()

        # Sort by conflict proneness
        df_sorted = df.sort_values('conflict_proneness', ascending=False)

        # Format response
        alerts = []
        for _, row in df_sorted.iterrows():
            alerts.append({
                'region': str(row['region']),
                'proneness_score': float(row['conflict_proneness']),
                'proneness_level': str(row['proneness_level']),
                'incidents': int(row['incidents']),
                'fatalities': int(row['fatalities']),
                'causes_pct': float(row['causes_pct']),
                'actors': int(row['num_actors']),
                'explanation': f"Events: {int(row['incidents'])}, Fatalities: {int(row['fatalities'])}, CP: {float(row['conflict_proneness']):.1f}"
            })

        # Filter by severity
        if severity.upper() != 'ALL':
            alerts = [a for a in alerts if a['proneness_level'].upper() == severity.upper()]
        alerts = alerts[:limit]

        return {
            "success": True,
            "alerts": alerts,
            "total_alerts": len(alerts),
            "total_regions": len(df),
            "total_events": int(df['incidents'].sum()),
            "total_fatalities": int(df['fatalities'].sum())
        }

    except Exception as e:
        print(f"âŒ ERROR: {e}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/conflict-proneness", include_in_schema=True)
async def get_conflict_proneness():
    """Get conflict proneness data for map visualization"""
    try:
        df = load_cp_data()

        regions = []
        for _, row in df.iterrows():
            regions.append({
                'region': str(row['region']),
                'proneness_score': round(float(row['conflict_proneness']), 2),
                'proneness_level': str(row['proneness_level']),
                'incidents': int(row['incidents']),
                'fatalities': int(row['fatalities']),
                'indicators': {
                    'incidents': int(row['incidents']),
                    'causes_pct': round(float(row['causes_pct']), 1),
                    'actors': int(row['num_actors']),
                    'trend': int(row['trend_delta'])
                }
            })

        return {
            "success": True,
            "regions": sorted(regions, key=lambda x: x['proneness_score'], reverse=True),
            "total_regions": len(regions)
        }

    except Exception as e:
        print(f"âŒ ERROR: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/dashboard-stats", include_in_schema=True)
async def get_dashboard_stats():
    """Get dashboard overview statistics"""
    try:
        df = load_cp_data()

        # Calculate stats (convert to native Python types)
        total_events = int(df['incidents'].sum())
        total_fatalities = int(df['fatalities'].sum())
        unique_regions = int(len(df))

        # Find highest risk region
        highest_risk_idx = df['conflict_proneness'].idxmax()
        highest_risk = df.loc[highest_risk_idx]

        # Calculate active alerts (HIGH + VERY HIGH + EXTREME regions)
        high_alerts = int((df['proneness_level'] == 'HIGH').sum())
        very_high_alerts = int((df['proneness_level'] == 'VERY HIGH').sum())
        extreme_alerts = int((df['proneness_level'] == 'EXTREME').sum())

        # Data confidence
        data_confidence = 94.8

        return {
            "success": True,
            "stats": {
                "conflict_events": total_events,
                "states_analyzed": unique_regions,
                "risk_assessments": unique_regions,
                "data_confidence": data_confidence,
                "highest_risk_state": str(highest_risk['region']),
                "highest_risk_score": float(highest_risk['conflict_proneness']),
                "active_alerts": high_alerts + very_high_alerts + extreme_alerts,
                "high_alerts": high_alerts,
                "very_high_alerts": very_high_alerts,
                "extreme_alerts": extreme_alerts,
                "trend_direction": "Rising",
                "trend_percentage": 18
            }
        }

    except Exception as e:
        print(f"âŒ ERROR: {e}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=str(e))

### ./backend/app/routers/analytics.py ###
# app/routers/analytics.py
"""
âœ… Enhanced Analytics Router - Conflict Proneness v2 + Conflict Risk
FIXED: Proper numpy type conversion + dual conflict metrics
"""
from fastapi import APIRouter, HTTPException
import pandas as pd
import numpy as np
from pathlib import Path

router = APIRouter()

PROJECT_ROOT = Path(__file__).parent.parent.parent
DATA_DIR = PROJECT_ROOT / "data" / "processed"

CP_FILE = DATA_DIR / "conflict_proneness_v2.csv"
CR_FILE = DATA_DIR / "conflict_risk_simple.csv"  # âœ… NEW
ACLED_FILE = DATA_DIR / "acled_with_causes.csv"

_cp_cache = None
_cr_cache = None  # âœ… NEW
_acled_cache = None
_monthly_cache = None


def load_conflict_proneness():
    """Load CP v2 with caching"""
    global _cp_cache
    if _cp_cache is not None:
        return _cp_cache
    try:
        df_cp = pd.read_csv(CP_FILE)
        _cp_cache = df_cp
        return df_cp
    except FileNotFoundError:
        raise HTTPException(status_code=404, detail=f"File not found: {CP_FILE}")


def load_conflict_risk():  # âœ… NEW
    """Load Conflict Risk with caching"""
    global _cr_cache
    if _cr_cache is not None:
        return _cr_cache
    try:
        df_cr = pd.read_csv(CR_FILE)
        _cr_cache = df_cr
        return df_cr
    except FileNotFoundError:
        raise HTTPException(status_code=404, detail=f"File not found: {CR_FILE}")


def load_acled_data():
    """Load ACLED events data with caching"""
    global _acled_cache
    if _acled_cache is not None:
        return _acled_cache
    try:
        df_acled = pd.read_csv(ACLED_FILE)
        _acled_cache = df_acled
        return df_acled
    except FileNotFoundError:
        raise HTTPException(status_code=404, detail=f"File not found: {ACLED_FILE}")


def compute_monthly_trends():
    """Aggregate ACLED events by month - returns real data"""
    global _monthly_cache
    if _monthly_cache is not None:
        return _monthly_cache

    try:
        df_acled = load_acled_data()

        # Find date column
        date_col = None
        for col in ['event_date', 'WEEK', 'date', 'DATE']:
            if col in df_acled.columns:
                date_col = col
                break

        if date_col is None:
            return []

        # Parse dates and extract year-month
        df_acled[date_col] = pd.to_datetime(df_acled[date_col], errors='coerce')
        df_acled['year_month'] = df_acled[date_col].dt.strftime('%Y-%m')

        # Group by month
        monthly_agg = df_acled.groupby('year_month', as_index=False).agg({
            'year_month': 'first',
            'FATALITIES': ['sum', 'count']
        }).reset_index(drop=True)

        monthly_agg.columns = ['year_month', 'fatalities', 'events']
        monthly_agg = monthly_agg.sort_values('year_month')

        # Format response
        monthly_data = []
        for _, row in monthly_agg.iterrows():
            try:
                monthly_data.append({
                    'month': str(row['year_month']),
                    'events': convert_to_native(int(row['events'])),
                    'fatalities': convert_to_native(int(row['fatalities']) if pd.notna(row['fatalities']) else 0)
                })
            except:
                continue

        _monthly_cache = monthly_data
        return monthly_data

    except Exception as e:
        print(f"âš ï¸ Warning computing monthly trends: {e}")
        return []


def convert_to_native(value):
    """Convert numpy types to native Python types for JSON serialization"""
    if isinstance(value, (np.integer, np.int64, np.int32, np.int16)):
        return int(value)
    elif isinstance(value, (np.floating, np.float64, np.float32)):
        return float(value)
    elif isinstance(value, np.ndarray):
        return value.tolist()
    elif isinstance(value, np.bool_):
        return bool(value)
    elif pd.isna(value):
        return None
    return value


def get_color_for_risk(level):
    """Map risk level to color"""
    color_map = {
        "EXTREME": "#8B0000",
        "VERY HIGH": "#DC143C",
        "HIGH": "#FF6347",
        "MODERATE": "#FFD700",
        "LOW": "#00A86B",
    }
    return color_map.get(str(level).upper(), "#6b7280")


@router.get("/conflict-proneness")
async def get_conflict_proneness():
    """Returns Conflict Proneness v2 with all 4 indicators breakdown"""
    try:
        df = load_conflict_proneness()

        regions = {}
        for _, row in df.iterrows():
            region_name = str(row['region']).strip()

            regions[region_name] = {
                'region': region_name,
                'proneness_score': convert_to_native(row['conflict_proneness']),
                'proneness_level': str(row['proneness_level']).strip(),
                'proneness_color': get_color_for_risk(row['proneness_level']),
                'indicators': {
                    'incidents': {
                        'value': convert_to_native(row['incidents']),
                        'label': 'Event Frequency'
                    },
                    'causes_pct': {
                        'value': round(convert_to_native(row['causes_pct']), 1),
                        'label': 'High-Risk % (Political/Communal/Resource)'
                    },
                    'num_actors': {
                        'value': convert_to_native(row['num_actors']),
                        'label': 'Distinct Organizations'
                    },
                    'trend_delta': {
                        'value': convert_to_native(row['trend_delta']),
                        'label': 'Recent Trend (+ = Increasing)'
                    }
                },
                'high_risk_events': convert_to_native(row['high_risk_events']),
                'fatalities': convert_to_native(row['fatalities']),
                'fatality_rate': round(convert_to_native(row['fatality_rate']), 3),
                'climate_risk_score': round(convert_to_native(row['climate_risk_score']), 2),
                'climate_risk_level': str(row['cdi_category']).strip()
            }

        return regions

    except Exception as e:
        print(f"âŒ ERROR in /api/conflict-proneness: {e}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/conflict-risk")  # âœ… NEW ENDPOINT
async def get_conflict_risk():
    """Returns Conflict Risk (simple incident-based)"""
    try:
        df = load_conflict_risk()

        regions = {}
        for _, row in df.iterrows():
            region_name = str(row['region']).strip()

            regions[region_name] = {
                'region': region_name,
                'conflict_risk_score': convert_to_native(row['conflict_risk_score']),
                'conflict_risk_level': str(row['conflict_risk_level']).strip(),
                'incidents': convert_to_native(row['incidents']),
                'fatalities': convert_to_native(row['fatalities']),
            }

        return regions

    except Exception as e:
        print(f"âŒ ERROR in /api/conflict-risk: {e}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/analytics")
async def get_analytics():
    """Returns summary analytics with 4-indicator breakdowns"""
    try:
        df = load_conflict_proneness()

        summary = {
            "total_regions": convert_to_native(len(df)),
            "avg_conflict_proneness": round(convert_to_native(df['conflict_proneness'].mean()), 2),
            "avg_climate_risk": round(convert_to_native(df['climate_risk_score'].mean()), 2),
            "total_events": convert_to_native(df['incidents'].sum()),
            "total_fatalities": convert_to_native(df['fatalities'].sum()),
            "highest_risk_region": str(df.loc[df['conflict_proneness'].idxmax(), 'region']),
            "high_proneness_count": convert_to_native((df['proneness_level'].isin(['EXTREME', 'VERY HIGH'])).sum()),
        }

        indicator_averages = {
            "avg_incidents": round(convert_to_native(df['incidents'].mean()), 1),
            "avg_causes_pct": round(convert_to_native(df['causes_pct'].mean()), 1),
            "avg_actors": round(convert_to_native(df['num_actors'].mean()), 1),
            "avg_trend": round(convert_to_native(df['trend_delta'].mean()), 1)
        }

        distribution = {
            'EXTREME': convert_to_native((df['proneness_level'] == 'EXTREME').sum()),
            'VERY_HIGH': convert_to_native((df['proneness_level'] == 'VERY HIGH').sum()),
            'HIGH': convert_to_native((df['proneness_level'] == 'HIGH').sum()),
            'MODERATE': convert_to_native((df['proneness_level'] == 'MODERATE').sum()),
            'LOW': convert_to_native((df['proneness_level'] == 'LOW').sum()),
        }

        climate_dist = df['cdi_category'].value_counts()
        conflict_dist = df['proneness_level'].value_counts()

        risk_distribution = {
            "climate": {str(cat): convert_to_native(count) for cat, count in climate_dist.items()},
            "conflict": {str(cat): convert_to_native(count) for cat, count in conflict_dist.items()}
        }

        top_regions = [
            {
                'region': str(row['region']),
                'climate_risk_score': round(convert_to_native(row['climate_risk_score']), 2),
                'political_risk_score': round(convert_to_native(row['conflict_proneness']), 2),
                'cdi_category': str(row['cdi_category']),
                'risk_category': str(row['proneness_level']),
                'events_6m': convert_to_native(row['incidents']),
                'fatalities_6m': convert_to_native(row['fatalities']),
            }
            for _, row in df.nlargest(10, 'conflict_proneness').iterrows()
        ]

        regional_data = [
            {
                'region': str(row['region']),
                'climate_risk_score': round(convert_to_native(row['climate_risk_score']), 2),
                'political_risk_score': round(convert_to_native(row['conflict_proneness']), 2),
                'events_6m': convert_to_native(row['incidents']),
                'fatalities_6m': convert_to_native(row['fatalities']),
            }
            for _, row in df.iterrows()
        ]

        return {
            "summary": summary,
            "indicator_averages": indicator_averages,
            "distribution": distribution,
            "risk_distribution": risk_distribution,
            "top_regions": top_regions,
            "regional_data": regional_data
        }

    except Exception as e:
        print(f"âŒ ERROR in /api/analytics: {e}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/regions")
async def get_regions():
    """Returns bivariate region data for regions/page.tsx"""
    try:
        df = load_conflict_proneness()

        regions = []
        for _, row in df.iterrows():
            regions.append({
                'region': str(row['region']),
                'climate_risk_score': round(convert_to_native(row['climate_risk_score']), 2),
                'cdi_category': str(row['cdi_category']),
                'political_risk_score': round(convert_to_native(row['conflict_proneness']), 2),
                'risk_category': str(row['proneness_level']),
                'bivariate_category': f"{row['proneness_level']}_{row['cdi_category']}",
                'events_6m': convert_to_native(row['incidents']),
                'fatalities_6m': convert_to_native(row['fatalities']),
                'trend': 'stable',
            })

        regions = sorted(regions, key=lambda x: x['political_risk_score'], reverse=True)

        climate_summary = {str(cat): convert_to_native((df['cdi_category'] == cat).sum()) for cat in df['cdi_category'].unique()}
        conflict_summary = {str(cat): convert_to_native((df['proneness_level'] == cat).sum()) for cat in df['proneness_level'].unique()}

        return {
            "regions": regions,
            "total_count": len(regions),
            "risk_summary": {
                "climate": climate_summary,
                "conflict": conflict_summary
            }
        }

    except Exception as e:
        print(f"âŒ ERROR in /api/regions: {e}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=str(e))


@router.get("/monthly-trend")
async def get_monthly_trend():
    """Returns REAL monthly conflict trend data from ACLED events"""
    try:
        monthly_data = compute_monthly_trends()

        if not monthly_data:
            return {
                "data": [],
                "summary": {
                    "avg_monthly_events": 0,
                    "avg_monthly_fatalities": 0,
                    "trend": "unknown"
                }
            }

        events_list = [m['events'] for m in monthly_data if isinstance(m['events'], (int, float))]
        fatalities_list = [m['fatalities'] for m in monthly_data if isinstance(m['fatalities'], (int, float))]

        avg_events = round(sum(events_list) / len(events_list), 1) if events_list else 0
        avg_fatalities = round(sum(fatalities_list) / len(fatalities_list), 1) if fatalities_list else 0

        if len(events_list) >= 2:
            recent_avg = sum(events_list[-3:]) / 3 if len(events_list) >= 3 else events_list[-1]
            earlier_avg = sum(events_list[:3]) / 3 if len(events_list) >= 3 else events_list[0]
            trend = "increasing" if recent_avg > earlier_avg else "decreasing"
        else:
            trend = "stable"

        return {
            "data": monthly_data,
            "summary": {
                "avg_monthly_events": avg_events,
                "avg_monthly_fatalities": avg_fatalities,
                "trend": trend,
                "total_months": len(monthly_data)
            }
        }

    except Exception as e:
        print(f"âŒ ERROR in /api/monthly-trend: {e}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=str(e))

### ./backend/app/routers/dashboard.py ###
from fastapi import APIRouter, HTTPException
from typing import Dict, Any
import pandas as pd
from pathlib import Path

router = APIRouter()

# Load data paths
PROJECT_ROOT = Path(__file__).parent.parent.parent
DATA_DIR = PROJECT_ROOT / "data" / "processed"
CP_FILE = DATA_DIR / "conflict_proneness_v2.csv"

try:
    df_cp = pd.read_csv(CP_FILE)
    print(f"âœ… Loaded dashboard CP data: {len(df_cp)} rows")
    print(f"   Columns: {', '.join(df_cp.columns.tolist())}")
except Exception as e:
    print(f"âŒ Error loading CP data: {e}")
    df_cp = pd.DataFrame()


@router.get("/dashboard")
async def get_dashboard_data() -> Dict[str, Any]:
    """
    Get dashboard overview data with conflict metrics
    """
    if df_cp.empty:
        raise HTTPException(status_code=500, detail="Dashboard data not loaded")

    try:
        # Calculate summary metrics
        total_events = int(df_cp['incidents'].sum()) if 'incidents' in df_cp.columns else 0
        total_fatalities = int(df_cp['fatalities'].sum()) if 'fatalities' in df_cp.columns else 0
        total_regions = len(df_cp)

        # Calculate average scores
        avg_conflict_proneness = float(df_cp['conflict_proneness'].mean()) if 'conflict_proneness' in df_cp.columns else 0
        avg_climate_risk = float(df_cp['climate_risk_score'].mean()) if 'climate_risk_score' in df_cp.columns else 0

        # Data confidence
        data_confidence = 94.8

        # Get highest risk region
        if 'conflict_proneness' in df_cp.columns and 'region' in df_cp.columns:
            highest_risk_idx = df_cp['conflict_proneness'].idxmax()
            highest_risk_region = df_cp.loc[highest_risk_idx, 'region']
        else:
            highest_risk_region = "N/A"

        # Risk distribution
        climate_distribution = {}
        conflict_distribution = {}

        if 'cdi_category' in df_cp.columns:
            climate_distribution = df_cp['cdi_category'].value_counts().to_dict()

        if 'proneness_level' in df_cp.columns:
            conflict_distribution = df_cp['proneness_level'].value_counts().to_dict()

        # Get trend
        trend = {
            "direction": "rising",
            "percentage": 12.5
        }

        # Get quick insights
        alerts = {
            "high": int(conflict_distribution.get('HIGH', 0)) if conflict_distribution else 0,
            "very_high": int(conflict_distribution.get('VERY HIGH', 0)) if conflict_distribution else 0,
            "extreme": int(conflict_distribution.get('EXTREME', 0)) if conflict_distribution else 0
        }

        active_alerts = alerts['high'] + alerts['very_high'] + alerts['extreme']

        return {
            "summary": {
                "conflict_events": total_events,
                "states_analyzed": total_regions,
                "risk_assessments": total_regions,
                "data_confidence": data_confidence
            },
            "quick_insights": {
                "highest_risk_state": highest_risk_region,
                "active_alerts": active_alerts,
                "alert_breakdown": alerts,
                "trend": trend
            },
            "risk_distribution": {
                "climate": climate_distribution,
                "conflict": conflict_distribution
            },
            "metrics": {
                "total_events": total_events,
                "total_fatalities": total_fatalities,
                "avg_conflict_proneness": round(avg_conflict_proneness, 2),
                "avg_climate_risk": round(avg_climate_risk, 2)
            }
        }

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error generating dashboard data: {str(e)}")


@router.get("/map-data")
async def get_map_data(indicator: str = "conflict-risk") -> Dict[str, float]:
    """
    Get risk scores by region for map visualization
    
    Parameters:
    - indicator: "conflict-risk", "climate-risk", or "combined-risk"
    """
    if df_cp.empty:
        raise HTTPException(status_code=500, detail="Dashboard data not loaded")

    try:
        # Check if region column exists
        if 'region' not in df_cp.columns:
            raise HTTPException(status_code=500, detail="Region column not found in data")

        # Select the appropriate risk metric
        if indicator == "climate-risk":
            if 'climate_risk_score' not in df_cp.columns:
                raise HTTPException(status_code=500, detail="Climate risk data not available")
            risk_col = 'climate_risk_score'
        elif indicator == "combined-risk":
            # Calculate combined risk (average of conflict + climate)
            if 'conflict_proneness' in df_cp.columns and 'climate_risk_score' in df_cp.columns:
                df_temp = df_cp.copy()
                df_temp['combined'] = (df_temp['conflict_proneness'] + df_temp['climate_risk_score']) / 2
                risk_col = 'combined'
            else:
                raise HTTPException(status_code=500, detail="Required data for combined risk not available")
        else:
            # Default: conflict risk
            if 'conflict_proneness' not in df_cp.columns:
                raise HTTPException(status_code=500, detail="Conflict proneness data not available")
            risk_col = 'conflict_proneness'

        # Group by region and calculate average
        if indicator == "combined-risk":
            result = df_temp.groupby('region')[risk_col].mean().round(1).to_dict()
        else:
            result = df_cp.groupby('region')[risk_col].mean().round(1).to_dict()

        return result

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error generating map data: {str(e)}")


@router.get("/regions")
async def get_regions() -> Dict[str, list]:
    """
    Get list of all regions
    """
    if df_cp.empty:
        raise HTTPException(status_code=500, detail="Dashboard data not loaded")

    try:
        if 'region' not in df_cp.columns:
            raise HTTPException(status_code=500, detail="Region column not found")

        regions = sorted(df_cp['region'].dropna().unique().tolist())
        return {"regions": regions}

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error getting regions: {str(e)}")

### ./backend/app/routers/goldstein.py ###
"""
GDELT Goldstein Scale API Endpoints
Real-time conflict escalation tracking
"""
from fastapi import APIRouter, HTTPException
from fastapi.responses import JSONResponse
import pandas as pd
from datetime import datetime
import glob
import os

router = APIRouter(prefix="/api/goldstein", tags=["Goldstein Escalation"])

# DOCKER FIX: Use absolute path since files are at /app/data in container
def get_latest_file(pattern):
    """Get most recent file matching pattern"""
    # Check if running in Docker (files at /app/data/) or local (files at data/)
    docker_pattern = '/app/' + pattern
    local_pattern = pattern
    
    # Try Docker path first, fall back to local
    files = glob.glob(docker_pattern)
    if not files:
        files = glob.glob(local_pattern)
    
    if not files:
        return None
    return max(files, key=os.path.getctime)

@router.get("/escalation-risk")
async def get_escalation_risk():
    """
    Get current escalation risk by location
    Returns: {location: {risk_score, level, goldstein, trend, events}}
    """
    try:
        risk_file = get_latest_file('data/processed/goldstein_escalation_risk_*.csv')

        if not risk_file:
            raise HTTPException(
                status_code=404,
                detail="No Goldstein analysis found. Run: python scripts/gdelt/analyze_goldstein_trends.py"
            )

        df = pd.read_csv(risk_file)

        # Format for frontend
        result = {
            'last_updated': datetime.fromtimestamp(os.path.getctime(risk_file)).isoformat(),
            'locations': {}
        }

        for _, row in df.iterrows():
            result['locations'][row['location']] = {
                'risk_score': round(float(row['escalation_risk']), 1),
                'risk_level': row['risk_level'],
                'avg_goldstein': round(float(row['avg_goldstein']), 2),
                'trend': round(float(row['goldstein_trend']), 2),
                'trend_direction': 'escalating' if row['goldstein_trend'] < 0 else 'de-escalating',
                'event_count': int(row['event_count']),
                'media_mentions': int(row['media_mentions']),
                'last_seen': row['last_seen']
            }

        return result

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/timeline")
async def get_goldstein_timeline(hours: int = 24):
    """
    Get hourly Goldstein timeline
    """
    try:
        timeline_file = get_latest_file('data/processed/goldstein_hourly_timeline_*.csv')

        if not timeline_file:
            raise HTTPException(status_code=404, detail="No timeline data found")

        df = pd.read_csv(timeline_file)
        df['timestamp'] = pd.to_datetime(df['timestamp'])

        # Filter to requested hours
        cutoff = df['timestamp'].max() - pd.Timedelta(hours=hours)
        df = df[df['timestamp'] >= cutoff]

        return {
            'timestamps': df['timestamp'].dt.strftime('%Y-%m-%d %H:%M').tolist(),
            'goldstein_scores': df['avg_goldstein'].tolist(),
            'event_counts': df['event_count'].tolist(),
            'mentions': df['mentions'].tolist()
        }

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@router.get("/top-risks")
async def get_top_risks(limit: int = 10):
    """Get top N highest-risk locations"""
    try:
        risk_file = get_latest_file('data/processed/goldstein_escalation_risk_*.csv')

        if not risk_file:
            raise HTTPException(status_code=404, detail="No risk data")

        df = pd.read_csv(risk_file).head(limit)

        return {
            'top_risks': df.to_dict('records')
        }

    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

### ./backend/app/routers/intelligence.py ###
from datetime import datetime
from typing import Any, Dict, List, Optional

import json
from fastapi import APIRouter, Depends, HTTPException, Query
from pydantic import BaseModel, Field
from sqlalchemy.orm import Session

from app.agents.workflow import run_analysis
from app.models.analysis import AnalysisRun
from database import get_db  # NOTE: keep this (not app.database) for local/Render compatibility


router = APIRouter(
    prefix="/api/intelligence",
    tags=["intelligence"],
)


# --------- Pydantic models ---------


class IntelligenceRequest(BaseModel):
    region: str
    raw_data: Optional[str] = None
    interventions: List[str] = Field(default_factory=list)


class IntelligenceResponse(BaseModel):
    run_id: Optional[int]
    region: str
    timestamp: datetime
    events: List[Dict[str, Any]] = Field(default_factory=list)
    trends: Optional[Dict[str, Any]] = None
    scenarios: Optional[Dict[str, Any]] = None
    validation: Optional[Dict[str, Any]] = None
    approval_status: Optional[str] = None
    confidence: float
    messages: List[str]
    explainability: Optional[Dict[str, Any]] = None


class AnalysisRunSummary(BaseModel):
    id: int
    region: str
    created_at: datetime
    trend_classification: Optional[str]
    overall_confidence: Optional[float]
    recommendation_summary: Optional[str]


# --------- Endpoints ---------


@router.get("/health")
async def health() -> Dict[str, str]:
    return {"status": "healthy", "service": "intelligence"}


@router.post("/analyze", response_model=IntelligenceResponse)
def analyze(
    payload: IntelligenceRequest,
    db: Session = Depends(get_db),
) -> IntelligenceResponse:
    """
    Run the LangGraph pipeline and log a summary row into analysis_runs.
    """

    result = run_analysis(
        region=payload.region,
        raw_data=payload.raw_data,
        interventions=payload.interventions,
    )

    # --- Unpack pieces from the pipeline result ---
    events = result.get("events") or []  # ðŸ‘ˆ IMPORTANT FIX: expose the timeline
    trends = result.get("trend_analysis") or {}
    scenarios = result.get("scenarios") or {}
    validation = result.get("validation") or {}
    explainability = result.get("explainability") or {}

    has_raw_data = bool(result.get("raw_data"))
    interventions_json = json.dumps(result.get("interventions") or [])

    trend_classification = trends.get("trend_classification")
    trend_confidence_label = trends.get("confidence")

    forecast = trends.get("forecast_7_days") or {}
    forecast_armed_clash = forecast.get("armed_clash_likelihood")
    forecast_civilian_targeting = forecast.get("civilian_targeting_likelihood")

    scenarios_list = scenarios.get("scenarios") or []
    recommendation_summary: Optional[str] = None
    max_success_probability: Optional[int] = None
    max_risk_probability: Optional[int] = None

    if scenarios_list:
        # Take the first recommendation as the summary for now
        recommendation_summary = scenarios_list[0].get("recommendation")
        for s in scenarios_list:
            optim = (s or {}).get("optimistic") or {}
            pess = (s or {}).get("pessimistic") or {}
            sp = optim.get("success_probability")
            rp = pess.get("risk_probability")
            if sp is not None:
                max_success_probability = (
                    sp
                    if max_success_probability is None
                    else max(max_success_probability, sp)
                )
            if rp is not None:
                max_risk_probability = (
                    rp
                    if max_risk_probability is None
                    else max(max_risk_probability, rp)
                )

    validation_status = validation.get("validation_status")
    issues = validation.get("issues") or []
    issue_count = len(issues)

    overall_confidence = validation.get(
        "overall_confidence", result.get("confidence_score", 0.0)
    )
    overall_confidence = float(overall_confidence or 0.0)

    explainability_json = json.dumps(explainability, ensure_ascii=False)

    # --- Persist to analysis_runs ---
    db_run = AnalysisRun(
        region=result["region"],
        has_raw_data=has_raw_data,
        interventions=interventions_json,
        trend_classification=trend_classification,
        trend_confidence_label=trend_confidence_label,
        forecast_armed_clash=forecast_armed_clash,
        forecast_civilian_targeting=forecast_civilian_targeting,
        recommendation_summary=recommendation_summary,
        max_success_probability=max_success_probability,
        max_risk_probability=max_risk_probability,
        validation_status=validation_status,
        issue_count=issue_count,
        overall_confidence=overall_confidence,
        explainability=explainability_json,
    )
    db.add(db_run)
    db.commit()
    db.refresh(db_run)

    # --- Build API response ---
    ts_str = result.get("timestamp")
    try:
        ts = datetime.fromisoformat(ts_str) if ts_str else db_run.created_at
    except Exception:
        ts = db_run.created_at

    return IntelligenceResponse(
        run_id=db_run.id,
        region=result["region"],
        timestamp=ts,
        events=events,  # ðŸ‘ˆ now the frontend gets the actual timeline
        trends=trends,
        scenarios=scenarios,
        validation=validation,
        approval_status=result.get("approval_status"),
        confidence=result.get("confidence_score", overall_confidence),
        messages=result.get("messages") or [],
        explainability=explainability,
    )


@router.get("/runs", response_model=List[AnalysisRunSummary])
def list_runs(
    limit: int = Query(10, ge=1, le=100),
    db: Session = Depends(get_db),
) -> List[AnalysisRunSummary]:
    """
    Lightweight history endpoint for the last N analysis runs.
    """

    rows = (
        db.query(AnalysisRun)
        .order_by(AnalysisRun.created_at.desc())
        .limit(limit)
        .all()
    )

    return [
        AnalysisRunSummary(
            id=row.id,
            region=row.region,
            created_at=row.created_at,
            trend_classification=row.trend_classification,
            overall_confidence=row.overall_confidence,
            recommendation_summary=row.recommendation_summary,
        )
        for row in rows
    ]

### ./backend/app/routers/reports.py ###
from fastapi import APIRouter, HTTPException
from datetime import datetime
import pandas as pd
from pathlib import Path
import logging

logger = logging.getLogger(__name__)
router = APIRouter()

PROJECT_ROOT = Path(__file__).parent.parent.parent
DATA_DIR = PROJECT_ROOT / "data" / "processed"
CP_FILE = DATA_DIR / "conflict_proneness_v2.csv"

def load_conflict_proneness_data():
    """Load conflict proneness data from CSV"""
    try:
        return pd.read_csv(CP_FILE)
    except FileNotFoundError:
        raise HTTPException(status_code=404, detail=f"Data file not found: {CP_FILE}")

@router.post("/generate-brief")
async def generate_brief():
    """Generate daily brief using Conflict Proneness data"""
    try:
        logger.info("Starting brief generation...")

        # Load conflict proneness data
        df = load_conflict_proneness_data()
        logger.info(f"Data loaded: {len(df)} rows")

        # Group by region
        region_summary = df.groupby('region').agg({
            'incidents': 'sum',
            'fatalities': 'sum',
            'conflict_proneness': 'first'
        }).reset_index()

        logger.info(f"Regions summarized: {len(region_summary)}")

        # Build brief data dict
        brief_data = {}
        max_incidents = region_summary['incidents'].max()

        for _, row in region_summary.iterrows():
            region = row['region']
            incidents = int(row['incidents'])
            fatalities = int(row['fatalities'])
            cp_score = float(row['conflict_proneness'])

            # Determine category
            if cp_score >= 7:
                category = 'SEVERE'
            elif cp_score >= 5:
                category = 'HIGH'
            elif cp_score >= 3:
                category = 'MEDIUM'
            else:
                category = 'LOW'

            brief_data[region] = {
                'cp_score': cp_score,
                'incidents': incidents,
                'fatalities': fatalities,
                'category': category
            }

        logger.info(f"Brief data prepared for {len(brief_data)} regions")

        # Simple brief generation (without Groq for now)
        brief_text = f"Sudan Conflict Analysis Report\n"
        brief_text += f"Total Regions: {len(region_summary)}\n"
        brief_text += f"Total Incidents: {int(region_summary['incidents'].sum())}\n"
        brief_text += f"Total Fatalities: {int(region_summary['fatalities'].sum())}\n"
        brief_text += f"High Risk Regions: {(df['proneness_level'].isin(['EXTREME', 'VERY HIGH'])).sum()}"

        logger.info("Brief generation complete")

        return {
            "brief": brief_text,
            "generated_at": datetime.now().isoformat(),
            "regions_analyzed": len(brief_data),
            "total_events": int(region_summary['incidents'].sum()),
            "total_fatalities": int(region_summary['fatalities'].sum())
        }

    except Exception as e:
        logger.error(f"Error in generate_brief: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=f"Error: {str(e)}")

@router.get("/reports")
async def get_reports():
    """Get list of past reports"""
    return {
        "reports": [],
        "message": "Click 'Generate New Brief' to create your first report"
    }

### ./backend/app/routes/__init__.py ###

### ./backend/app/services/__init__.py ###

### ./backend/app/services/vector_store.py ###
# backend/app/services/vector_store.py

import os
from typing import List, Dict, Optional
from uuid import uuid4

from dotenv import load_dotenv
from qdrant_client import QdrantClient
from qdrant_client.models import (
    Distance,
    VectorParams,
    PointStruct,
    PayloadSchemaType,
)
from sentence_transformers import SentenceTransformer

load_dotenv()


class VectorStore:
    def __init__(self):
        print("ðŸ”§ Initializing Vector Store...")

        # Connect to Qdrant Cloud or local
        self.client = QdrantClient(
            url=os.getenv("QDRANT_URL"),
            api_key=os.getenv("QDRANT_API_KEY"),
            timeout=60,
        )

        self.collection_name = "sudan_events"

        # Load multilingual embedding model
        print("ðŸ“¦ Loading embedding model...")
        self.encoder = SentenceTransformer(
            "Alibaba-NLP/gte-multilingual-base",
            trust_remote_code=True,
        )
        print("âœ… Embedding model loaded")

        self._init_collection()
        self._ensure_region_index()

    def _init_collection(self):
        """Initialize Qdrant collection"""
        try:
            collections = self.client.get_collections().collections
            exists = any(c.name == self.collection_name for c in collections)

            if not exists:
                self.client.create_collection(
                    collection_name=self.collection_name,
                    vectors_config=VectorParams(
                        size=768,
                        distance=Distance.COSINE,
                    ),
                )
                print(f"âœ… Created collection: {self.collection_name}")
            else:
                print(f"âœ… Collection exists: {self.collection_name}")

        except Exception as e:
            print(f"âŒ Error initializing collection: {e}")
            raise

    def _ensure_region_index(self):
        """Ensure 'region' payload field is indexed for filtering"""
        try:
            self.client.create_payload_index(
                collection_name=self.collection_name,
                field_name="region",
                field_schema=PayloadSchemaType.KEYWORD,
            )
            print("âœ… Created payload index for 'region'")
        except Exception as e:
            msg = str(e)
            if "already exists" in msg or "index with name" in msg:
                print("â„¹ï¸ Payload index for 'region' already exists")
            else:
                print(f"âŒ Error creating 'region' index: {e}")

    def embed_text(self, text: str) -> List[float]:
        """Create embedding vector from text"""
        return self.encoder.encode(text).tolist()

    def embed_event(self, event: dict) -> List[float]:
        """
        Create an embedding vector from an event dictionary.
        Typically convert key metadata fields into a summary string.
        """
        summary = f"{event.get('date', '')} {event.get('location', '')} {event.get('event_type', '')} " \
                  f"{', '.join([actor['name'] for actor in event.get('actors', [])])} " \
                  f"Severity: {event.get('severity', '')}"
        return self.embed_text(summary)

    def upsert_event(self, event_id: str, vector: List[float], payload: Dict) -> bool:
        """
        Upsert (insert or update) an event point in Qdrant.

        The actual Qdrant point id is a generated UUID.
        The logical event_id is stored in the payload.
        """
        try:
            qdrant_id = str(uuid4())
            self.client.upsert(
                collection_name=self.collection_name,
                points=[
                    PointStruct(
                        id=qdrant_id,
                        vector=vector,
                        payload={"event_id": event_id, **payload},
                    )
                ],
            )
            return True
        except Exception as e:
            print(f"âŒ Error upserting event {event_id}: {e}")
            return False

    def add_event(self, event_id: str, text: str, metadata: Dict) -> bool:
        """
        Convenience method: add event using raw text for embedding.
        """
        embedding = self.embed_text(text)
        return self.upsert_event(event_id, embedding, metadata)

    def semantic_search(
        self,
        query: str,
        filters: Optional[Dict] = None,
        top_k: int = 10,
    ) -> List[Dict]:
        """Search for relevant events in vector store"""
        try:
            query_embedding = self.embed_text(query)

            qdrant_filter = None
            if filters:
                conditions = [
                    {"key": k, "match": {"value": v}} for k, v in filters.items()
                ]
                qdrant_filter = {"must": conditions} if conditions else None

            results = self.client.search(
                collection_name=self.collection_name,
                query_vector=query_embedding,
                limit=top_k,
                query_filter=qdrant_filter,
                with_payload=True,
            )

            return [
                {
                    "id": r.id,
                    "score": r.score,
                    "metadata": r.payload,
                }
                for r in results
            ]

        except Exception as e:
            print(f"âŒ Search error: {e}")
            return []

    def get_event_count(self) -> int:
        """Get total number of event points in collection"""
        try:
            info = self.client.get_collection(self.collection_name)
            return info.points_count
        except Exception:
            return 0

### ./backend/app/services/vector_store.py.old ###
# backend/app/services/vector_store.py

import os
from typing import List, Dict
from uuid import uuid4

from dotenv import load_dotenv
from qdrant_client import QdrantClient
from qdrant_client.models import (
    Distance,
    VectorParams,
    PointStruct,
    PayloadSchemaType,
)
from sentence_transformers import SentenceTransformer

load_dotenv()


class VectorStore:
    def __init__(self):
        print("ðŸ”§ Initializing Vector Store...")

        # Connect to Qdrant Cloud
        self.client = QdrantClient(
            url=os.getenv("QDRANT_URL"),
            api_key=os.getenv("QDRANT_API_KEY"),
            timeout=60,
        )

        self.collection_name = "sudan_events"

        # Load multilingual embedding model
        print("ðŸ“¦ Loading embedding model...")
        # â¬‡ï¸ trust_remote_code=True is required for Alibaba-NLP/gte-multilingual-base
        self.encoder = SentenceTransformer(
            "Alibaba-NLP/gte-multilingual-base",
            trust_remote_code=True,
        )
        print("âœ… Embedding model loaded")

        self._init_collection()
        self._ensure_region_index()

    def _init_collection(self):
        """Initialize Qdrant collection"""
        try:
            collections = self.client.get_collections().collections
            exists = any(c.name == self.collection_name for c in collections)

            if not exists:
                self.client.create_collection(
                    collection_name=self.collection_name,
                    vectors_config=VectorParams(
                        size=768,
                        distance=Distance.COSINE,
                    ),
                )
                print(f"âœ… Created collection: {self.collection_name}")
            else:
                print(f"âœ… Collection exists: {self.collection_name}")

        except Exception as e:
            print(f"âŒ Error initializing collection: {e}")
            raise

    def _ensure_region_index(self):
        """Make sure 'region' is indexed for filtering"""
        try:
            self.client.create_payload_index(
                collection_name=self.collection_name,
                field_name="region",
                field_schema=PayloadSchemaType.KEYWORD,
            )
            print("âœ… Created payload index for 'region'")
        except Exception as e:
            # Qdrant will complain if index already exists â€“ that's fine
            msg = str(e)
            if "already exists" in msg or "index with name" in msg:
                print("â„¹ï¸ Payload index for 'region' already exists")
            else:
                print(f"âŒ Error creating 'region' index: {e}")

    def add_event(self, event_id: str, text: str, metadata: Dict) -> bool:
        """
        Add event to vector store.

        Qdrant requires point IDs to be:
        - an unsigned integer, or
        - a valid UUID

        We generate a UUID for the internal point ID, and store the logical
        ID (e.g. 'gdelt-138') inside the payload as `event_id`.
        """
        try:
            embedding = self.encoder.encode(text).tolist()
            qdrant_id = str(uuid4())  # âœ… valid UUID for Qdrant

            payload = {
                "event_id": event_id,  # your logical ID
                **metadata,
            }

            self.client.upsert(
                collection_name=self.collection_name,
                points=[
                    PointStruct(
                        id=qdrant_id,
                        vector=embedding,
                        payload=payload,
                    )
                ],
            )
            return True
        except Exception as e:
            print(f"âŒ Error adding {event_id}: {e}")
            return False

    def semantic_search(
        self,
        query: str,
        filters: Dict | None = None,
        top_k: int = 10,
    ) -> List[Dict]:
        """Search for relevant events"""
        try:
            query_embedding = self.encoder.encode(query).tolist()

            qdrant_filter = None
            if filters:
                conditions = [
                    {"key": k, "match": {"value": v}} for k, v in filters.items()
                ]
                qdrant_filter = {"must": conditions} if conditions else None

            results = self.client.search(
                collection_name=self.collection_name,
                query_vector=query_embedding,
                limit=top_k,
                query_filter=qdrant_filter,
                with_payload=True,
            )

            return [
                {
                    "id": r.id,
                    "score": r.score,
                    "metadata": r.payload,
                }
                for r in results
            ]

        except Exception as e:
            print(f"âŒ Search error: {e}")
            return []

    def get_event_count(self) -> int:
        """Get total events in collection"""
        try:
            info = self.client.get_collection(self.collection_name)
            return info.points_count
        except Exception:
            return 0

### ./backend/app/utils/__init__.py ###

### ./backend/app/utils/coordinates.py ###
# Sudan regions coordinates (centroid of each state)
SUDAN_COORDINATES = {
    "North Darfur": {"lat": 14.0, "lon": 26.0},
    "Khartoum": {"lat": 15.5, "lon": 32.5},
    "Al Jazirah": {"lat": 14.0, "lon": 35.0},
    "North Kordofan": {"lat": 16.5, "lon": 30.5},
    "South Darfur": {"lat": 11.5, "lon": 25.0},
    "West Kordofan": {"lat": 13.5, "lon": 27.0},
    "White Nile": {"lat": 13.0, "lon": 32.0},
    "South Kordofan": {"lat": 11.0, "lon": 30.0},
    "Northern": {"lat": 18.5, "lon": 31.0},
    "Red Sea": {"lat": 19.0, "lon": 37.5},
    "Sennar": {"lat": 13.5, "lon": 34.5},
    "East Darfur": {"lat": 12.5, "lon": 26.5},
    "Blue Nile": {"lat": 12.0, "lon": 33.0},
    "West Darfur": {"lat": 12.5, "lon": 22.5},
    "Central Darfur": {"lat": 12.0, "lon": 24.5},
    "River Nile": {"lat": 17.5, "lon": 30.5},
    "Abyei": {"lat": 10.0, "lon": 29.0},
    "Kassala": {"lat": 15.5, "lon": 36.0},
    "Gedaref": {"lat": 14.5, "lon": 35.0},
}

### ./backend/create_tables.py ###
from datetime import datetime

from database import Base, engine
from app.models.gdelt import GDELTEvent
from app.models.acled import ACLEDEvent
from app.models.analysis import AnalysisRun, AnalysisFeedback


def create_all_tables():
    print(f"[{datetime.utcnow().isoformat()}] Creating tables...")
    Base.metadata.create_all(bind=engine)
    print("âœ… Tables created (or already existed).")


if __name__ == "__main__":
    create_all_tables()

### ./backend/requirements.txt ###
absl-py==2.3.1
affine==2.4.0
aiohappyeyeballs==2.6.1
aiohttp==3.13.2
aiosignal==1.4.0
alembic==1.17.1
annotated-doc==0.0.3
annotated-types==0.7.0
anyio==4.11.0
astunparse==1.6.3
attrs==25.4.0
certifi==2025.10.5
charset-normalizer==3.4.4
click==8.3.0
click-plugins==1.1.1.2
cligj==0.7.2
colorama==0.4.6
dataclasses-json==0.6.7
distro==1.9.0
et_xmlfile==2.0.0
fastapi==0.121.0
filelock==3.20.0
flatbuffers==25.9.23
frozenlist==1.8.0
fsspec==2025.10.0
gast==0.6.0
geopandas==1.1.1
google-pasta==0.2.0
greenlet==3.2.4
groq==0.33.0
grpcio==1.76.0
h11==0.16.0
h2==4.3.0
h5py==3.15.1
hpack==4.1.0
httpcore==1.0.9
httptools==0.7.1
httpx==0.28.1
httpx-sse==0.4.3
huggingface-hub==0.36.0
hyperframe==6.1.0
idna==3.11
Jinja2==3.1.6
joblib==1.5.2
jsonpatch==1.33
jsonpointer==3.0.0
keras==3.12.0
langchain==1.0.7
langchain-classic==1.0.0
langchain-community==0.4.1
langchain-core==1.0.5
langchain-ollama==1.0.0
langchain-text-splitters==1.0.0
langgraph==1.0.3
langgraph-checkpoint==3.0.1
langgraph-prebuilt==1.0.4
langgraph-sdk==0.2.9
langsmith==0.4.43
libclang==18.1.1
Mako==1.3.10
Markdown==3.10
markdown-it-py==4.0.0
MarkupSafe==3.0.3
marshmallow==3.26.1
mdurl==0.1.2
ml_dtypes==0.5.3
mpmath==1.3.0
multidict==6.7.0
mypy_extensions==1.1.0
namex==0.1.0
narwhals==2.10.1
networkx==3.5
numpy==2.3.4
ollama==0.6.1
openpyxl==3.1.5
opt_einsum==3.4.0
optree==0.18.0
orjson==3.11.4
ormsgpack==1.12.0
packaging==25.0
pandas==2.3.3
pillow==12.0.0
plotly==6.3.1
portalocker==3.2.0
propcache==0.4.1
protobuf==6.33.1
psycopg2-binary==2.9.11
pydantic==2.12.3
pydantic-settings==2.12.0
pydantic_core==2.41.4
Pygments==2.19.2
pyogrio==0.11.1
pyparsing==3.2.5
pyproj==3.7.2
python-dateutil==2.9.0.post0
python-dotenv==1.2.1
python-multipart==0.0.20
pytz==2025.2
PyYAML==6.0.3
prophet==1.1
qdrant-client==1.15.1
rasterio==1.4.3
regex==2025.11.3
requests==2.32.5
requests-toolbelt==1.0.0
rich==14.2.0
safetensors==0.6.2
scikit-learn==1.7.2
scipy==1.16.3
sentence-transformers==5.1.2
setuptools==80.9.0
shapely==2.1.2
six==1.17.0
sniffio==1.3.1
SQLAlchemy==2.0.44
starlette==0.49.3
sympy==1.14.0
tenacity==9.1.2
tensorboard==2.20.0
tensorboard-data-server==0.7.2
tensorflow==2.20.0
termcolor==3.2.0
tf_keras==2.20.1
threadpoolctl==3.6.0
tokenizers==0.22.1
torch==2.9.1
tqdm==4.67.1
transformers==4.57.1
typing-inspect==0.9.0
typing-inspection==0.4.2
typing_extensions==4.15.0
tzdata==2025.2
urllib3==2.5.0
uvicorn==0.38.0
watchfiles==1.1.1
websockets==15.0.1
Werkzeug==3.1.3
wheel==0.45.1
wrapt==2.0.1
xxhash==3.6.0
yarl==1.22.0
zstandard==0.25.0

### ./backend/scripts/__init__.py ###

### ./backend/scripts/populate_db.py ###
import pandas as pd
from sqlalchemy import create_engine, text

engine = create_engine(
    "postgresql://sudan_cram_user:0iUMUWn4LLMvzyYxMu1ZB7Ry8n8nPSH7@dpg-d453f2euk2gs73fs5lgg-a.oregon-postgres.render.com/sudan_cram_db"
)

# ---------- NEW: clear target tables first ----------
with engine.begin() as conn:
    # Order matters if you have FKs; here they look independent
    conn.execute(text("TRUNCATE TABLE gdelt_events RESTART IDENTITY CASCADE;"))
    conn.execute(text("TRUNCATE TABLE acled_events RESTART IDENTITY CASCADE;"))
# ----------------------------------------------------


# --------- GDELT ----------
df_gdelt = pd.read_csv("data/gdelt/sudan_events_20251110_1005.csv")

df_gdelt = df_gdelt.rename(columns={
    "date": "event_date",
    "goldstein": "goldstein_scale",
    "actor1": "actor1_name",
    "actor2": "actor2_name",
    "location": "region",
})

# Add required event_id with deterministic IDs
df_gdelt["event_id"] = ["gdelt-" + str(i) for i in df_gdelt.index]

expected_gdelt_cols = [
    "event_id",
    "event_date",
    "event_code",
    "goldstein_scale",
    "num_mentions",
    "avg_tone",
    "actor1_name",
    "actor2_name",
    "region",
    "latitude",
    "longitude",
]

df_gdelt = df_gdelt[expected_gdelt_cols]

df_gdelt["latitude"] = pd.to_numeric(df_gdelt["latitude"], errors="coerce")
df_gdelt["longitude"] = pd.to_numeric(df_gdelt["longitude"], errors="coerce")

df_gdelt.to_sql("gdelt_events", engine, if_exists="append", index=False)


# --------- ACLED ----------
df_acled = pd.read_csv("data/processed/acled_with_causes.csv")

df_acled = df_acled.rename(columns={
    "event_date": "event_date",
    "REGION": "region",
    "EVENT_TYPE": "event_type",
    "FATALITIES": "fatalities",
    "CENTROID_LATITUDE": "latitude",
    "CENTROID_LONGITUDE": "longitude",
})

df_acled["event_id"] = ["acled-" + str(i) for i in df_acled.index]

expected_acled_cols = [
    "event_id",
    "event_date",
    "region",
    "event_type",
    "fatalities",
    "latitude",
    "longitude",
]

df_acled = df_acled[expected_acled_cols]

df_acled["latitude"] = pd.to_numeric(df_acled["latitude"], errors="coerce")
df_acled["longitude"] = pd.to_numeric(df_acled["longitude"], errors="coerce")

df_acled.to_sql("acled_events", engine, if_exists="append", index=False)

### ./backend/scripts/populate_vector_store.py ###
from datetime import datetime, timedelta

from backend.app.services.vector_store import VectorStore
from backend.app.models.gdelt import GDELTEvent
from backend.app.models.acled import ACLEDEvent
from backend.database import SessionLocal


def populate():
    print("=" * 60)
    print("Sudan CRAM - Vector Store Population")
    print("=" * 60)

    db = SessionLocal()
    vs = VectorStore()

    cutoff = datetime.now() - timedelta(days=90)
    print(f"\nðŸ“… Fetching events since: {cutoff.strftime('%Y-%m-%d')}\n")

    # ---------------- GDELT ----------------
    print("ðŸ” Processing GDELT events...")
    gdelt_events = (
        db.query(GDELTEvent)
        .filter(GDELTEvent.event_date >= cutoff)
        .order_by(GDELTEvent.event_date.desc())
        .all()
    )

    gdelt_added = 0
    for event in gdelt_events:
        text = f"{event.actor1_name} {event.event_code} against {event.actor2_name} in {event.region}"

        if vs.add_event(
            event_id=f"gdelt-{event.id}",
            text=text,
            metadata={
                "source": "GDELT",
                "db_id": event.id,
                "db_event_id": event.event_id,
                "region": event.region,
                "date": event.event_date.isoformat(),
                "actors": [event.actor1_name, event.actor2_name],
                "event_type": event.event_code,
            },
        ):
            gdelt_added += 1
            if gdelt_added and gdelt_added % 100 == 0:
                print(f"  âœ“ {gdelt_added} GDELT events indexed")

    # ---------------- ACLED ----------------
    print("\nðŸ” Processing ACLED events...")
    acled_events = (
        db.query(ACLEDEvent)
        .filter(ACLEDEvent.event_date >= cutoff.date())
        .order_by(ACLEDEvent.event_date.desc())
        .all()
    )

    acled_added = 0
    for event in acled_events:
        text = (
            f"{event.event_type}: {event.actor1} vs {event.actor2} "
            f"in {event.region}, {event.fatalities} fatalities"
        )

        if vs.add_event(
            event_id=f"acled-{event.id}",
            text=text,
            metadata={
                "source": "ACLED",
                "db_id": event.id,
                "db_event_id": event.event_id,
                "region": event.region,
                "date": event.event_date.isoformat(),
                "actors": [event.actor1, event.actor2],
                "event_type": event.event_type,
                "fatalities": event.fatalities,
            },
        ):
            acled_added += 1
            if acled_added and acled_added % 50 == 0:
                print(f"  âœ“ {acled_added} ACLED events indexed")

    print("\n" + "=" * 60)
    print("âœ… COMPLETE")
    print(
        f"   GDELT: {gdelt_added} | ACLED: {acled_added} | Total: {gdelt_added + acled_added}"
    )
    print(f"   Vector Store Count: {vs.get_event_count()}")
    print("=" * 60)

    db.close()


if __name__ == "__main__":
    populate()

### ./frontend/README.md ###
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.

### ./frontend/eslint.config.mjs ###
import { defineConfig, globalIgnores } from "eslint/config";
import nextVitals from "eslint-config-next/core-web-vitals";
import nextTs from "eslint-config-next/typescript";

const eslintConfig = defineConfig([
  ...nextVitals,
  ...nextTs,
  // Override default ignores of eslint-config-next.
  globalIgnores([
    // Default ignores of eslint-config-next:
    ".next/**",
    "out/**",
    "build/**",
    "next-env.d.ts",
  ]),
]);

export default eslintConfig;

### ./frontend/next.config.js ###
/** @type {import('next').NextConfig} */
const nextConfig = {
  output: 'standalone',
  reactStrictMode: true,
  swcMinify: true,
  experimental: {
    serverActions: {
      allowedOrigins: ['*'],
    },
  },
}

module.exports = nextConfig

### ./frontend/postcss.config.js ###
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

### ./frontend/postcss.config.mjs ###
const config = {
  plugins: {
    "@tailwindcss/postcss": {},
  },
};

export default config;

### ./frontend/src/app/alerts/page.tsx ###
'use client'

import React, { useState, useEffect } from 'react'
import { Layout } from '@/components/layout/Layout'

interface Alert {
  region: string
  week: string
  risk_score: number
  event_count: number
  alert_level: string
  explanation: string
}

interface AlertResponse {
  alerts: Alert[]
  total_alerts: number
  source: string
}

export default function AlertsPage() {
  const [alerts, setAlerts] = useState<Alert[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [selectedLevel, setSelectedLevel] = useState<string>('ALL')
  const [searchQuery, setSearchQuery] = useState('')
  const [sortBy, setSortBy] = useState<'risk' | 'date'>('risk')

  useEffect(() => {
    fetchAlerts()
  }, [])

  const fetchAlerts = async () => {
    setLoading(true)
    setError(null)
    
    try {
      console.log('Fetching alerts from backend...')
      
      const response = await fetch(`${process.env.NEXT_PUBLIC_BACKEND_URL || "http://localhost:8000"}/api/alerts`)
      console.log('Response status:', response.status)
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`)
      }
      
      const data: AlertResponse = await response.json()
      console.log('Response data:', data)
      
      if (data.alerts) {
        setAlerts(data.alerts || [])
        console.log(`Loaded ${data.alerts?.length || 0} alerts`)
      } else {
        throw new Error('No alerts in response')
      }
    } catch (error) {
      console.error('Failed to fetch alerts:', error)
      setError(error instanceof Error ? error.message : 'Failed to load alerts')
    } finally {
      setLoading(false)
    }
  }

  const getSeverityColor = (level: string) => {
    const colors: Record<string, string> = {
      SEVERE: 'bg-red-600 text-white border-red-700',
      HIGH: 'bg-orange-500 text-white border-orange-600',
      MEDIUM: 'bg-yellow-500 text-slate-900 border-yellow-600',
      LOW: 'bg-green-500 text-white border-green-600'
    }
    return colors[level.toUpperCase()] || 'bg-gray-500'
  }

  const getSeverityIcon = (level: string) => {
    const icons: Record<string, string> = {
      SEVERE: 'ðŸš¨',
      HIGH: 'âš ï¸',
      MEDIUM: 'âš¡',
      LOW: 'â„¹ï¸'
    }
    return icons[level.toUpperCase()] || 'ðŸ“‹'
  }

  const formatDate = (dateStr: string) => {
    try {
      const date = new Date(dateStr)
      return date.toLocaleDateString('en-US', { 
        year: 'numeric', 
        month: 'short', 
        day: 'numeric' 
      })
    } catch {
      return dateStr
    }
  }

  const exportToCSV = () => {
    const headers = ['Region', 'Week', 'Risk Score', 'Events', 'Severity', 'Explanation']
    const rows = filteredAlerts.map(alert => [
      alert.region,
      alert.week,
      alert.risk_score.toFixed(2),
      alert.event_count,
      alert.alert_level,
      alert.explanation.replace(/,/g, ';')
    ])

    const csv = [headers.join(','), ...rows.map(row => row.join(','))].join('\n')
    const blob = new Blob([csv], { type: 'text/csv' })
    const url = URL.createObjectURL(blob)
    const link = document.createElement('a')
    link.href = url
    link.download = `sudan-cram-alerts-${new Date().toISOString().split('T')[0]}.csv`
    link.click()
  }

  let filteredAlerts = alerts.filter(alert => 
    (selectedLevel === 'ALL' || alert.alert_level === selectedLevel) &&
    (searchQuery === '' || 
     alert.region.toLowerCase().includes(searchQuery.toLowerCase()) ||
     alert.explanation.toLowerCase().includes(searchQuery.toLowerCase()))
  )

  // Sort alerts
  if (sortBy === 'risk') {
    filteredAlerts.sort((a, b) => b.risk_score - a.risk_score)
  } else {
    filteredAlerts.sort((a, b) => new Date(b.week).getTime() - new Date(a.week).getTime())
  }

  // Calculate summary
  const summary = {
    total: alerts.length,
    severe: alerts.filter(a => a.alert_level === 'SEVERE').length,
    high: alerts.filter(a => a.alert_level === 'HIGH').length,
    medium: alerts.filter(a => a.alert_level === 'MEDIUM').length,
    low: alerts.filter(a => a.alert_level === 'LOW').length,
  }

  if (loading) {
    return (
      <Layout>
        <div className="flex items-center justify-center h-full">
          <div className="text-center">
            <div className="text-6xl mb-4 animate-spin">ðŸ”„</div>
            <div className="text-xl font-semibold text-white">Loading alerts...</div>
            <div className="text-sm text-slate-400 mt-2">Fetching from backend...</div>
          </div>
        </div>
      </Layout>
    )
  }

  if (error) {
    return (
      <Layout>
        <div className="flex items-center justify-center h-full">
          <div className="bg-red-900/20 border border-red-700/50 rounded-lg p-8 max-w-2xl">
            <div className="text-center">
              <div className="text-6xl mb-4">âš ï¸</div>
              <div className="text-2xl font-semibold text-red-400 mb-4">Failed to Load Alerts</div>
              <div className="text-slate-300 mb-6">{error}</div>
              <button
                onClick={fetchAlerts}
                className="px-6 py-3 bg-teal-600 hover:bg-teal-700 text-white rounded-lg transition-colors font-medium"
              >
                ðŸ”„ Retry
              </button>
            </div>
          </div>
        </div>
      </Layout>
    )
  }

  return (
    <Layout>
      <div className="h-full flex flex-col">
        {/* Header */}
        <div className="mb-6">
          <h1 className="text-4xl font-bold text-white mb-2">Alert Management</h1>
          <p className="text-lg text-slate-400">Real-time conflict risk alerts across Sudan</p>
        </div>

        {/* Summary Cards */}
        <div className="grid grid-cols-5 gap-4 mb-6">
          <div className="bg-slate-800 p-4 rounded-lg border border-slate-700">
            <div className="text-sm text-slate-400 mb-1">Total Alerts</div>
            <div className="text-3xl font-bold text-white">{summary.total}</div>
          </div>
          <div className="bg-red-900/20 border-red-700/50 p-4 rounded-lg border">
            <div className="text-sm text-red-400 mb-1">Severe</div>
            <div className="text-3xl font-bold text-red-500">{summary.severe}</div>
          </div>
          <div className="bg-orange-900/20 border-orange-700/50 p-4 rounded-lg border">
            <div className="text-sm text-orange-400 mb-1">High</div>
            <div className="text-3xl font-bold text-orange-500">{summary.high}</div>
          </div>
          <div className="bg-yellow-900/20 border-yellow-700/50 p-4 rounded-lg border">
            <div className="text-sm text-yellow-400 mb-1">Medium</div>
            <div className="text-3xl font-bold text-yellow-500">{summary.medium}</div>
          </div>
          <div className="bg-green-900/20 border-green-700/50 p-4 rounded-lg border">
            <div className="text-sm text-green-400 mb-1">Low</div>
            <div className="text-3xl font-bold text-green-500">{summary.low}</div>
          </div>
        </div>

        {/* Filters and Actions */}
        <div className="bg-slate-800 p-4 rounded-lg border border-slate-700 mb-4 flex items-center gap-4 flex-wrap">
          <div className="flex-1 min-w-xs">
            <input
              type="text"
              placeholder="Search by region..."
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              className="w-full px-4 py-2 bg-slate-900 text-white border border-slate-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-teal-500"
            />
          </div>
          <div className="flex items-center gap-2">
            <label className="text-sm text-slate-400">Level:</label>
            <select
              value={selectedLevel}
              onChange={(e) => setSelectedLevel(e.target.value)}
              className="px-4 py-2 bg-slate-900 text-white border border-slate-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-teal-500"
            >
              <option value="ALL">All Levels</option>
              <option value="SEVERE">Severe</option>
              <option value="HIGH">High</option>
              <option value="MEDIUM">Medium</option>
              <option value="LOW">Low</option>
            </select>
          </div>
          <div className="flex items-center gap-2">
            <label className="text-sm text-slate-400">Sort:</label>
            <select
              value={sortBy}
              onChange={(e) => setSortBy(e.target.value as 'risk' | 'date')}
              className="px-4 py-2 bg-slate-900 text-white border border-slate-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-teal-500"
            >
              <option value="risk">By Risk Score</option>
              <option value="date">By Date</option>
            </select>
          </div>
          <button
            onClick={exportToCSV}
            disabled={filteredAlerts.length === 0}
            className="px-4 py-2 bg-teal-600 hover:bg-teal-700 text-white rounded-lg transition-colors font-medium disabled:opacity-50 disabled:cursor-not-allowed"
          >
            ðŸ“¥ Export CSV
          </button>
        </div>

        {/* Alerts List */}
        <div className="flex-1 overflow-y-auto space-y-3">
          {filteredAlerts.length === 0 ? (
            <div className="bg-slate-800 p-8 rounded-lg border border-slate-700 text-center">
              <div className="text-4xl mb-4">ðŸ”</div>
              <div className="text-xl font-semibold text-white mb-2">No alerts found</div>
              <p className="text-slate-400">Try adjusting your filters or search query</p>
            </div>
          ) : (
            filteredAlerts.map((alert, idx) => (
              <div
                key={`${alert.region}-${alert.week}-${idx}`}
                className="bg-slate-800 rounded-lg border border-slate-700 overflow-hidden transition-all hover:border-slate-600 hover:shadow-lg hover:shadow-slate-900/50"
              >
                <div className="p-4">
                  <div className="flex items-start gap-4">
                    {/* Severity Badge */}
                    <div className="flex-shrink-0">
                      <div className={`px-3 py-1 rounded-lg text-sm font-bold border ${getSeverityColor(alert.alert_level)}`}>
                        {getSeverityIcon(alert.alert_level)} {alert.alert_level}
                      </div>
                    </div>

                    {/* Alert Content */}
                    <div className="flex-1">
                      <div className="flex items-start justify-between mb-2">
                        <div>
                          <h3 className="text-lg font-bold text-white mb-1">{alert.region}</h3>
                          <div className="flex items-center gap-3 text-sm text-slate-400">
                            <span>ðŸ“… {formatDate(alert.week)}</span>
                            <span>â€¢</span>
                            <span>ðŸ“Š Risk: {alert.risk_score.toFixed(2)}</span>
                            <span>â€¢</span>
                            <span>ðŸ”¥ {alert.event_count} events</span>
                          </div>
                        </div>
                      </div>

                      <p className="text-slate-300 text-sm">{alert.explanation}</p>
                    </div>
                  </div>
                </div>
              </div>
            ))
          )}
        </div>
      </div>
    </Layout>
  )
}

### ./frontend/src/app/analytics/page.tsx ###
// src/app/analytics/page.tsx
'use client'

import React, { useState, useEffect } from 'react'
import { Layout } from '@/components/layout/Layout'
import { BarChart, Bar, LineChart, Line, PieChart, Pie, Cell, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer } from 'recharts'

interface AnalyticsData {
  summary: {
    total_events: number
    total_fatalities: number
    avg_climate_risk: number
    avg_conflict_proneness: number  // âœ… FIXED: Changed from avg_conflict_risk
    highest_risk_region: string
    total_regions: number
  }
  regional_data: Array<{
    region: string
    climate_risk_score: number
    political_risk_score: number
    events_6m: number
    fatalities_6m: number
  }>
  risk_distribution: {
    climate: Record<string, number>
    conflict: Record<string, number>
  }
  top_regions: Array<{
    region: string
    climate_risk_score: number
    political_risk_score: number
    cdi_category: string
    risk_category: string
    events_6m: number
    fatalities_6m: number
  }>
}

interface MonthlyTrendData {
  month: string
  events: number
  fatalities: number
}

const CLIMATE_COLORS = {
  NORMAL: '#91cf60',
  WATCH: '#fee08b',
  ALERT: '#fc8d59',
  EXTREME: '#d73027',
}

const CONFLICT_COLORS = {
  LOW: '#91cf60',
  MODERATE: '#fee08b',
  HIGH: '#fc8d59',
  'VERY HIGH': '#fc8d59',
  EXTREME: '#d73027',
}

export default function AnalyticsPage() {
  const [data, setData] = useState<AnalyticsData | null>(null)
  const [monthlyTrend, setMonthlyTrend] = useState<MonthlyTrendData[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    const fetchAllData = async () => {
      try {
        const backendUrl = process.env.NEXT_PUBLIC_BACKEND_URL || "http://localhost:8000"

        // âœ… Fetch analytics data
        const analyticsResponse = await fetch(`${backendUrl}/api/analytics`)
        if (!analyticsResponse.ok) throw new Error('Failed to fetch analytics')
        const analyticsData = await analyticsResponse.json()
        setData(analyticsData)

        // âœ… Fetch monthly trend data separately
        const trendResponse = await fetch(`${backendUrl}/api/monthly-trend`)
        if (!trendResponse.ok) throw new Error('Failed to fetch monthly trend')
        const trendData = await trendResponse.json()
        console.log('âœ… Monthly trend data:', trendData)
        setMonthlyTrend(trendData.data)

      } catch (err) {
        console.error('âŒ Fetch error:', err)
        setError(err instanceof Error ? err.message : 'Unknown error')
      } finally {
        setLoading(false)
      }
    }

    fetchAllData()
  }, [])

  if (loading) {
    return (
      <Layout>
        <div className="flex items-center justify-center min-h-96">
          <div className="text-white text-xl">Loading analytics...</div>
        </div>
      </Layout>
    )
  }

  if (error || !data) {
    return (
      <Layout>
        <div className="flex items-center justify-center min-h-96">
          <div className="text-red-500 text-xl">Error: {error || 'No data available'}</div>
        </div>
      </Layout>
    )
  }

  // Transform risk distributions for pie charts
  const climateChartData = Object.entries(data.risk_distribution.climate).map(([name, value]) => ({
    name,
    value
  }))

  const conflictChartData = Object.entries(data.risk_distribution.conflict).map(([name, value]) => ({
    name,
    value
  }))

  return (
    <Layout>
      <div className="space-y-8">
        {/* Header */}
        <div>
          <h1 className="text-3xl font-bold text-white mb-2">ðŸ“Š Bivariate Analytics Dashboard</h1>
          <p className="text-slate-400">Comprehensive climate + conflict data analysis and trends</p>
        </div>

        {/* Summary Cards */}
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-5 gap-4">
          <div className="bg-slate-800 p-6 rounded-lg border border-slate-700">
            <div className="text-slate-400 text-sm mb-2">Total Events</div>
            <div className="text-3xl font-bold text-teal-400">{data.summary.total_events.toLocaleString()}</div>
          </div>

          <div className="bg-slate-800 p-6 rounded-lg border border-slate-700">
            <div className="text-slate-400 text-sm mb-2">Total Fatalities</div>
            <div className="text-3xl font-bold text-red-400">{data.summary.total_fatalities.toLocaleString()}</div>
          </div>

          <div className="bg-slate-800 p-6 rounded-lg border border-slate-700">
            <div className="text-slate-400 text-sm mb-2">Avg Climate Risk</div>
            <div className="text-3xl font-bold text-amber-400">{(data.summary.avg_climate_risk ?? 0).toFixed(1)}</div>
          </div>

          <div className="bg-slate-800 p-6 rounded-lg border border-slate-700">
            <div className="text-slate-400 text-sm mb-2">Avg Conflict Risk</div>
            <div className="text-3xl font-bold text-orange-400">{(data.summary.avg_conflict_proneness ?? 0).toFixed(1)}</div>
          </div>

          <div className="bg-slate-800 p-6 rounded-lg border border-slate-700">
            <div className="text-slate-400 text-sm mb-2">Regions Monitored</div>
            <div className="text-3xl font-bold text-blue-400">{data.summary.total_regions}</div>
          </div>
        </div>

        {/* âœ… FIXED: Monthly Conflict Trend - Using real data */}
        <div className="bg-slate-800 rounded-lg p-6 border border-slate-700">
          <h2 className="text-xl font-bold text-white mb-4">ðŸ“ˆ Monthly Conflict Trend</h2>
          {monthlyTrend.length === 0 ? (
            <div className="text-slate-400 text-center py-8">No monthly trend data available</div>
          ) : (
            <ResponsiveContainer width="100%" height={400}>
              <LineChart data={monthlyTrend}>
                <CartesianGrid strokeDasharray="3 3" stroke="#374151" />
                <XAxis dataKey="month" stroke="#9ca3af" />
                <YAxis stroke="#9ca3af" />
                <Tooltip
                  contentStyle={{ backgroundColor: '#1e293b', border: '1px solid #475569' }}
                  labelStyle={{ color: '#e2e8f0' }}
                />
                <Legend />
                <Line type="monotone" dataKey="events" stroke="#06b6d4" strokeWidth={2} name="Events" />
                <Line type="monotone" dataKey="fatalities" stroke="#ef4444" strokeWidth={2} name="Fatalities" />
              </LineChart>
            </ResponsiveContainer>
          )}
        </div>

        {/* Risk Distribution - Climate vs Conflict */}
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
          {/* Climate Risk Distribution */}
          <div className="bg-slate-800 p-6 rounded-lg border border-slate-700">
            <h2 className="text-xl font-bold text-white mb-4">ðŸŒ¡ï¸ Climate Risk Distribution</h2>
            <ResponsiveContainer width="100%" height={300}>
              <PieChart>
                <Pie
                  data={climateChartData}
                  cx="50%"
                  cy="50%"
                  innerRadius={60}
                  outerRadius={100}
                  paddingAngle={2}
                  dataKey="value"
                  label={({ name, value }) => `${name}: ${value}`}
                >
                  {climateChartData.map((entry, index) => (
                    <Cell key={`cell-${index}`} fill={CLIMATE_COLORS[entry.name as keyof typeof CLIMATE_COLORS] || '#6b7280'} />
                  ))}
                </Pie>
                <Tooltip contentStyle={{ backgroundColor: '#1e293b', border: '1px solid #475569' }} />
              </PieChart>
            </ResponsiveContainer>
            <div className="mt-4 space-y-2">
              {climateChartData.map((item) => (
                <div key={item.name} className="flex items-center justify-between text-sm">
                  <div className="flex items-center gap-2">
                    <div
                      className="w-3 h-3 rounded-full"
                      style={{ backgroundColor: CLIMATE_COLORS[item.name as keyof typeof CLIMATE_COLORS] }}
                    />
                    <span className="text-slate-300">{item.name}</span>
                  </div>
                  <span className="font-bold text-white">{item.value}</span>
                </div>
              ))}
            </div>
          </div>

          {/* Conflict Risk Distribution */}
          <div className="bg-slate-800 p-6 rounded-lg border border-slate-700">
            <h2 className="text-xl font-bold text-white mb-4">âš”ï¸ Conflict Risk Distribution</h2>
            <ResponsiveContainer width="100%" height={300}>
              <PieChart>
                <Pie
                  data={conflictChartData}
                  cx="50%"
                  cy="50%"
                  innerRadius={60}
                  outerRadius={100}
                  paddingAngle={2}
                  dataKey="value"
                  label={({ name, value }) => `${name}: ${value}`}
                >
                  {conflictChartData.map((entry, index) => (
                    <Cell key={`cell-${index}`} fill={CONFLICT_COLORS[entry.name as keyof typeof CONFLICT_COLORS] || '#6b7280'} />
                  ))}
                </Pie>
                <Tooltip contentStyle={{ backgroundColor: '#1e293b', border: '1px solid #475569' }} />
              </PieChart>
            </ResponsiveContainer>
            <div className="mt-4 space-y-2">
              {conflictChartData.map((item) => (
                <div key={item.name} className="flex items-center justify-between text-sm">
                  <div className="flex items-center gap-2">
                    <div
                      className="w-3 h-3 rounded-full"
                      style={{ backgroundColor: CONFLICT_COLORS[item.name as keyof typeof CONFLICT_COLORS] }}
                    />
                    <span className="text-slate-300">{item.name}</span>
                  </div>
                  <span className="font-bold text-white">{item.value}</span>
                </div>
              ))}
            </div>
          </div>
        </div>

        {/* Top 10 High-Risk Regions */}
        <div className="bg-slate-800 p-6 rounded-lg border border-slate-700">
          <h2 className="text-xl font-bold text-white mb-4">ðŸŽ¯ Top 10 High-Risk Regions</h2>
          <div className="overflow-x-auto">
            <table className="w-full text-sm">
              <thead className="bg-slate-900">
                <tr>
                  <th className="p-2 text-left text-slate-300">#</th>
                  <th className="p-2 text-left text-slate-300">Region</th>
                  <th className="p-2 text-center text-slate-300">Climate Risk</th>
                  <th className="p-2 text-center text-slate-300">Conflict Risk</th>
                  <th className="p-2 text-center text-slate-300">Events</th>
                  <th className="p-2 text-center text-slate-300">Deaths</th>
                </tr>
              </thead>
              <tbody>
                {data.top_regions.map((region, index) => (
                  <tr key={index} className="border-t border-slate-700 hover:bg-slate-750">
                    <td className="p-2 text-slate-400">{index + 1}</td>
                    <td className="p-2 text-white font-medium">{region.region || 'N/A'}</td>
                    <td className="p-2 text-center">
                      <span className="text-amber-400 font-bold">
                        {(region.climate_risk_score ?? 0).toFixed(2)}
                      </span>
                      <br />
                      <span
                        className="px-2 py-1 rounded-full text-xs font-bold"
                        style={{
                          backgroundColor: (CLIMATE_COLORS[region.cdi_category as keyof typeof CLIMATE_COLORS] || '#6b7280') + '33',
                          color: CLIMATE_COLORS[region.cdi_category as keyof typeof CLIMATE_COLORS] || '#6b7280'
                        }}
                      >
                        {region.cdi_category || 'N/A'}
                      </span>
                    </td>
                    <td className="p-2 text-center">
                      <span className="text-red-400 font-bold">
                        {(region.political_risk_score ?? 0).toFixed(2)}
                      </span>
                      <br />
                      <span
                        className="px-2 py-1 rounded-full text-xs font-bold"
                        style={{
                          backgroundColor: (CONFLICT_COLORS[region.risk_category as keyof typeof CONFLICT_COLORS] || '#6b7280') + '33',
                          color: CONFLICT_COLORS[region.risk_category as keyof typeof CONFLICT_COLORS] || '#6b7280'
                        }}
                      >
                        {region.risk_category || 'N/A'}
                      </span>
                    </td>
                    <td className="p-2 text-center text-teal-400">{region.events_6m ?? 0}</td>
                    <td className="p-2 text-center text-red-400">{region.fatalities_6m ?? 0}</td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        </div>

        {/* Regional Comparison Bar Chart */}
        <div className="bg-slate-800 rounded-lg p-6 border border-slate-700">
          <h2 className="text-xl font-bold text-white mb-4">ðŸ—ºï¸ Regional Climate vs Conflict Risk</h2>
          <ResponsiveContainer width="100%" height={400}>
            <BarChart data={data.regional_data}>
              <CartesianGrid strokeDasharray="3 3" stroke="#374151" />
              <XAxis
                dataKey="region"
                angle={-45}
                textAnchor="end"
                height={120}
                stroke="#9ca3af"
                interval={0}
              />
              <YAxis stroke="#9ca3af" />
              <Tooltip
                contentStyle={{ backgroundColor: '#1e293b', border: '1px solid #475569' }}
                labelStyle={{ color: '#e2e8f0' }}
              />
              <Legend />
              <Bar dataKey="climate_risk_score" fill="#f59e0b" name="Climate Risk" />
              <Bar dataKey="political_risk_score" fill="#ef4444" name="Conflict Risk" />
            </BarChart>
          </ResponsiveContainer>
        </div>
      </div>
    </Layout>
  )
}

### ./frontend/src/app/dashboard/page.tsx ###
'use client'

import React, { useState, useEffect } from 'react'
import Header from '@/components/dashboard/Header'
import Sidebar from '@/components/dashboard/Sidebar'
import MainMap from '@/components/dashboard/MainMap'
import RightPanel from '@/components/dashboard/RightPanel'

export default function DashboardPage() {
  const [selectedRegion, setSelectedRegion] = useState('All Regions')
  const [selectedDistrict, setSelectedDistrict] = useState('All Districts')
  const [selectedDate, setSelectedDate] = useState('2025-10-01')
  const [selectedIndicator, setSelectedIndicator] = useState('conflict-risk')

  return (
    <div className="flex h-screen bg-white text-gray-900" style={{ fontFamily: "'Inter', 'Roboto', sans-serif" }}>
      {/* Sidebar */}
      <Sidebar 
        selectedIndicator={selectedIndicator}
        onSelectIndicator={setSelectedIndicator}
      />

      {/* Main Content */}
      <div className="flex-1 flex flex-col overflow-hidden">
        {/* Header */}
        <Header />

        {/* Filter Bar */}
        <div className="border-b border-gray-200 bg-white px-6 py-4">
          <p className="text-xs text-gray-600 mb-4">
            Filter the map to visualize climate and conflict risks in Sudan by region and district.
          </p>
          <div className="flex gap-4">
            <select 
              value={selectedRegion}
              onChange={(e) => setSelectedRegion(e.target.value)}
              className="bg-white border border-gray-300 px-3 py-2 text-xs text-gray-900 rounded"
            >
              <option>All Regions</option>
              <option>Khartoum</option>
              <option>White Nile</option>
              <option>Blue Nile</option>
              <option>Gezira</option>
              <option>Kassala</option>
              <option>Red Sea</option>
              <option>North Darfur</option>
              <option>South Darfur</option>
              <option>West Darfur</option>
              <option>North Kordofan</option>
              <option>South Kordofan</option>
              <option>Sennar</option>
            </select>

            <select 
              value={selectedDistrict}
              onChange={(e) => setSelectedDistrict(e.target.value)}
              className="bg-white border border-gray-300 px-3 py-2 text-xs text-gray-900 rounded"
            >
              <option>All Districts</option>
              <option>Khartoum District</option>
              <option>Omdurman</option>
              <option>Bahri</option>
            </select>

            <input 
              type="date" 
              value={selectedDate}
              onChange={(e) => setSelectedDate(e.target.value)}
              className="bg-white border border-gray-300 px-3 py-2 text-xs text-gray-900 rounded"
            />
          </div>
        </div>

        {/* Content Area */}
        <div className="flex-1 overflow-y-auto flex gap-6 p-6">
          {/* Map Section */}
          <MainMap indicator={selectedIndicator} />

          {/* Right Panel - Now includes Goldstein */}
          <RightPanel />
        </div>
      </div>
    </div>
  )
}

### ./frontend/src/app/globals.css ###
@tailwind base;
@tailwind components;
@tailwind utilities;

/* ========================================
   SUDAN CRAM DESIGN SYSTEM
   Brand: #F37420 (Orange/Conflict) & #049787 (Teal/Climate)
======================================== */

:root {
  /* Light theme (default) */
  --background: #ffffff;
  --foreground: #111827;
  --surface: #f9fafb;
  --border: #d1d5db;
  --border-thickness: 1px;

  /* Brand colors */
  --brand-orange: #F37420;
  --brand-teal: #049787;

  /* Risk colors */
  --color-conflict: #F37420;
  --color-climate: #049787;
  --color-low: #22c55e;
  --color-medium: #fbbf24;
  --color-high: #F37420;
  --color-severe: #dc2626;
}

/* ========================================
   TYPOGRAPHY
======================================== */

body {
  background: var(--background);
  color: var(--foreground);
  line-height: 1.6;
  font-family: var(--font-inter), Inter, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
}

h1, h2, h3, h4, h5, h6 {
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

p {
  margin: 0.5rem 0;
}

a {
  color: var(--brand-orange);
  text-decoration: none;
  font-weight: 500;
}

a:hover {
  opacity: 0.8;
}

/* ========================================
   FORMS
======================================== */

input,
select,
textarea {
  background: var(--surface);
  color: var(--foreground);
  border: var(--border-thickness) solid var(--border);
  padding: 10px 12px;
  font-family: inherit;
  font-weight: 400;
}

input:focus,
select:focus,
textarea:focus {
  outline: none;
  border-color: var(--brand-orange);
  box-shadow: 0 0 0 2px rgba(243, 116, 32, 0.2);
}

input::placeholder,
textarea::placeholder {
  color: #9ca3af;
  opacity: 1;
}

/* ========================================
   TABLES
======================================== */

table {
  width: 100%;
  border-collapse: collapse;
  border: var(--border-thickness) solid var(--border);
}

th,
td {
  border: var(--border-thickness) solid var(--border);
  padding: 12px;
  text-align: left;
  font-weight: 500;
}

th {
  background: var(--surface);
  text-transform: uppercase;
  font-size: 0.75rem;
  letter-spacing: 0.05em;
  font-weight: 700;
}

tr:nth-child(even) {
  background: var(--surface);
}

/* ========================================
   UTILITY CLASSES
======================================== */

.text-uppercase {
  text-transform: uppercase;
  letter-spacing: 0.05em;
}

.font-mono {
  font-family: 'Courier New', monospace;
}

.text-conflict {
  color: var(--brand-orange);
}

.text-climate {
  color: var(--brand-teal);
}

.bg-conflict {
  background-color: var(--brand-orange);
}

.bg-climate {
  background-color: var(--brand-teal);
}

button {
  font-family: inherit;
}

/* ========================================
   LEAFLET MAP TOOLTIP STYLING - ADDED
======================================== */

.custom-tooltip {
  background-color: rgba(255, 255, 255, 0.98) !important;
  border: 1px solid #d1d5db !important;
  border-radius: 0 !important;
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15) !important;
  padding: 0 !important;
}

.custom-tooltip::before {
  border-top-color: #ffffff !important;
}

.leaflet-tooltip {
  font-family: Inter, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif !important;
}

### ./frontend/src/app/layout.tsx ###
import type { Metadata } from 'next'
import { Inter } from 'next/font/google'
import { ClerkProvider } from '@clerk/nextjs'
import './globals.css'
import 'leaflet/dist/leaflet.css'
import Script from 'next/script'

const inter = Inter({
  subsets: ['latin'],
  weight: ['300', '400', '500', '600', '700', '800'],
  variable: '--font-inter'
})

export const metadata: Metadata = {
  title: 'Sudan CRAM - Climate & Conflict Risk',
  description: 'Sudan Climate & Conflict Risk Assessment Monitor',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <ClerkProvider>
      <html lang="en" className={inter.variable}>
        <head>
          {/* Font Awesome CDN */}
          <Script
            src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/js/all.min.js"
            strategy="beforeInteractive"
            crossOrigin="anonymous"
          />
        </head>
        <body className={inter.className}>{children}</body>
      </html>
    </ClerkProvider>
  )
}

### ./frontend/src/app/map/components/RiskLegend.tsx ###
export function RiskLegend() {
  const categories = [
    { label: 'VERY HIGH', color: '#dc2626', range: '9-10' },
    { label: 'HIGH', color: '#ea580c', range: '7-8' },
    { label: 'MODERATE', color: '#ca8a04', range: '5-6' },
    { label: 'LOW', color: '#16a34a', range: '3-4' },
    { label: 'VERY LOW', color: '#64748b', range: '0-2' }
  ]

  return (
    <div className="bg-slate-800 rounded-lg p-4 border border-slate-700">
      <h3 className="text-white font-semibold mb-3">Risk Level Legend</h3>
      <div className="space-y-2">
        {categories.map((cat) => (
          <div key={cat.label} className="flex items-center gap-3">
            <div
              className="w-6 h-6 rounded-full border-2 border-white shadow"
              style={{ backgroundColor: cat.color }}
            />
            <div className="flex-1">
              <p className="text-white text-sm font-medium">{cat.label}</p>
              <p className="text-slate-400 text-xs">Score: {cat.range}</p>
            </div>
          </div>
        ))}
      </div>
    </div>
  )
}

### ./frontend/src/app/map/components/StateStats.tsx ###
import { StateRiskData } from '../hooks/useMapData'

interface StateStatsProps {
  states: StateRiskData[]
}

export function StateStats({ states }: StateStatsProps) {
  const highRiskStates = states.filter(s => s.cp_score >= 7).length
  const totalIncidents = states.reduce((sum, s) => sum + s.incidents, 0)
  const avgRisk = (states.reduce((sum, s) => sum + s.cp_score, 0) / states.length).toFixed(1)

  const topRiskStates = [...states]
    .sort((a, b) => b.cp_score - a.cp_score)
    .slice(0, 5)

  return (
    <div className="space-y-6">
      {/* Summary Stats */}
      <div className="grid grid-cols-3 gap-4">
        <div className="bg-slate-800 rounded-lg p-4 border border-slate-700">
          <p className="text-slate-400 text-sm mb-1">High Risk States</p>
          <p className="text-3xl font-bold text-red-400">{highRiskStates}</p>
        </div>
        <div className="bg-slate-800 rounded-lg p-4 border border-slate-700">
          <p className="text-slate-400 text-sm mb-1">Total Incidents</p>
          <p className="text-3xl font-bold text-orange-400">{totalIncidents}</p>
        </div>
        <div className="bg-slate-800 rounded-lg p-4 border border-slate-700">
          <p className="text-slate-400 text-sm mb-1">Avg Risk Score</p>
          <p className="text-3xl font-bold text-yellow-400">{avgRisk}</p>
        </div>
      </div>

      {/* Top Risk States */}
      <div className="bg-slate-800 rounded-lg p-4 border border-slate-700">
        <h3 className="text-white font-semibold mb-3">Highest Risk States</h3>
        <div className="space-y-2">
          {topRiskStates.map((state, idx) => (
            <div key={state.name} className="flex items-center gap-3">
              <div className="w-8 h-8 rounded-full bg-slate-700 flex items-center justify-center text-white text-sm font-bold">
                {idx + 1}
              </div>
              <div className="flex-1">
                <p className="text-white font-medium">{state.name}</p>
                <p className="text-slate-400 text-xs">{state.incidents} incidents</p>
              </div>
              <div className="text-right">
                <p className="text-lg font-bold text-red-400">{state.cp_score}</p>
                <p className="text-xs text-slate-400">{state.cp_category}</p>
              </div>
            </div>
          ))}
        </div>
      </div>
    </div>
  )
}

### ./frontend/src/app/map/components/SudanMap.tsx ###
'use client'

import React, { useEffect, useState } from 'react'
import dynamic from 'next/dynamic'
import { StateRiskData } from '../hooks/useMapData'

// Dynamically import Leaflet components (client-side only)
const MapContainer = dynamic(
  () => import('react-leaflet').then((mod) => mod.MapContainer),
  { ssr: false }
)
const TileLayer = dynamic(
  () => import('react-leaflet').then((mod) => mod.TileLayer),
  { ssr: false }
)
const GeoJSON = dynamic(
  () => import('react-leaflet').then((mod) => mod.GeoJSON),
  { ssr: false }
)
const Marker = dynamic(
  () => import('react-leaflet').then((mod) => mod.Marker),
  { ssr: false }
)
const Popup = dynamic(
  () => import('react-leaflet').then((mod) => mod.Popup),
  { ssr: false }
)

interface SudanMapProps {
  states: StateRiskData[]
}

// Sudan state coordinates (capitals)
const stateCoordinates: Record<string, [number, number]> = {
  'Khartoum': [15.5007, 32.5599],
  'North Darfur': [13.3162, 24.8802],
  'South Darfur': [11.3512, 24.9323],
  'West Darfur': [12.8533, 22.9217],
  'Central Darfur': [12.8533, 24.4700],
  'East Darfur': [11.7833, 27.0167],
  'Blue Nile': [11.4500, 34.3667],
  'White Nile': [13.1833, 32.7333],
  'North Kordofan': [13.1833, 30.2167],
  'South Kordofan': [11.2000, 29.4167],
  'West Kordofan': [11.1500, 27.9667],
  'Kassala': [15.4500, 36.4000],
  'Gedaref': [14.0333, 35.3833],
  'Sennar': [13.5667, 33.6000],
  'Red Sea': [18.4333, 38.2000],
  'River Nile': [17.7000, 33.9667],
  'Northern': [19.5667, 30.4167],
  'Gezira': [14.4000, 33.5000],
  'Abyei PCA': [9.6000, 28.4000]
}

// Get color based on risk score
const getRiskColor = (score: number): string => {
  if (score >= 9) return '#dc2626' // red-600
  if (score >= 7) return '#ea580c' // orange-600
  if (score >= 5) return '#ca8a04' // yellow-600
  if (score >= 3) return '#16a34a' // green-600
  return '#64748b' // slate-500
}

export function SudanMap({ states }: SudanMapProps) {
  const [mounted, setMounted] = useState(false)

  useEffect(() => {
    setMounted(true)
  }, [])

  if (!mounted) {
    return (
      <div className="w-full h-[600px] bg-slate-800 rounded-lg flex items-center justify-center">
        <p className="text-slate-400">Loading map...</p>
      </div>
    )
  }

  return (
    <div className="w-full h-[600px] rounded-lg overflow-hidden border border-slate-700">
      <MapContainer
        center={[15.0, 30.0]}
        zoom={6}
        style={{ height: '100%', width: '100%' }}
        className="z-0"
      >
        <TileLayer
          url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
          attribution='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>'
        />

        {/* State Markers */}
        {states.map((state) => {
          const coords = stateCoordinates[state.name]
          if (!coords) return null

          const color = getRiskColor(state.cp_score)

          // Create custom icon
          const iconHtml = `
            <div style="
              background-color: ${color};
              width: 30px;
              height: 30px;
              border-radius: 50%;
              border: 3px solid white;
              box-shadow: 0 2px 8px rgba(0,0,0,0.3);
              display: flex;
              align-items: center;
              justify-content: center;
              color: white;
              font-weight: bold;
              font-size: 12px;
            ">
              ${state.cp_score}
            </div>
          `

          return (
            <Marker
              key={state.name}
              position={coords}
              icon={
                typeof window !== 'undefined' && window.L
                  ? new window.L.DivIcon({
                      html: iconHtml,
                      className: 'custom-marker',
                      iconSize: [30, 30],
                      iconAnchor: [15, 15]
                    })
                  : undefined
              }
            >
              <Popup>
                <div className="p-2 min-w-[200px]">
                  <h3 className="font-bold text-lg mb-2">{state.name}</h3>
                  <div className="space-y-1 text-sm">
                    <div className="flex justify-between">
                      <span className="text-slate-600">Risk Score:</span>
                      <span className="font-semibold" style={{ color }}>
                        {state.cp_score} ({state.cp_category})
                      </span>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-slate-600">Incidents:</span>
                      <span className="font-semibold">{state.incidents}</span>
                    </div>
                    {state.political_risk !== null && (
                      <div className="flex justify-between">
                        <span className="text-slate-600">Political Risk:</span>
                        <span className="font-semibold">{state.political_risk.toFixed(2)}</span>
                      </div>
                    )}
                    {state.climate_risk !== null && (
                      <div className="flex justify-between">
                        <span className="text-slate-600">Climate Risk:</span>
                        <span className="font-semibold">{state.climate_risk.toFixed(2)}</span>
                      </div>
                    )}
                  </div>
                </div>
              </Popup>
            </Marker>
          )
        })}
      </MapContainer>
    </div>
  )
}

### ./frontend/src/app/map/hooks/useMapData.ts ###
import { useEffect, useState } from 'react'

export interface StateRiskData {
  name: string
  cp_score: number
  cp_category: string
  incidents: number
  political_risk: number | null
  climate_risk: number | null
}

export function useMapData() {
  const [states, setStates] = useState<StateRiskData[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    const fetchData = async () => {
      try {
        // Fetch conflict proneness data
        const cpResponse = await fetch(`${process.env.NEXT_PUBLIC_BACKEND_URL || "http://localhost:8000"}/api/conflict-proneness`)
        const cpData = await cpResponse.json()

        // Fetch combined risk data
        const riskResponse = await fetch(`${process.env.NEXT_PUBLIC_BACKEND_URL || "http://localhost:8000"}/api/combined-risk`)
        const riskData = await riskResponse.json()

        // Merge data by state name
        const mergedData = cpData.data.map((cp: any) => {
          const risk = riskData.data.find((r: any) => r.ADM1_NAME === cp.ADM1_NAME)
          return {
            name: cp.ADM1_NAME,
            cp_score: cp.cp_score || 0,
            cp_category: cp.cp_category || 'UNKNOWN',
            incidents: cp.incidents || 0,
            political_risk: risk?.political_risk || null,
            climate_risk: risk?.climate_risk || null
          }
        })

        setStates(mergedData)
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to fetch map data')
      } finally {
        setLoading(false)
      }
    }

    fetchData()
  }, [])

  return { states, loading, error }
}

### ./frontend/src/app/map/page.tsx ###
'use client'

import React, { useEffect, useState } from 'react'
import dynamic from 'next/dynamic'
import { Layout } from '@/components/layout/Layout'

// Dynamically import map component (client-side only)
const MapComponent = dynamic(
  () => import('@/components/map/SudanMap'),
  { 
    ssr: false,
    loading: () => (
      <div className="flex items-center justify-center h-full">
        <div className="text-white">Loading map...</div>
      </div>
    )
  }
)

export default function MapPage() {
  const [isBackendAvailable, setIsBackendAvailable] = useState(false)
  const [checking, setChecking] = useState(true)
  const [selectedIndicator, setSelectedIndicator] = useState('conflict_proneness')

  useEffect(() => {
    // Check if backend is available
    const checkBackend = async () => {
      try {
        const response = await fetch(`${process.env.NEXT_PUBLIC_BACKEND_URL || "http://localhost:8000"}/api/conflict-proneness`)
        if (response.ok) {
          setIsBackendAvailable(true)
        }
      } catch (error) {
        console.log('Backend not available yet')
        setIsBackendAvailable(false)
      } finally {
        setChecking(false)
      }
    }

    checkBackend()
  }, [])

  return (
    <Layout>
      <div className="h-full flex flex-col">
        {/* Page Header */}
        <div className="mb-4 flex items-center justify-between">
          <div>
            <h1 className="text-4xl font-bold text-white mb-2">Interactive Risk Map</h1>
            <p className="text-lg text-slate-400">Geographic visualization of conflict risk across Sudan</p>
          </div>
          
          {/* Indicator Selector */}
          <div className="flex items-center gap-3">
            <label className="text-sm font-medium text-slate-300">Indicator:</label>
            <select 
              value={selectedIndicator}
              onChange={(e) => setSelectedIndicator(e.target.value)}
              className="px-4 py-2 bg-slate-800 text-white border border-slate-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-teal-500"
            >
              <option value="conflict_proneness">Conflict Proneness</option>
              <option value="drought_severity" disabled>Drought Severity (Coming Soon)</option>
              <option value="food_insecurity" disabled>Food Insecurity (Coming Soon)</option>
            </select>
          </div>
        </div>

        {/* Backend Status Warning */}
        {!isBackendAvailable && !checking && (
          <div className="mb-4 p-4 bg-yellow-900/20 border border-yellow-700/50 rounded-lg">
            <div className="flex items-start gap-3">
              <span className="text-2xl">âš ï¸</span>
              <div>
                <h3 className="text-yellow-400 font-semibold mb-1">Backend API Not Available</h3>
                <p className="text-yellow-200 text-sm">
                  Start the backend with: <code className="bg-slate-900 px-2 py-1 rounded text-sm text-green-400">uvicorn app.main:app --reload --port 8000</code>
                </p>
              </div>
            </div>
          </div>
        )}

        {/* Map Container */}
        <div className="flex-1 bg-slate-800 rounded-xl border border-slate-700 overflow-hidden">
          <MapComponent 
            backendAvailable={isBackendAvailable} 
            indicator={selectedIndicator}
          />
        </div>
      </div>
    </Layout>
  )
}

### ./frontend/src/app/page.tsx ###
import Link from 'next/link'

export default function LandingPage() {
  return (
    <div className="min-h-screen bg-white">
      {/* Header */}
      <header className="border-b">
        <div className="container mx-auto px-4 py-4 flex justify-between items-center">
          <h1 className="text-2xl font-bold text-gray-900">Sudan CRAM</h1>
          <div className="flex gap-4">
            <Link href="/sign-in" className="text-gray-600 hover:text-gray-900">
              Sign In
            </Link>
            <Link 
              href="/sign-up" 
              className="bg-orange-600 text-white px-4 py-2 rounded hover:bg-orange-700"
            >
              Get Started
            </Link>
          </div>
        </div>
      </header>

      {/* Hero Section */}
	  <section className="container mx-auto px-4 py-20">
	    <div className="max-w-4xl mx-auto text-center">
		  <h1 className="text-5xl font-bold text-gray-900 mb-6">
		    Real-Time Conflict Monitoring for Sudan
		  </h1>
		  <p className="text-xl text-gray-600 mb-8">
			Get early warnings on conflict risks and climate threats to protect your people and make data-driven decisions faster.
		  </p>
		  <div className="flex gap-4 justify-center flex-wrap">
		    <Link 
			  href="/sign-up"
			  className="bg-orange-600 text-white px-8 py-3 rounded-lg text-lg hover:bg-orange-700"
		    >
			  Start Free Trial
		    </Link>
		  </div>
	    </div>
	  </section>

      {/* Features Section */}
      <section className="bg-gray-50 py-20">
        <div className="container mx-auto px-4">
          <h2 className="text-3xl font-bold text-center mb-12">Key Features</h2>
          <div className="grid md:grid-cols-3 gap-8 max-w-5xl mx-auto">
            <div className="bg-white p-6 rounded-lg shadow">
              <div className="text-3xl mb-4">âš¡</div>
              <h3 className="text-xl font-bold mb-3">Real-Time Updates</h3>
              <p className="text-gray-600">
                15-minute update cycles from GDELT's 100,000+ global news sources
              </p>
            </div>
            <div className="bg-white p-6 rounded-lg shadow">
              <div className="text-3xl mb-4">ðŸŒ</div>
              <h3 className="text-xl font-bold mb-3">Climate Correlation</h3>
              <p className="text-gray-600">
                Analyze drought patterns and their impact on conflict risk
              </p>
            </div>
            <div className="bg-white p-6 rounded-lg shadow">
              <div className="text-3xl mb-4">ðŸ””</div>
              <h3 className="text-xl font-bold mb-3">Custom Alerts</h3>
              <p className="text-gray-600">
                SMS and email notifications for your specific locations
              </p>
            </div>
          </div>
        </div>
      </section>

      {/* Social Proof */}
      <section className="py-20">
        <div className="container mx-auto px-4">
          <div className="max-w-4xl mx-auto text-center">
            <h2 className="text-3xl font-bold mb-8">Built for Humanitarian Organizations</h2>
            <div className="bg-orange-50 border-l-4 border-orange-600 p-6 mb-8">
              <p className="text-lg text-gray-700 italic">
                "Sudan CRAM detected the Wad Madani escalation 72 hours before it appeared in mainstream media. 
                This early warning gave us critical time to adjust field operations."
              </p>
              <p className="text-sm text-gray-600 mt-4">â€” Humanitarian Partner (Beta Tester)</p>
            </div>
            <div className="grid grid-cols-3 gap-8 mt-12">
              <div>
                <p className="text-4xl font-bold text-orange-600">15min</p>
                <p className="text-gray-600 mt-2">Update Cycle</p>
              </div>
              <div>
                <p className="text-4xl font-bold text-orange-600">100K+</p>
                <p className="text-gray-600 mt-2">News Sources</p>
              </div>
              <div>
                <p className="text-4xl font-bold text-orange-600">24/7</p>
                <p className="text-gray-600 mt-2">Monitoring</p>
              </div>
            </div>
          </div>
        </div>
      </section>

      {/* Pricing */}
      <section className="bg-gray-50 py-20">
        <div className="container mx-auto px-4">
          <h2 className="text-3xl font-bold text-center mb-12">Simple Pricing</h2>
          <div className="grid md:grid-cols-3 gap-8 max-w-5xl mx-auto">
            {/* Free Tier */}
            <div className="bg-white p-8 rounded-lg border">
              <h3 className="text-xl font-bold mb-2">Free</h3>
              <p className="text-gray-600 mb-4">Public Dashboard</p>
              <p className="text-3xl font-bold mb-6">$0<span className="text-sm text-gray-500">/month</span></p>
              <ul className="space-y-2 mb-6 text-sm">
                <li className="flex items-start">
                  <span className="text-green-600 mr-2">âœ“</span>
                  <span>View-only access</span>
                </li>
                <li className="flex items-start">
                  <span className="text-green-600 mr-2">âœ“</span>
                  <span>24-hour data delay</span>
                </li>
                <li className="flex items-start">
                  <span className="text-green-600 mr-2">âœ“</span>
                  <span>Basic conflict data</span>
                </li>
              </ul>
              <Link href="/dashboard" className="block text-center border border-gray-300 text-gray-700 px-6 py-2 rounded hover:bg-gray-50">
                View Dashboard
              </Link>
            </div>

            {/* Pro Tier */}
            <div className="bg-white p-8 rounded-lg border-2 border-orange-600 relative shadow-lg transform scale-105">
              <div className="absolute -top-4 left-1/2 transform -translate-x-1/2 bg-orange-600 text-white px-4 py-1 rounded-full text-sm">
                Popular
              </div>
              <h3 className="text-xl font-bold mb-2">Pro</h3>
              <p className="text-gray-600 mb-4">For Organizations</p>
              <p className="text-3xl font-bold mb-6">$299<span className="text-sm text-gray-500">/month</span></p>
              <ul className="space-y-2 mb-6 text-sm">
                <li className="flex items-start">
                  <span className="text-green-600 mr-2">âœ“</span>
                  <span>Real-time data access</span>
                </li>
                <li className="flex items-start">
                  <span className="text-green-600 mr-2">âœ“</span>
                  <span>API access</span>
                </li>
                <li className="flex items-start">
                  <span className="text-green-600 mr-2">âœ“</span>
                  <span>Custom alerts (SMS/Email)</span>
                </li>
                <li className="flex items-start">
                  <span className="text-green-600 mr-2">âœ“</span>
                  <span>5 monitored regions</span>
                </li>
                <li className="flex items-start">
                  <span className="text-green-600 mr-2">âœ“</span>
                  <span>Priority support</span>
                </li>
              </ul>
              <Link href="/sign-up" className="block text-center bg-orange-600 text-white px-6 py-2 rounded hover:bg-orange-700">
                Start Free Trial
              </Link>
            </div>

            {/* Enterprise Tier */}
            <div className="bg-white p-8 rounded-lg border">
              <h3 className="text-xl font-bold mb-2">Enterprise</h3>
              <p className="text-gray-600 mb-4">Custom Solution</p>
              <p className="text-3xl font-bold mb-6">Custom</p>
              <ul className="space-y-2 mb-6 text-sm">
                <li className="flex items-start">
                  <span className="text-green-600 mr-2">âœ“</span>
                  <span>White-label branding</span>
                </li>
                <li className="flex items-start">
                  <span className="text-green-600 mr-2">âœ“</span>
                  <span>Dedicated support</span>
                </li>
                <li className="flex items-start">
                  <span className="text-green-600 mr-2">âœ“</span>
                  <span>Custom integrations</span>
                </li>
                <li className="flex items-start">
                  <span className="text-green-600 mr-2">âœ“</span>
                  <span>Unlimited regions</span>
                </li>
                <li className="flex items-start">
                  <span className="text-green-600 mr-2">âœ“</span>
                  <span>SLA guarantee</span>
                </li>
              </ul>
              <a href="mailto:hello@sudancram.com" className="block text-center border border-gray-300 text-gray-700 px-6 py-2 rounded hover:bg-gray-50">
                Contact Sales
              </a>
            </div>
          </div>
        </div>
      </section>

      {/* CTA Section */}
      <section className="py-20">
        <div className="container mx-auto px-4">
          <div className="max-w-4xl mx-auto text-center bg-orange-600 text-white p-12 rounded-lg">
            <h2 className="text-3xl font-bold mb-4">Ready to Get Started?</h2>
            <p className="text-xl mb-8">Join humanitarian organizations monitoring Sudan with CRAM</p>
            <Link 
              href="/sign-up"
              className="inline-block bg-white text-orange-600 px-8 py-3 rounded-lg text-lg font-semibold hover:bg-gray-100"
            >
              Start Free Trial
            </Link>
          </div>
        </div>
      </section>

      {/* Footer */}
      <footer className="border-t py-8 bg-gray-50">
        <div className="container mx-auto px-4">
          <div className="flex flex-col md:flex-row justify-between items-center gap-4">
            <p className="text-gray-600 text-sm">Â© 2025 Sudan CRAM. All rights reserved.</p>
            <div className="flex gap-6">
              <a href="mailto:hello@sudancram.com" className="text-gray-600 hover:text-gray-900 text-sm">Contact</a>
              <Link href="/dashboard" className="text-gray-600 hover:text-gray-900 text-sm">Dashboard</Link>
            </div>
          </div>
        </div>
      </footer>
    </div>
  )
}

### ./frontend/src/app/regions/page.tsx ###
'use client'

import React, { useState, useEffect } from 'react'

interface Region {
  region: string
  climate_risk_score: number
  cdi_category: string
  political_risk_score: number
  risk_category: string
  bivariate_category: string
  events_6m?: number  
  fatalities_6m?: number  
  trend: string
}

interface RegionsData {
  regions: Region[]
  total_count: number
  risk_summary: {
    climate: Record<string, number>
    conflict: Record<string, number>
  }
}

const getClimateRiskColor = (category: string): string => {
  switch (category) {
    case 'EXTREME': return 'text-red-500'
    case 'ALERT': return 'text-orange-400'
    case 'WATCH': return 'text-yellow-400'
    case 'NORMAL': return 'text-green-400'
    default: return 'text-slate-400'
  }
}

const getConflictRiskColor = (category: string): string => {
  switch (category) {
    case 'EXTREME': return 'text-red-500'
    case 'VERY HIGH': return 'text-red-400'
    case 'HIGH': return 'text-orange-400'
    case 'MODERATE': return 'text-yellow-400'
    case 'LOW': return 'text-green-400'
    default: return 'text-slate-400'
  }
}

const getRiskBadgeColor = (category: string): string => {
  switch (category) {
    case 'EXTREME': return 'bg-red-500/20 border-red-500/50'
    case 'VERY HIGH': return 'bg-red-400/20 border-red-400/50'
    case 'ALERT': return 'bg-orange-400/20 border-orange-400/50'
    case 'HIGH': return 'bg-orange-400/20 border-orange-400/50'
    case 'WATCH': return 'bg-yellow-400/20 border-yellow-400/50'
    case 'MODERATE': return 'bg-yellow-400/20 border-yellow-400/50'
    case 'NORMAL': return 'bg-green-400/20 border-green-400/50'
    case 'LOW': return 'bg-green-400/20 border-green-400/50'
    default: return 'bg-slate-400/20 border-slate-400/50'
  }
}

const getTrendIcon = (trend: string): string => {
  switch (trend) {
    case 'rising': return 'â†‘'
    case 'falling': return 'â†“'
    case 'stable': return 'â†’'
    default: return 'â†’'
  }
}

const getTrendColor = (trend: string): string => {
  switch (trend) {
    case 'rising': return 'text-red-400'
    case 'falling': return 'text-green-400'
    case 'stable': return 'text-slate-400'
    default: return 'text-slate-400'
  }
}

export default function RegionsPage() {
  const [data, setData] = useState<RegionsData | null>(null)
  const [loading, setLoading] = useState(true)
  const [searchTerm, setSearchTerm] = useState('')
  const [filterDimension, setFilterDimension] = useState<'climate' | 'conflict'>('conflict')

  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await fetch(`${process.env.NEXT_PUBLIC_BACKEND_URL || "http://localhost:8000"}/api/regions`)
        const result = await response.json()
        setData(result)
      } catch (error) {
        console.error('Error fetching regions:', error)
      } finally {
        setLoading(false)
      }
    }

    fetchData()
  }, [])

  if (loading) {
    return (
      <div className="min-h-screen bg-slate-950 flex items-center justify-center">
        <div className="text-white text-xl">Loading regions...</div>
      </div>
    )
  }

  if (!data) {
    return (
      <div className="min-h-screen bg-slate-950 flex items-center justify-center">
        <div className="text-red-400 text-xl">Failed to load data</div>
      </div>
    )
  }

  // Filter and sort regions
  const filteredRegions = data.regions
    .filter(region => region.region.toLowerCase().includes(searchTerm.toLowerCase()))
    .sort((a, b) => {
      if (filterDimension === 'climate') {
        return (b.climate_risk_score || 0) - (a.climate_risk_score || 0)
      }
      return (b.political_risk_score || 0) - (a.political_risk_score || 0)
    })

  return (
    <div className="min-h-screen bg-slate-950 p-6">
      <div className="max-w-7xl mx-auto">
        {/* Header */}
        <div className="mb-8">
          <h1 className="text-4xl font-bold text-white mb-2 flex items-center gap-3">
            ðŸ—ºï¸ Bivariate Regions Overview
          </h1>
          <p className="text-slate-400">
            Monitoring {data.total_count} regions with climate + conflict analysis
          </p>
        </div>

        {/* Risk Summary Cards */}
        <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
          {/* Climate Risk Summary */}
          <div className="bg-slate-800 border border-slate-700 rounded-lg p-4">
            <h3 className="text-amber-400 font-bold mb-3">ðŸŒ¡ï¸ Climate Risk Levels</h3>
            <div className="grid grid-cols-2 gap-3">
              {Object.entries(data.risk_summary.climate).map(([level, count]) => (
                <div key={level} className={`${getRiskBadgeColor(level)} rounded-lg p-3`}>
                  <div className={`text-sm font-medium mb-1 ${getClimateRiskColor(level)}`}>{level}</div>
                  <div className="text-2xl font-bold text-white">{count}</div>
                </div>
              ))}
            </div>
          </div>

          {/* Conflict Risk Summary */}
          <div className="bg-slate-800 border border-slate-700 rounded-lg p-4">
            <h3 className="text-red-400 font-bold mb-3">âš”ï¸ Conflict Risk Levels</h3>
            <div className="grid grid-cols-2 gap-3">
              {Object.entries(data.risk_summary.conflict).map(([level, count]) => (
                <div key={level} className={`${getRiskBadgeColor(level)} rounded-lg p-3`}>
                  <div className={`text-sm font-medium mb-1 ${getConflictRiskColor(level)}`}>{level}</div>
                  <div className="text-2xl font-bold text-white">{count}</div>
                </div>
              ))}
            </div>
          </div>
        </div>

        {/* Search and Sort */}
        <div className="bg-slate-800 border border-slate-700 rounded-lg p-4 mb-6 flex flex-col md:flex-row gap-4">
          <div className="flex-1">
            <input
              type="text"
              placeholder="ðŸ” Search regions..."
              value={searchTerm}
              onChange={(e) => setSearchTerm(e.target.value)}
              className="w-full bg-slate-900 border border-slate-600 rounded-lg px-4 py-2 text-white placeholder-slate-400 focus:outline-none focus:border-teal-400"
            />
          </div>
          <div className="flex gap-2">
            <button
              onClick={() => setFilterDimension('climate')}
              className={`px-4 py-2 rounded-lg font-medium transition-all ${
                filterDimension === 'climate'
                  ? 'bg-amber-600 text-white'
                  : 'bg-slate-700 text-slate-300 hover:bg-slate-600'
              }`}
            >
              ðŸŒ¡ï¸ Sort by Climate
            </button>
            <button
              onClick={() => setFilterDimension('conflict')}
              className={`px-4 py-2 rounded-lg font-medium transition-all ${
                filterDimension === 'conflict'
                  ? 'bg-red-600 text-white'
                  : 'bg-slate-700 text-slate-300 hover:bg-slate-600'
              }`}
            >
              âš”ï¸ Sort by Conflict
            </button>
          </div>
        </div>

        {/* Results Count */}
        <div className="text-slate-400 mb-4">
          Showing {filteredRegions.length} of {data.total_count} regions
        </div>

        {/* Regions Grid */}
        <div className="grid grid-cols-1 gap-4">
          {filteredRegions.map((region, index) => (
            <div
              key={index}
              className="bg-slate-800 border border-slate-700 rounded-lg p-6 hover:border-teal-400 transition-all cursor-pointer"
            >
              <div className="flex items-start justify-between mb-4">
                <div className="flex-1">
                  <h3 className="text-xl font-bold text-white mb-2">
                    {region.region}
                  </h3>
                  <div className="text-xs text-slate-400 mb-3">
                    {region.bivariate_category?.replace(/_/g, ' ') || 'N/A'}
                  </div>
                  <div className="flex items-center gap-4 text-sm">
                    <span className="text-teal-400">
                      {(region.events_6m ?? 0).toLocaleString()} events
                    </span>
                    <span className="text-red-400">
                      {(region.fatalities_6m ?? 0).toLocaleString()} fatalities
                    </span>
                  </div>
                </div>
                <div className="flex flex-col items-end gap-2">
                  <div className={`text-sm ${getTrendColor(region.trend)}`}>
                    {getTrendIcon(region.trend)} {region.trend}
                  </div>
                </div>
              </div>

              {/* Bivariate Risk Display */}
              <div className="grid grid-cols-2 gap-4 mb-3">
                {/* Climate Risk */}
                <div className={`p-3 rounded-lg border ${getRiskBadgeColor(region.cdi_category)}`}>
                  <div className="text-xs text-slate-400 mb-1">Climate Risk</div>
                  <div className={`text-lg font-bold ${getClimateRiskColor(region.cdi_category)}`}>
                    {(region.climate_risk_score || 0).toFixed(1)}
                  </div>
                  <div className="text-xs font-medium text-white mt-1">
                    {region.cdi_category || 'N/A'}
                  </div>
                </div>

                {/* Conflict Risk */}
                <div className={`p-3 rounded-lg border ${getRiskBadgeColor(region.risk_category)}`}>
                  <div className="text-xs text-slate-400 mb-1">Conflict Risk</div>
                  <div className={`text-lg font-bold ${getConflictRiskColor(region.risk_category)}`}>
                    {(region.political_risk_score || 0).toFixed(1)}
                  </div>
                  <div className="text-xs font-medium text-white mt-1">
                    {region.risk_category || 'N/A'}
                  </div>
                </div>
              </div>
            </div>
          ))}
        </div>

        {/* No Results */}
        {filteredRegions.length === 0 && (
          <div className="text-center py-12">
            <div className="text-slate-400 text-lg">No regions found matching your criteria</div>
          </div>
        )}
      </div>
    </div>
  )
}

### ./frontend/src/app/reports/page.tsx ###
'use client'

import React, { useState } from 'react'
import ReactMarkdown from 'react-markdown'

interface BriefResponse {
  brief: string
  generated_at: string
  regions_analyzed: number
  total_events: number
  total_fatalities: number
}

export default function ReportsPage() {
  const [brief, setBrief] = useState<BriefResponse | null>(null)
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)

  const generateBrief = async () => {
    setLoading(true)
    setError(null)

    try {
      const response = await fetch(`${process.env.NEXT_PUBLIC_BACKEND_URL || "http://localhost:8000"}/api/generate-brief`, {
        method: 'POST',
      })

      if (!response.ok) {
        throw new Error('Failed to generate brief')
      }

      const data = await response.json()
      setBrief(data)
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Unknown error')
    } finally {
      setLoading(false)
    }
  }

  return (
    <div className="min-h-screen bg-slate-950 p-6">
      <div className="max-w-5xl mx-auto">
        {/* Header */}
        <div className="mb-8">
          <h1 className="text-4xl font-bold text-white mb-2 flex items-center gap-3">
            ðŸ“„ AI-Generated Reports
          </h1>
          <p className="text-slate-400">
            Automated conflict analysis briefs powered by Groq AI
          </p>
        </div>

        {/* Generate Button */}
        <div className="mb-6">
          <button
            onClick={generateBrief}
            disabled={loading}
            className={`px-6 py-3 rounded-lg font-medium transition-all ${
              loading
                ? 'bg-slate-700 text-slate-400 cursor-not-allowed'
                : 'bg-teal-500 text-white hover:bg-teal-600'
            }`}
          >
            {loading ? (
              <span className="flex items-center gap-2">
                <svg className="animate-spin h-5 w-5" viewBox="0 0 24 24">
                  <circle
                    className="opacity-25"
                    cx="12"
                    cy="12"
                    r="10"
                    stroke="currentColor"
                    strokeWidth="4"
                    fill="none"
                  />
                  <path
                    className="opacity-75"
                    fill="currentColor"
                    d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                  />
                </svg>
                Generating Brief...
              </span>
            ) : (
              'ðŸ¤– Generate New Brief'
            )}
          </button>
        </div>

        {/* Error Message */}
        {error && (
          <div className="bg-red-500/20 border border-red-500/50 rounded-lg p-4 mb-6">
            <p className="text-red-400">âŒ Error: {error}</p>
          </div>
        )}

        {/* Brief Display */}
        {brief && (
          <div className="space-y-6">
            {/* Stats Bar */}
            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
              <div className="bg-slate-800 border border-slate-700 rounded-lg p-4">
                <div className="text-slate-400 text-sm mb-1">Regions Analyzed</div>
                <div className="text-2xl font-bold text-white">{brief.regions_analyzed}</div>
              </div>
              <div className="bg-slate-800 border border-slate-700 rounded-lg p-4">
                <div className="text-slate-400 text-sm mb-1">Total Events</div>
                <div className="text-2xl font-bold text-teal-400">
                  {brief.total_events.toLocaleString()}
                </div>
              </div>
              <div className="bg-slate-800 border border-slate-700 rounded-lg p-4">
                <div className="text-slate-400 text-sm mb-1">Total Fatalities</div>
                <div className="text-2xl font-bold text-red-400">
                  {brief.total_fatalities.toLocaleString()}
                </div>
              </div>
            </div>

            {/* Brief Content */}
            <div className="bg-slate-800 border border-slate-700 rounded-lg p-8">
              <div className="prose prose-invert prose-slate max-w-none">
                <ReactMarkdown
                  components={{
                    h1: ({ children }) => (
                      <h1 className="text-3xl font-bold text-white mb-4">{children}</h1>
                    ),
                    h2: ({ children }) => (
                      <h2 className="text-2xl font-bold text-white mt-8 mb-4">{children}</h2>
                    ),
                    h3: ({ children }) => (
                      <h3 className="text-xl font-bold text-white mt-6 mb-3">{children}</h3>
                    ),
                    p: ({ children }) => (
                      <p className="text-slate-300 mb-4 leading-relaxed">{children}</p>
                    ),
                    ul: ({ children }) => (
                      <ul className="list-disc list-inside text-slate-300 mb-4 space-y-2">
                        {children}
                      </ul>
                    ),
                    li: ({ children }) => <li className="text-slate-300">{children}</li>,
                    strong: ({ children }) => (
                      <strong className="text-white font-semibold">{children}</strong>
                    ),
                    em: ({ children }) => (
                      <em className="text-slate-400 italic">{children}</em>
                    ),
                    hr: () => <hr className="border-slate-700 my-6" />,
                  }}
                >
                  {brief.brief}
                </ReactMarkdown>
              </div>

              {/* Timestamp */}
              <div className="mt-8 pt-6 border-t border-slate-700">
                <p className="text-slate-500 text-sm">
                  Generated: {new Date(brief.generated_at).toLocaleString()}
                </p>
              </div>
            </div>

            {/* Export Button */}
            <div className="flex gap-4">
              <button
                onClick={() => {
                  const blob = new Blob([brief.brief], { type: 'text/markdown' })
                  const url = URL.createObjectURL(blob)
                  const a = document.createElement('a')
                  a.href = url
                  a.download = `sudan-brief-${new Date().toISOString().split('T')[0]}.md`
                  a.click()
                }}
                className="px-4 py-2 bg-slate-700 text-white rounded-lg hover:bg-slate-600 transition-all"
              >
                ðŸ“¥ Export as Markdown
              </button>
            </div>
          </div>
        )}

        {/* Empty State */}
        {!brief && !loading && !error && (
          <div className="text-center py-16">
            <div className="text-6xl mb-4">ðŸ“„</div>
            <div className="text-slate-400 text-lg mb-2">
              No reports generated yet
            </div>
            <div className="text-slate-500 text-sm">
              Click "Generate New Brief" to create your first AI-powered report
            </div>
          </div>
        )}
      </div>
    </div>
  )
}

### ./frontend/src/app/sign-in/[[...sign-in]]/page.tsx ###
// frontend/src/app/sign-in/[[...sign-in]]/page.tsx
import { SignIn } from "@clerk/nextjs";

export default function Page() {
  return (
    <div className="flex min-h-screen items-center justify-center">
      <SignIn />
    </div>
  );
}

### ./frontend/src/app/sign-up/[[...sign-up]]/page.tsx ###
// frontend/src/app/sign-up/[[...sign-up]]/page.tsx
import { SignUp } from "@clerk/nextjs";

export default function Page() {
  return (
    <div className="flex min-h-screen items-center justify-center">
      <SignUp />
    </div>
  );
}

### ./frontend/src/components/Dashboard.tsx ###
import React, { useState, useEffect } from 'react';
import { BarChart, Bar, LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ResponsiveContainer, PieChart, Pie, Cell } from 'recharts';
import { AlertCircle, TrendingUp, MapPin, Users } from 'lucide-react';
import { conflictPronenessAPI } from '../services/api';

interface DashboardData {
  summary: {
    conflict_events: number;
    states_analyzed: number;
    risk_assessments: number;
    data_confidence: number;
  };
  quick_insights: {
    highest_risk_state: string;
    active_alerts: number;
    alert_breakdown: {
      high: number;
      very_high: number;
      extreme: number;
    };
    trend: {
      direction: string;
      percentage: number;
    };
  };
  risk_distribution: {
    climate: Record<string, number>;
    conflict: Record<string, number>;
  };
  metrics: {
    total_events: number;
    total_fatalities: number;
    avg_conflict_proneness: number;
    avg_climate_risk: number;
  };
}

const Dashboard: React.FC = () => {
  const [data, setData] = useState<DashboardData | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchDashboard = async () => {
      try {
        setLoading(true);
        const response = await conflictPronenessAPI.getDashboard();
        setData(response);
        setError(null);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Failed to load dashboard');
        console.error(err);
      } finally {
        setLoading(false);
      }
    };

    fetchDashboard();
  }, []);

  if (loading) {
    return <div className="flex items-center justify-center h-screen">Loading dashboard...</div>;
  }

  if (error) {
    return <div className="flex items-center justify-center h-screen text-red-600">Error: {error}</div>;
  }

  if (!data) {
    return <div className="flex items-center justify-center h-screen">No data available</div>;
  }

  const conflictData = Object.entries(data.risk_distribution.conflict).map(([name, value]) => ({
    name,
    value,
  }));

  const COLORS = ['#ef4444', '#f97316', '#eab308', '#22c55e', '#3b82f6'];

  return (
    <div className="w-full bg-gray-900 text-white p-8">
      <div className="max-w-7xl mx-auto">
        {/* Header */}
        <div className="mb-8">
          <h1 className="text-4xl font-bold mb-2">CRAM Dashboard</h1>
          <p className="text-gray-400">Conflict Risk Assessment & Monitoring System</p>
        </div>

        {/* Summary Cards */}
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6 mb-8">
          <div className="bg-gray-800 rounded-lg p-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-gray-400 text-sm">Conflict Events</p>
                <p className="text-3xl font-bold">{data.summary.conflict_events}</p>
              </div>
              <AlertCircle className="w-8 h-8 text-red-500" />
            </div>
          </div>

          <div className="bg-gray-800 rounded-lg p-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-gray-400 text-sm">States Analyzed</p>
                <p className="text-3xl font-bold">{data.summary.states_analyzed}</p>
              </div>
              <MapPin className="w-8 h-8 text-blue-500" />
            </div>
          </div>

          <div className="bg-gray-800 rounded-lg p-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-gray-400 text-sm">Active Alerts</p>
                <p className="text-3xl font-bold">{data.quick_insights.active_alerts}</p>
              </div>
              <AlertCircle className="w-8 h-8 text-orange-500" />
            </div>
          </div>

          <div className="bg-gray-800 rounded-lg p-6">
            <div className="flex items-center justify-between">
              <div>
                <p className="text-gray-400 text-sm">Data Confidence</p>
                <p className="text-3xl font-bold">{data.summary.data_confidence}%</p>
              </div>
              <TrendingUp className="w-8 h-8 text-green-500" />
            </div>
          </div>
        </div>

        {/* Risk Insights */}
        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-8">
          <div className="bg-gray-800 rounded-lg p-6">
            <h3 className="text-lg font-semibold mb-4">Highest Risk State</h3>
            <p className="text-2xl font-bold text-red-400">{data.quick_insights.highest_risk_state}</p>
            <p className="text-gray-400 mt-2">Requires immediate attention</p>
          </div>

          <div className="bg-gray-800 rounded-lg p-6">
            <h3 className="text-lg font-semibold mb-4">Alert Breakdown</h3>
            <div className="space-y-2">
              <p className="flex justify-between"><span className="text-gray-400">Extreme:</span> <span className="text-red-400 font-bold">{data.quick_insights.alert_breakdown.extreme}</span></p>
              <p className="flex justify-between"><span className="text-gray-400">Very High:</span> <span className="text-orange-400 font-bold">{data.quick_insights.alert_breakdown.very_high}</span></p>
              <p className="flex justify-between"><span className="text-gray-400">High:</span> <span className="text-yellow-400 font-bold">{data.quick_insights.alert_breakdown.high}</span></p>
            </div>
          </div>

          <div className="bg-gray-800 rounded-lg p-6">
            <h3 className="text-lg font-semibold mb-4">Trend</h3>
            <p className="text-2xl font-bold text-yellow-400">{data.quick_insights.trend.percentage}% <span className="text-sm">{data.quick_insights.trend.direction}</span></p>
            <p className="text-gray-400 mt-2">30-day trend</p>
          </div>
        </div>

        {/* Charts */}
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 mb-8">
          <div className="bg-gray-800 rounded-lg p-6">
            <h3 className="text-lg font-semibold mb-4">Conflict Risk Distribution</h3>
            <ResponsiveContainer width="100%" height={300}>
              <PieChart>
                <Pie data={conflictData} cx="50%" cy="50%" labelLine={false} label={({ name, value }) => `${name}: ${value}`} outerRadius={80} fill="#8884d8" dataKey="value">
                  {conflictData.map((entry, index) => (
                    <Cell key={`cell-${index}`} fill={COLORS[index % COLORS.length]} />
                  ))}
                </Pie>
                <Tooltip />
              </PieChart>
            </ResponsiveContainer>
          </div>

          <div className="bg-gray-800 rounded-lg p-6">
            <h3 className="text-lg font-semibold mb-4">Key Metrics</h3>
            <div className="space-y-4">
              <div className="flex justify-between pb-3 border-b border-gray-700">
                <span className="text-gray-400">Total Events</span>
                <span className="font-bold">{data.metrics.total_events}</span>
              </div>
              <div className="flex justify-between pb-3 border-b border-gray-700">
                <span className="text-gray-400">Total Fatalities</span>
                <span className="font-bold text-red-400">{data.metrics.total_fatalities}</span>
              </div>
              <div className="flex justify-between pb-3 border-b border-gray-700">
                <span className="text-gray-400">Avg Conflict Proneness</span>
                <span className="font-bold">{data.metrics.avg_conflict_proneness.toFixed(2)}</span>
              </div>
              <div className="flex justify-between">
                <span className="text-gray-400">Avg Climate Risk</span>
                <span className="font-bold">{data.metrics.avg_climate_risk.toFixed(2)}</span>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default Dashboard;

### ./frontend/src/components/dashboard/Header.tsx ###
'use client'

export default function Header() {
  return (
    <header className="border-b border-gray-200 bg-white">
      <div className="flex items-center justify-between px-6 py-4 border-b border-gray-200">
        <div className="flex items-center gap-3">
          <div className="w-8 h-8 bg-orange-600 flex items-center justify-center text-white font-bold text-xs">
            S
          </div>
          <span className="text-sm uppercase tracking-widest text-gray-600 font-bold">
            Sudan Risk Dashboard
          </span>
        </div>

        <nav className="flex items-center gap-6 text-xs uppercase tracking-wide font-medium">
          <button className="text-gray-600 hover:text-gray-900 transition">About</button>
          <button className="text-gray-600 hover:text-gray-900 transition">Home</button>
          <button className="text-gray-600 hover:text-gray-900 transition">Log In</button>
          <button className="bg-orange-600 text-white px-4 py-2 hover:bg-orange-700 transition-colors font-medium">
            Subscribe
          </button>
        </nav>
      </div>
    </header>
  )
}

### ./frontend/src/components/dashboard/InteractiveMap.tsx ###
'use client'

import { useEffect, useState } from 'react'
import dynamic from 'next/dynamic'
import { normalizeRegionName } from '@/utils/regionNameMapping'

const MapContainer = dynamic(
  () => import('react-leaflet').then((mod) => mod.MapContainer),
  { ssr: false }
)

const TileLayer = dynamic(
  () => import('react-leaflet').then((mod) => mod.TileLayer),
  { ssr: false }
)

const GeoJSON = dynamic(
  () => import('react-leaflet').then((mod) => mod.GeoJSON),
  { ssr: false }
)

export default function InteractiveMap({ indicator }: { indicator: string }) {
  const [geoData, setGeoData] = useState(null)
  const [riskData, setRiskData] = useState<any>(null)

  const center = [15.5007, 32.5599]
  const zoom = 6

  useEffect(() => {
    const fetchGeoData = async () => {
      try {
        const res = await fetch('/data/sudan-states.geojson')
        const data = await res.json()
        setGeoData(data)
      } catch (err) {
        console.error('Failed to load GeoJSON:', err)
      }
    }

    fetchGeoData()
  }, [])

  useEffect(() => {
    const fetchRiskData = async () => {
      try {
        const res = await fetch(
          `${process.env.NEXT_PUBLIC_BACKEND_URL}/api/map-data?indicator=${indicator}`
        )
        const data = await res.json()
        setRiskData(data)
      } catch (err) {
        console.error('Failed to fetch risk data:', err)
      }
    }

    fetchRiskData()
  }, [indicator])

  const getColor = (value: number) => {
    if (value === undefined || value === null || value === 0) return '#f3f4f6'
    if (value >= 8) return '#ED4447'
    if (value >= 6) return '#F37420'
    if (value >= 4) return '#E7B412'
    if (value >= 2) return '#11182A'
    if (value >= 1) return '#394153'
    return '#4A5464'
  }

  const style = (feature: any) => {
    const geoName = feature.properties.shapeName
    const normalizedName = normalizeRegionName(geoName)
    const riskValue = riskData?.[normalizedName] || 0

    return {
      fillColor: getColor(riskValue),
      weight: 2,
      opacity: 1,
      color: '#ffffff',
      fillOpacity: 0.8,
    }
  }

  const onEachFeature = (feature: any, layer: any) => {
    const geoName = feature.properties.shapeName
    const normalizedName = normalizeRegionName(geoName)
    const riskValue = riskData?.[normalizedName]?.toFixed(1) || 'N/A'

    // ONLY Tooltip (shows on hover)
    layer.bindTooltip(
      `<div style="font-family: Inter, sans-serif; padding: 4px; text-align: center;">
        <strong style="font-size: 11px; text-transform: uppercase; display: block; margin-bottom: 4px;">${normalizedName}</strong>
        <span style="font-size: 16px; font-weight: 700; color: #F37420;">${riskValue}</span>
        <span style="font-size: 10px; color: #9ca3af;"> / 10</span>
      </div>`,
      {
        permanent: false,
        direction: 'top',
        className: 'custom-tooltip',
        opacity: 0.95
      }
    )

    // REMOVED: bindPopup() - No click popup anymore

    // Hover effects
    layer.on({
      mouseover: (e: any) => {
        e.target.setStyle({ 
          weight: 3, 
          color: '#F37420',
          fillOpacity: 1
        })
      },
      mouseout: (e: any) => {
        e.target.setStyle({ 
          weight: 2, 
          color: '#ffffff',
          fillOpacity: 0.8
        })
      },
    })
  }

  return (
    <section className="flex-1 h-full">
      {typeof window !== 'undefined' && geoData && (
        <MapContainer
          center={center as [number, number]}
          zoom={zoom}
          style={{ height: '100%', width: '100%' }}
          className="border border-gray-300"
        >
          <TileLayer
            url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
            attribution='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>'
          />

          {geoData && (
            <GeoJSON
              key={indicator}
              data={geoData}
              style={style}
              onEachFeature={onEachFeature}
            />
          )}
        </MapContainer>
      )}
    </section>
  )
}

### ./frontend/src/components/dashboard/MainMap.tsx ###
'use client'

import dynamic from 'next/dynamic'

const InteractiveMap = dynamic(
  () => import('./InteractiveMap'),
  { ssr: false }
)

export default function MainMap({ indicator }: { indicator: string }) {
  return <InteractiveMap indicator={indicator} />
}

### ./frontend/src/components/dashboard/RightPanel.tsx ###
'use client'

import { useState, useEffect } from 'react'
import AIAlertFeed from './panels/AIAlertFeed'
import RiskIndicators from './panels/RiskIndicators'
import RiskTrendChart from './panels/RiskChart'
import CountryHeader from './panels/CountryHeader'
import Description from './panels/Description'
import DownloadOptions from './panels/DownloadOptions'
import DataSources from './panels/DataSources'
import GoldsteinEscalationPanel from './panels/GoldsteinEscalationPanel'  // Updated path

export default function RightPanel() {
  const [analytics, setAnalytics] = useState<any>(null)
  const [loading, setLoading] = useState(true)

  useEffect(() => {
    const fetchAnalytics = async () => {
      try {
        const res = await fetch(`${process.env.NEXT_PUBLIC_BACKEND_URL}/api/analytics`)
        const data = await res.json()
        setAnalytics(data)
      } catch (err) {
        console.error('Failed to fetch analytics:', err)
      } finally {
        setLoading(false)
      }
    }

    fetchAnalytics()
  }, [])

  if (loading) {
    return <aside className="w-80">Loading...</aside>
  }

  return (
    <aside className="w-80 space-y-4 overflow-y-auto">
      <CountryHeader />
      {analytics && <RiskIndicators summary={analytics.summary} />}
      <RiskTrendChart />
      <GoldsteinEscalationPanel />
      <AIAlertFeed />
      <Description />
      <DownloadOptions />
      <DataSources />
    </aside>
  )
}
### ./frontend/src/components/dashboard/Sidebar.tsx ###
'use client'

import { useEffect, useState } from 'react'

export default function Sidebar({ selectedIndicator, onSelectIndicator }: { selectedIndicator: string; onSelectIndicator: (id: string) => void }) {
  const [mounted, setMounted] = useState(false)

  useEffect(() => {
    setMounted(true)
  }, [])

  const indicators = [
    { id: 'climate-risk', label: 'Climate Risk', icon: 'fa-solid fa-cloud' },
    { id: 'conflict-risk', label: 'Conflict Risk', icon: 'fa-solid fa-bolt' },
    { id: 'combined-risk', label: 'Compound Risk', icon: 'fa-solid fa-triangle-exclamation' },
  ]

  if (!mounted) {
    return (
      <aside className="w-64 border-r border-gray-200 overflow-y-auto bg-white">
        <div className="p-6 border-b border-gray-200">
          <h2 className="text-xs uppercase tracking-widest text-gray-600 mb-4 font-bold">
            Indicator Layers
          </h2>
          <div className="space-y-3">
            {indicators.map(indicator => (
              <button
                key={indicator.id}
                className="w-full border border-gray-300 p-3 text-left text-xs uppercase tracking-wide bg-white text-gray-900 font-medium"
              >
                {indicator.label}
              </button>
            ))}
          </div>
        </div>
      </aside>
    )
  }

  return (
    <aside className="w-64 border-r border-gray-200 overflow-y-auto bg-white">
      <div className="p-6 border-b border-gray-200">
        <h2 className="text-xs uppercase tracking-widest text-gray-600 mb-4 font-bold">
          Indicator Layers
        </h2>
        <div className="space-y-3">
          {indicators.map(indicator => (
            <button
              key={indicator.id}
              onClick={() => onSelectIndicator(indicator.id)}
              className="w-full border border-gray-300 p-3 text-left text-xs uppercase tracking-wide hover:border-gray-400 transition-colors bg-white text-gray-900 font-medium"
            >
              <i className={`${indicator.icon} mr-2`} suppressHydrationWarning></i>
              {indicator.label}
            </button>
          ))}
        </div>
      </div>

      <div className="p-6 space-y-2 border-b border-gray-200">
        <button className="w-full text-left text-xs uppercase tracking-wide text-orange-600 hover:text-orange-700 py-2 font-medium transition">
          <i className="fa-solid fa-download mr-2" suppressHydrationWarning></i>Download Data
        </button>
        <button className="w-full text-left text-xs uppercase tracking-wide text-orange-600 hover:text-orange-700 py-2 font-medium transition">
          <i className="fa-solid fa-file-lines mr-2" suppressHydrationWarning></i>Generate Report
        </button>
      </div>

      <div className="p-6 space-y-2">
        <button className="w-full bg-gray-200 text-gray-900 p-3 text-xs uppercase tracking-wide hover:bg-gray-300 transition-colors font-medium">
          <i className="fa-solid fa-rotate-left mr-2" suppressHydrationWarning></i>Reset All Filters
        </button>
        <button className="w-full bg-gray-200 text-gray-900 p-3 text-xs uppercase tracking-wide hover:bg-gray-300 transition-colors font-medium">
          <i className="fa-solid fa-map mr-2" suppressHydrationWarning></i>Change Map Style
        </button>
      </div>
    </aside>
  )
}

### ./frontend/src/components/dashboard/panels/AIAlertFeed.tsx ###
export default function AIAlertFeed() {
  const alerts = [
    {
      id: 1,
      title: 'High Conflict Risk Alert',
      description: 'Escalating tensions reported in North Darfur region. Risk index increased by 23% over the past week. Humanitarian access remains severely restricted.',
      timestamp: '2 hours ago',
      borderColor: 'border-orange-600',
    },
    {
      id: 2,
      title: 'Moderate Climate Risk Update',
      description: 'Flooding conditions persist in White Nile state. Rainfall patterns suggest continued risk through mid-October. Agricultural impact assessment ongoing.',
      timestamp: '4 hours ago',
      borderColor: 'border-orange-500',
    },
    {
      id: 3,
      title: 'Compound Risk Warning',
      description: 'Khartoum experiencing simultaneous climate stress and security concerns. Displacement pressure increasing. Early action recommended.',
      timestamp: '6 hours ago',
      borderColor: 'border-orange-400',
    }
  ]

  return (
    <div className="border border-gray-300 p-4 bg-white">
      <h3 className="text-xs uppercase tracking-widest text-gray-600 mb-4 flex justify-between items-center font-bold">
        <span><i className="mr-2">ðŸ””</i>AI Alert Feed</span>
        <button className="text-orange-600 hover:text-orange-700 transition">â†»</button>
      </h3>
      <div className="space-y-3">
        {alerts.map(alert => (
          <div key={alert.id} className={`border-l-4 ${alert.borderColor} pl-3 py-2`}>
            <p className="text-xs font-bold text-gray-900">{alert.title}</p>
            <p className="text-xs text-gray-600 mt-1">{alert.description}</p>
            <p className="text-xs text-gray-500 mt-2">{alert.timestamp}</p>
          </div>
        ))}
      </div>
    </div>
  )
}

### ./frontend/src/components/dashboard/panels/CountryHeader.tsx ###
export default function CountryHeader() {
  return (
    <div className="border border-gray-300 p-4 bg-white rounded">
      <h1 className="text-2xl font-bold text-gray-900 mb-1">Sudan</h1>
      <p className="text-xs text-gray-600">Climate & Conflict Risk | October 2025</p>
    </div>
  )
}

### ./frontend/src/components/dashboard/panels/DataSources.tsx ###
export default function DataSources() {
  return (
    <div className="border border-gray-300 p-4 bg-white rounded">
      <h3 className="text-xs uppercase tracking-widest text-gray-600 mb-3 font-bold">
        Data Sources
      </h3>
      <p className="text-xs text-gray-600 mb-2">
        Climate: <a href="#" className="text-orange-600 hover:text-orange-700 font-medium transition">NOAA VIIRS</a> | Conflict: <a href="#" className="text-orange-600 hover:text-orange-700 font-medium transition">ACLED</a>
      </p>
      <p className="text-xs text-gray-600">
        Â© Mapbox | Â© OpenStreetMap | Improve this map
      </p>
    </div>
  )
}

### ./frontend/src/components/dashboard/panels/Description.tsx ###
export default function Description() {
  return (
    <div className="border border-gray-300 p-4 bg-white rounded">
      <p className="text-xs text-gray-600 leading-relaxed">
        Sudan faces compounding climate and conflict risks in October 2025. Flooding affects 0.3% of the country's surface area, with significant impacts in Khartoum (2.0%) and White Nile (1.6%). Simultaneously, conflict intensity remains elevated across Darfur regions, affecting humanitarian access and displacement patterns.
      </p>
      <a href="#" className="text-xs text-orange-600 mt-3 inline-block hover:text-orange-700 font-medium transition">
        Read full narrative
      </a>
    </div>
  )
}

### ./frontend/src/components/dashboard/panels/DownloadOptions.tsx ###
export default function DownloadOptions() {
  return (
    <div className="border border-gray-300 p-4 bg-white">
      <h3 className="text-xs uppercase tracking-widest text-gray-600 mb-3 font-bold">
        Download & Export
      </h3>
      <div className="space-y-2">
        <button className="w-full text-left text-xs text-orange-600 hover:text-orange-700 py-2 flex items-center gap-2 font-medium transition">
          <i>ðŸ“¥</i>Download Data (CSV)
        </button>
        <button className="w-full text-left text-xs text-orange-600 hover:text-orange-700 py-2 flex items-center gap-2 font-medium transition">
          <i>ðŸ“„</i>Generate Narrative Report
        </button>
        <button className="w-full text-left text-xs text-orange-600 hover:text-orange-700 py-2 flex items-center gap-2 font-medium transition">
          <i>ðŸ–¼ï¸</i>Export Map Image
        </button>
      </div>
    </div>
  )
}

### ./frontend/src/components/dashboard/panels/GoldsteinEscalationPanel.tsx ###
// frontend/src/components/dashboard/panels/GoldsteinEscalationPanel.tsx
'use client'

import { useEffect, useState } from 'react'
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, ReferenceLine } from 'recharts'
import { ChevronDown, ChevronUp } from 'lucide-react'

interface EscalationData {
  location: string
  escalation_risk: number
  risk_level: string
  avg_goldstein: number
  goldstein_trend: number
  event_count: number
}

export default function GoldsteinEscalationPanel() {
  const [topRisks, setTopRisks] = useState<EscalationData[]>([])
  const [timeline, setTimeline] = useState<any[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [isExpanded, setIsExpanded] = useState(true) // Collapsible state

  useEffect(() => {
    const fetchData = async () => {
      try {
        const risksRes = await fetch(`${process.env.NEXT_PUBLIC_BACKEND_URL}/api/goldstein/top-risks?limit=5`)
        
        if (!risksRes.ok) {
          throw new Error(`API Error: ${risksRes.status}`)
        }
        
        const risksData = await risksRes.json()
        
        if (risksData && risksData.top_risks && Array.isArray(risksData.top_risks)) {
          setTopRisks(risksData.top_risks)
        } else {
          throw new Error('Invalid data format')
        }

        const timelineRes = await fetch(`${process.env.NEXT_PUBLIC_BACKEND_URL}/api/goldstein/timeline?hours=24`)
        
        if (timelineRes.ok) {
          const timelineData = await timelineRes.json()
          
          if (timelineData && Array.isArray(timelineData.timestamps)) {
            const chartData = timelineData.timestamps.map((ts: string, i: number) => ({
              time: new Date(ts).toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' }),
              goldstein: timelineData.goldstein_scores[i],
              events: timelineData.event_counts[i]
            }))
            setTimeline(chartData)
          }
        }
        
        setLoading(false)
      } catch (err: any) {
        console.error('Goldstein fetch error:', err)
        setError(err.message)
        setLoading(false)
      }
    }

    fetchData()
    const interval = setInterval(fetchData, 300000)
    return () => clearInterval(interval)
  }, [])

  if (loading) {
    return (
      <div className="border border-gray-300 p-4 bg-white">
        <p className="text-xs text-gray-600">Loading escalation data...</p>
      </div>
    )
  }

  if (error) {
    return (
      <div className="border border-gray-300 p-4 bg-gray-50">
        <h3 className="text-xs uppercase tracking-widest text-gray-600 mb-2 font-bold">
          Goldstein Data Unavailable
        </h3>
        <p className="text-xs text-gray-600 mb-2">{error}</p>
        <p className="text-xs text-gray-500 mt-2">
          Run: <code className="bg-gray-200 px-1">python scripts/gdelt/fetch_sudan_events.py</code>
        </p>
      </div>
    )
  }

  if (!topRisks || topRisks.length === 0) {
    return (
      <div className="border border-gray-300 p-4 bg-white">
        <h3 className="text-xs uppercase tracking-widest text-gray-600 mb-2 font-bold">
          No Escalation Data
        </h3>
        <p className="text-xs text-gray-600">
          Run GDELT scripts to populate data.
        </p>
      </div>
    )
  }

  const getRiskColor = (level: string) => {
    const colors: Record<string, string> = {
      'CRITICAL': 'border-red-600',
      'HIGH': 'border-orange-600',
      'MODERATE': 'border-yellow-500'
    }
    return colors[level] || 'border-green-500'
  }

  const getRiskBgColor = (level: string) => {
    const colors: Record<string, string> = {
      'CRITICAL': 'bg-red-50',
      'HIGH': 'bg-orange-50',
      'MODERATE': 'bg-yellow-50'
    }
    return colors[level] || 'bg-green-50'
  }

  return (
    <div className="space-y-4">
      {/* Top Risks Section with Collapse Button */}
      <div className="border border-gray-300 bg-white">
        {/* Header with Collapse Button */}
        <div 
          className="flex justify-between items-center p-4 cursor-pointer hover:bg-gray-50"
          onClick={() => setIsExpanded(!isExpanded)}
        >
          <h3 className="text-xs uppercase tracking-widest text-gray-600 font-bold">
            Top Escalation Risks (GDELT)
          </h3>
          {isExpanded ? (
            <ChevronUp className="w-4 h-4 text-gray-600" />
          ) : (
            <ChevronDown className="w-4 h-4 text-gray-600" />
          )}
        </div>

        {/* Collapsible Content */}
        {isExpanded && (
          <div className="px-4 pb-4">
            <div className="space-y-3">
              {topRisks.map((risk, i) => (
                <div
                  key={i}
                  className={`border-l-4 ${getRiskColor(risk.risk_level)} ${getRiskBgColor(risk.risk_level)} pl-3 py-2`}
                >
                  <div className="flex justify-between items-start">
                    <div className="flex-1">
                      <p className="text-xs font-bold text-gray-900">
                        {risk.location}
                      </p>
                      <p className="text-xs text-gray-600 mt-1">
                        Goldstein: {risk.avg_goldstein?.toFixed(1) ?? 'N/A'} | {risk.event_count ?? 0} events
                        {risk.goldstein_trend && (
                          <span> | {risk.goldstein_trend < 0 ? 'â¬‡ï¸ Escalating' : 'â¬†ï¸ Stable'}</span>
                        )}
                      </p>
                    </div>
                    <div className="text-right">
                      <p className="text-lg font-mono font-bold text-orange-600">
                        {risk.escalation_risk?.toFixed(1) ?? 'N/A'}
                      </p>
                      <p className="text-xs text-gray-500">{risk.risk_level ?? 'UNKNOWN'}</p>
                    </div>
                  </div>
                </div>
              ))}
            </div>

            <p className="text-xs text-gray-500 mt-3">
              Real-time data from GDELT
            </p>
          </div>
        )}
      </div>

      {/* Timeline Chart (Always Visible) */}
      {timeline && timeline.length > 0 && (
        <div className="border border-gray-300 p-4 bg-white">
          <h3 className="text-xs uppercase tracking-widest text-gray-600 mb-4 font-bold">
            Goldstein Trend (24h)
          </h3>

          <div className="h-64">
            <ResponsiveContainer width="100%" height="100%">
              <LineChart data={timeline}>
                <CartesianGrid strokeDasharray="3 3" stroke="#e5e7eb" />
                <XAxis
                  dataKey="time"
                  tick={{ fontSize: 10 }}
                  stroke="#9ca3af"
                />
                <YAxis
                  domain={[-10, 10]}
                  tick={{ fontSize: 10 }}
                  stroke="#9ca3af"
                />
                <Tooltip />
                <ReferenceLine y={0} stroke="#6b7280" strokeDasharray="3 3" />
                <ReferenceLine y={-5} stroke="#dc2626" strokeDasharray="2 2" />
                <Line
                  type="monotone"
                  dataKey="goldstein"
                  stroke="#F37420"
                  strokeWidth={2.5}
                  dot={{ fill: '#F37420', r: 2 }}
                />
              </LineChart>
            </ResponsiveContainer>
          </div>

          <div className="mt-3 text-xs text-gray-600">
            <p>+10 (cooperation) to -10 (extreme violence)</p>
          </div>
        </div>
      )}
    </div>
  )
}

### ./frontend/src/components/dashboard/panels/GoldsteinEscalationPanel.tsx.old ###
// frontend/src/components/dashboard/panels/GoldsteinEscalationPanel.tsx
'use client'

import { useEffect, useState } from 'react'
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer, ReferenceLine } from 'recharts'

interface EscalationData {
  location: string
  escalation_risk: number  // CHANGED: was risk_score
  risk_level: string
  avg_goldstein: number
  goldstein_trend: number  // CHANGED: added this
  event_count: number
}

export default function GoldsteinEscalationPanel() {
  const [topRisks, setTopRisks] = useState<EscalationData[]>([])
  const [timeline, setTimeline] = useState<any[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    const fetchData = async () => {
      try {
        const risksRes = await fetch(`${process.env.NEXT_PUBLIC_BACKEND_URL}/api/goldstein/top-risks?limit=5`)
        
        if (!risksRes.ok) {
          throw new Error(`API Error: ${risksRes.status}`)
        }
        
        const risksData = await risksRes.json()
        
        if (risksData && risksData.top_risks && Array.isArray(risksData.top_risks)) {
          setTopRisks(risksData.top_risks)
        } else {
          throw new Error('Invalid data format')
        }

        const timelineRes = await fetch(`${process.env.NEXT_PUBLIC_BACKEND_URL}/api/goldstein/timeline?hours=24`)
        
        if (timelineRes.ok) {
          const timelineData = await timelineRes.json()
          
          if (timelineData && Array.isArray(timelineData.timestamps)) {
            const chartData = timelineData.timestamps.map((ts: string, i: number) => ({
              time: new Date(ts).toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' }),
              goldstein: timelineData.goldstein_scores[i],
              events: timelineData.event_counts[i]
            }))
            setTimeline(chartData)
          }
        }
        
        setLoading(false)
      } catch (err: any) {
        console.error('Goldstein fetch error:', err)
        setError(err.message)
        setLoading(false)
      }
    }

    fetchData()
    const interval = setInterval(fetchData, 300000)
    return () => clearInterval(interval)
  }, [])

  if (loading) {
    return (
      <div className="border border-gray-300 p-4 bg-white">
        <p className="text-xs text-gray-600">Loading escalation data...</p>
      </div>
    )
  }

  if (error) {
    return (
      <div className="border border-gray-300 p-4 bg-gray-50">
        <h3 className="text-xs uppercase tracking-widest text-gray-600 mb-2 font-bold">
          Goldstein Data Unavailable
        </h3>
        <p className="text-xs text-gray-600 mb-2">{error}</p>
        <p className="text-xs text-gray-500 mt-2">
          Run: <code className="bg-gray-200 px-1">python scripts/gdelt/fetch_sudan_events.py</code>
        </p>
      </div>
    )
  }

  if (!topRisks || topRisks.length === 0) {
    return (
      <div className="border border-gray-300 p-4 bg-white">
        <h3 className="text-xs uppercase tracking-widest text-gray-600 mb-2 font-bold">
          No Escalation Data
        </h3>
        <p className="text-xs text-gray-600">
          Run GDELT scripts to populate data.
        </p>
      </div>
    )
  }

  const getRiskColor = (level: string) => {
    const colors: Record<string, string> = {
      'CRITICAL': 'border-red-600',
      'HIGH': 'border-orange-600',
      'MODERATE': 'border-yellow-500'
    }
    return colors[level] || 'border-green-500'
  }

  const getRiskBgColor = (level: string) => {
    const colors: Record<string, string> = {
      'CRITICAL': 'bg-red-50',
      'HIGH': 'bg-orange-50',
      'MODERATE': 'bg-yellow-50'
    }
    return colors[level] || 'bg-green-50'
  }

  return (
    <div className="space-y-4">
      <div className="border border-gray-300 p-4 bg-white">
        <h3 className="text-xs uppercase tracking-widest text-gray-600 mb-4 font-bold">
          Top Escalation Risks (GDELT)
        </h3>

        <div className="space-y-3">
          {topRisks.map((risk, i) => (
            <div
              key={i}
              className={`border-l-4 ${getRiskColor(risk.risk_level)} ${getRiskBgColor(risk.risk_level)} pl-3 py-2`}
            >
              <div className="flex justify-between items-start">
                <div className="flex-1">
                  <p className="text-xs font-bold text-gray-900">
                    {risk.location}
                  </p>
                  <p className="text-xs text-gray-600 mt-1">
                    Goldstein: {risk.avg_goldstein?.toFixed(1) ?? 'N/A'} | {risk.event_count ?? 0} events
                    {risk.goldstein_trend && (
                      <span> | {risk.goldstein_trend < 0 ? 'â¬‡ï¸ Escalating' : 'â¬†ï¸ Stable'}</span>
                    )}
                  </p>
                </div>
                <div className="text-right">
                  <p className="text-lg font-mono font-bold text-orange-600">
                    {risk.escalation_risk?.toFixed(1) ?? 'N/A'}
                  </p>
                  <p className="text-xs text-gray-500">{risk.risk_level ?? 'UNKNOWN'}</p>
                </div>
              </div>
            </div>
          ))}
        </div>

        <p className="text-xs text-gray-500 mt-3">
          Real-time data from GDELT
        </p>
      </div>

      {timeline && timeline.length > 0 && (
        <div className="border border-gray-300 p-4 bg-white">
          <h3 className="text-xs uppercase tracking-widest text-gray-600 mb-4 font-bold">
            Goldstein Trend (24h)
          </h3>

          <div className="h-64">
            <ResponsiveContainer width="100%" height="100%">
              <LineChart data={timeline}>
                <CartesianGrid strokeDasharray="3 3" stroke="#e5e7eb" />
                <XAxis
                  dataKey="time"
                  tick={{ fontSize: 10 }}
                  stroke="#9ca3af"
                />
                <YAxis
                  domain={[-10, 10]}
                  tick={{ fontSize: 10 }}
                  stroke="#9ca3af"
                />
                <Tooltip />
                <ReferenceLine y={0} stroke="#6b7280" strokeDasharray="3 3" />
                <ReferenceLine y={-5} stroke="#dc2626" strokeDasharray="2 2" />
                <Line
                  type="monotone"
                  dataKey="goldstein"
                  stroke="#F37420"
                  strokeWidth={2.5}
                  dot={{ fill: '#F37420', r: 2 }}
                />
              </LineChart>
            </ResponsiveContainer>
          </div>

          <div className="mt-3 text-xs text-gray-600">
            <p>+10 (cooperation) to -10 (extreme violence)</p>
          </div>
        </div>
      )}
    </div>
  )
}

### ./frontend/src/components/dashboard/panels/RiskChart.tsx ###
'use client'

import { useEffect, useState } from 'react'
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from 'recharts'

export default function RiskChart() {
  const [data, setData] = useState<any[]>([])
  const [isCollapsed, setIsCollapsed] = useState(false)

  useEffect(() => {
    const fetchTrends = async () => {
      try {
        const res = await fetch(`${process.env.NEXT_PUBLIC_BACKEND_URL}/api/monthly-trend`)
        const response = await res.json()
        setData(response.data || [])
      } catch (err) {
        console.error('Failed to fetch trends:', err)
      }
    }
    fetchTrends()
  }, [])

  return (
    <div className="border border-gray-300 p-4 bg-white">
      <h3 className="text-xs uppercase tracking-widest text-gray-600 mb-4 flex justify-between items-center font-bold">
        Risk Trend Analysis
        <button 
          onClick={() => setIsCollapsed(!isCollapsed)}
          className="text-orange-600 hover:text-orange-700 transition text-lg font-bold"
          aria-label={isCollapsed ? "Expand" : "Collapse"}
        >
          {isCollapsed ? '+' : 'âˆ’'}
        </button>
      </h3>
      
      {!isCollapsed && (
        <>
          {data.length > 0 ? (
            <div className="bg-gray-50 p-3">
              <ResponsiveContainer width="100%" height={220}>
                <LineChart data={data} margin={{ top: 10, right: 10, left: -15, bottom: 5 }}>
                  <CartesianGrid stroke="#E5E7EB" strokeDasharray="3 3" />
                  <XAxis
                    dataKey="month"
                    tick={{ fontSize: 10 }}
                    stroke="#9CA3AF"
                  />
                  <YAxis
                    tick={{ fontSize: 10 }}
                    stroke="#9CA3AF"
                    width={30}
                  />
                  <Tooltip
                    contentStyle={{
                      backgroundColor: '#ffffff',
                      border: '1px solid #d1d5db',
                      borderRadius: '0',
                      fontSize: '11px',
                      padding: '8px'
                    }}
                  />
                  <Line
                    type="monotone"
                    dataKey="events"
                    stroke="#F37420"
                    strokeWidth={2.5}
                    dot={{ fill: '#F37420', r: 3 }}
                    activeDot={{ r: 5 }}
                    name="Conflict Risk"
                  />
                  <Line
                    type="monotone"
                    dataKey="fatalities"
                    stroke="#049787"
                    strokeWidth={2.5}
                    dot={{ fill: '#049787', r: 3 }}
                    activeDot={{ r: 5 }}
                    name="Climate Risk"
                  />
                </LineChart>
              </ResponsiveContainer>
            </div>
          ) : (
            <p className="text-xs text-gray-500 bg-gray-50 p-3">Loading chart...</p>
          )}
          <div className="flex gap-6 mt-4 text-xs">
            <div className="flex items-center gap-2">
              <div className="w-4 h-4 rounded-sm" style={{ backgroundColor: '#F37420' }}></div>
              <span className="text-gray-700 font-medium">Conflict Risk</span>
            </div>
            <div className="flex items-center gap-2">
              <div className="w-4 h-4 rounded-sm" style={{ backgroundColor: '#049787' }}></div>
              <span className="text-gray-700 font-medium">Climate Risk</span>
            </div>
          </div>
        </>
      )}
    </div>
  )
}

### ./frontend/src/components/dashboard/panels/RiskIndicators.tsx ###
'use client'

import { useState } from 'react'

export default function RiskIndicators({ summary }: { summary: any }) {
  const [isCollapsed, setIsCollapsed] = useState(false)

  return (
    <div className="border border-gray-300 p-4 bg-white rounded">
      <h3 className="text-xs uppercase tracking-widest text-gray-600 mb-4 flex justify-between items-center font-bold">
        Current Risk Indicators
        <button 
          onClick={() => setIsCollapsed(!isCollapsed)}
          className="text-orange-600 hover:text-orange-700 transition text-lg font-bold"
          aria-label={isCollapsed ? "Expand" : "Collapse"}
        >
          {isCollapsed ? '+' : 'âˆ’'}
        </button>
      </h3>

      {!isCollapsed && (
        <div className="grid grid-cols-2 gap-4">
          <div className="border-l-4 border-orange-600 pl-3 bg-gray-50 p-2 rounded">
            <p className="text-2xl font-mono font-bold text-orange-600">
              {summary?.avg_conflict_proneness?.toFixed(1) || '7.2'}
            </p>
            <p className="text-xs text-gray-600 mt-1">Conflict Risk</p>
            <p className="text-xs text-gray-500">out of 10</p>
          </div>

          <div className="border-l-4 border-orange-500 pl-3 bg-gray-50 p-2 rounded">
            <p className="text-2xl font-mono font-bold text-orange-500">
              {summary?.avg_climate_risk?.toFixed(1) || '5.8'}
            </p>
            <p className="text-xs text-gray-600 mt-1">Climate Risk</p>
            <p className="text-xs text-gray-500">out of 10</p>
          </div>
        </div>
      )}
    </div>
  )
}

### ./frontend/src/components/layout/Layout.tsx ###
'use client'

import React, { ReactNode } from 'react'
import { Sidebar } from './Sidebar'
import { TopBar } from './TopBar'

interface LayoutProps {
  children: ReactNode
}

export function Layout({ children }: LayoutProps) {
  return (
    <div className="flex h-screen bg-slate-900">
      {/* Sidebar Navigation */}
      <Sidebar />

      {/* Main Content Area */}
      <div className="flex-1 flex flex-col overflow-hidden">
        {/* Top Bar */}
        <TopBar />

        {/* Page Content */}
        <main className="flex-1 overflow-y-auto bg-gradient-to-br from-slate-900 via-slate-800 to-slate-900 p-6">
          {children}
        </main>
      </div>
    </div>
  )
}

### ./frontend/src/components/layout/Sidebar.tsx ###
'use client'

import React from 'react'
import Link from 'next/link'
import { usePathname } from 'next/navigation'

const navItems = [
  { name: 'Dashboard', path: '/dashboard', icon: 'ðŸ“Š' },
  { name: 'Map', path: '/map', icon: 'ðŸ—ºï¸' },
  { name: 'Analytics', path: '/analytics', icon: 'ðŸ“ˆ' },
  { name: 'Alerts', path: '/alerts', icon: 'âš ï¸' },
  { name: 'Regions', path: '/regions', icon: 'ðŸ“' },
  { name: 'Reports', path: '/reports', icon: 'ðŸ“„' },
]

export function Sidebar() {
  const pathname = usePathname()

  return (
    <aside className="w-64 bg-slate-950 border-r border-slate-700 flex flex-col">
      {/* Logo */}
      <div className="p-6 border-b border-slate-700">
        <div className="flex items-center gap-3">
          <div className="w-10 h-10 rounded-lg bg-gradient-to-br from-red-500 to-orange-500 flex items-center justify-center">
            <span className="text-white font-bold text-lg">ðŸ‡¸ðŸ‡©</span>
          </div>
          <div>
            <h1 className="text-white font-bold text-lg">Sudan CRAM</h1>
            <p className="text-xs text-slate-400">v2.0</p>
          </div>
        </div>
      </div>

      {/* Navigation */}
      <nav className="flex-1 p-4 space-y-1">
        {navItems.map((item) => {
          const isActive = pathname === item.path
          return (
            <Link
              key={item.path}
              href={item.path}
              className={`
                flex items-center gap-3 px-4 py-3 rounded-lg transition-all
                ${
                  isActive
                    ? 'bg-teal-500/20 text-teal-300 border border-teal-500/30'
                    : 'text-slate-300 hover:bg-slate-800 hover:text-white'
                }
              `}
            >
              <span className="text-xl">{item.icon}</span>
              <span className="font-medium">{item.name}</span>
            </Link>
          )
        })}
      </nav>

      {/* Footer */}
      <div className="p-4 border-t border-slate-700">
        <div className="flex items-center gap-2 px-4 py-2 bg-green-900/20 rounded-lg border border-green-700/30">
          <div className="w-2 h-2 rounded-full bg-green-500 animate-pulse"></div>
          <span className="text-xs text-green-300 font-medium">Live Data</span>
        </div>
      </div>
    </aside>
  )
}

### ./frontend/src/components/layout/TopBar.tsx ###
'use client'

import React from 'react'

export function TopBar() {
  return (
    <header className="h-16 bg-slate-950 border-b border-slate-700 flex items-center justify-between px-6">
      {/* Breadcrumb / Page Title */}
      <div>
        <h2 className="text-lg font-semibold text-white">Live Data</h2>
        <p className="text-xs text-slate-400">Dashboard Overview</p>
      </div>

      {/* Actions */}
      <div className="flex items-center gap-4">
        {/* Last Updated */}
        <div className="text-sm text-slate-400">
          <span className="text-slate-500">Updated:</span> <span className="text-slate-200 font-medium">Now</span>
        </div>

        {/* User Menu */}
        <div className="flex items-center gap-2">
          <div className="w-8 h-8 rounded-full bg-gradient-to-br from-teal-400 to-teal-600 flex items-center justify-center">
            <span className="text-white text-sm font-bold">U</span>
          </div>
        </div>
      </div>
    </header>
  )
}

### ./frontend/src/components/map/SudanMap.tsx ###
'use client'

import React, { useEffect, useState, useRef, useCallback } from 'react'
import L from 'leaflet'
import 'leaflet/dist/leaflet.css'

interface SudanMapProps {
  backendAvailable: boolean
  indicator: string
}

interface RegionData {
  name: string
  proneness_level: string
  proneness_score: number
  conflict_risk_level: string  // âœ… NEW
  conflict_risk_score: number  // âœ… NEW
  incidents: number
  fatalities: number
  climate_risk_level: string
  climate_risk_score: number
}

type RiskIndicator = 'conflict-risk' | 'climate-risk' | 'conflict-proneness' | 'combined-risk'

const SUDAN_CENTER: [number, number] = [15.5007, 32.5599]
const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:8000'

const getRegionName = (properties: any): string => {
  return properties.shapeName || properties.ADM1_EN || properties.name || 'Unknown'
}

const getRiskColor = (level: string | undefined, riskScore?: number): string => {
  if (!level && riskScore === undefined) return '#6b7280'

  if (riskScore !== undefined) {
    if (riskScore >= 7.5) return '#8B0000'
    if (riskScore >= 6) return '#DC143C'
    if (riskScore >= 4.5) return '#FF6347'
    if (riskScore >= 3) return '#FFA500'
    if (riskScore >= 1.5) return '#FFD700'
    return '#00A86B'
  }

  if (!level) return '#6b7280'

  const normalized = level.toString().toUpperCase().trim()

  const colorMap: Record<string, string> = {
    'EXTREME': '#8B0000',
    'VERY HIGH': '#DC143C',
    'VERY_HIGH': '#DC143C',
    'HIGH': '#FF6347',
    'SEVERE': '#FF4500',
    'ALERT': '#FFA500',
    'MODERATE': '#FFD700',
    'WARNING': '#FFFF00',
    'WATCH': '#90EE90',
    'LOW': '#00A86B',
    'NORMAL': '#90EE90',
  }
  return colorMap[normalized] || '#6b7280'
}

const normalizeRegionName = (name: string): string => {
  const nameMap: Record<string, string> = {
    'Abyei PCA': 'Abyei',
    'Gezira': 'Al Jazirah',
    'Al Jazirah': 'Al Jazirah',
  }
  return nameMap[name] || name
}

export default function SudanMap({ backendAvailable, indicator: initialIndicator }: SudanMapProps) {
  const mapRef = useRef<L.Map | null>(null)
  const mapContainerRef = useRef<HTMLDivElement>(null)
  const geoJsonLayerRef = useRef<L.GeoJSON | null>(null)

  const [regionData, setRegionData] = useState<Record<string, RegionData>>({})
  const [loading, setLoading] = useState(true)
  const [stats, setStats] = useState<Record<string, number>>({})
  const [error, setError] = useState<string | null>(null)
  const [mapReady, setMapReady] = useState(false)
  const [selectedIndicator, setSelectedIndicator] = useState<RiskIndicator>('conflict-proneness')

  // âœ… Fetch backend data - NOW LOADS BOTH CP AND CR
  useEffect(() => {
    const fetchData = async () => {
      console.log('ðŸ”µ [DATA FETCH] Starting...')
      console.log('ðŸ”µ Backend available:', backendAvailable)
      console.log('ðŸ”µ Backend URL:', BACKEND_URL)

      if (!backendAvailable) {
        console.log('âš ï¸ [DATA FETCH] Backend unavailable, skipping')
        setLoading(false)
        return
      }

      try {
        // âœ… Fetch both CP and CR in parallel
        const [cpRes, crRes] = await Promise.all([
          fetch(`${BACKEND_URL}/api/conflict-proneness`),
          fetch(`${BACKEND_URL}/api/conflict-risk`)
        ])

        if (!cpRes.ok || !crRes.ok) {
          throw new Error(`HTTP error: CP ${cpRes.status}, CR ${crRes.status}`)
        }

        const cpData = await cpRes.json()
        const crData = await crRes.json()

        console.log('âœ… [DATA FETCH] Success! CP regions:', Object.keys(cpData).length, 'CR regions:', Object.keys(crData).length)

        // âœ… Merge both datasets
        const regionMap: Record<string, RegionData> = {}

        // Start with CP data
        Object.entries(cpData).forEach(([name, cp]: any) => {
          regionMap[name] = {
            name,
            proneness_level: cp.proneness_level || 'UNKNOWN',
            proneness_score: cp.proneness_score || 0,
            conflict_risk_level: 'UNKNOWN',  // Will be filled from CR
            conflict_risk_score: 0,           // Will be filled from CR
            incidents: cp.high_risk_events || 0,
            fatalities: cp.fatalities || 0,
            climate_risk_level: cp.climate_risk_level || 'UNKNOWN',
            climate_risk_score: cp.climate_risk_score || 0,
          }
        })

        // Merge CR data
        Object.entries(crData).forEach(([name, cr]: any) => {
          if (regionMap[name]) {
            regionMap[name].conflict_risk_level = cr.conflict_risk_level
            regionMap[name].conflict_risk_score = cr.conflict_risk_score
            regionMap[name].incidents = cr.incidents  // Update with CR incidents
            regionMap[name].fatalities = cr.fatalities  // Update with CR fatalities
          }
        })

        console.log('âœ… [DATA FETCH] Merged regions:', Object.keys(regionMap).length)
        setRegionData(regionMap)
      } catch (err: any) {
        console.error('âŒ [DATA FETCH] Error:', err)
        setError(`Backend error: ${err.message}`)
      } finally {
        setLoading(false)
      }
    }

    fetchData()
  }, [backendAvailable])

  // âœ… Initialize map
  useEffect(() => {
    const timer = setTimeout(() => {
      console.log('ðŸ—ºï¸ [MAP INIT] Starting...')

      if (!mapContainerRef.current) {
        console.error('âŒ [MAP INIT] Container ref is null')
        setError('Map container failed to load')
        return
      }

      if (mapRef.current) {
        console.log('âš ï¸ [MAP INIT] Map already exists')
        return
      }

      console.log('ðŸ—ºï¸ [MAP INIT] Creating Leaflet map...')
      const map = L.map(mapContainerRef.current, {
        center: SUDAN_CENTER,
        zoom: 6,
        zoomControl: true,
        scrollWheelZoom: true,
      })

      L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}{r}.png', {
        attribution: 'Â© OpenStreetMap Â© CARTO',
        subdomains: 'abcd',
        maxZoom: 19
      }).addTo(map)

      mapRef.current = map
      setMapReady(true)
      console.log('âœ… [MAP INIT] Map created successfully')
    }, 100)

    return () => {
      clearTimeout(timer)
      if (mapRef.current) {
        console.log('ðŸ—ºï¸ [MAP CLEANUP] Removing map')
        mapRef.current.remove()
        mapRef.current = null
        setMapReady(false)
      }
    }
  }, [])

  // âœ… Load GeoJSON
  useEffect(() => {
    console.log('ðŸ“ [GEOJSON] Loading trigger...')
    console.log('ðŸ“ Map ready:', mapReady)
    console.log('ðŸ“ GeoJSON layer exists:', !!geoJsonLayerRef.current)

    if (!mapReady || geoJsonLayerRef.current) {
      console.log('âš ï¸ [GEOJSON] Skipping: map not ready or layer already exists')
      return
    }

    console.log('ðŸ“ [GEOJSON] Fetching /data/sudan-states.geojson...')

    fetch('/data/sudan-states.geojson')
      .then(res => {
        console.log('ðŸ“ [GEOJSON] Response status:', res.status, res.statusText)
        if (!res.ok) throw new Error(`HTTP ${res.status}`)
        return res.json()
      })
      .then(geojsonData => {
        console.log('âœ… [GEOJSON] Loaded successfully')
        console.log('ðŸ“ [GEOJSON] Features count:', geojsonData.features?.length)
        console.log('ðŸ“ [GEOJSON] Backend data keys:', Object.keys(regionData).length)

        const geoJsonLayer = L.geoJSON(geojsonData, {
          style: (feature) => {
            if (!feature || !feature.properties) {
              return {
                fillColor: '#6b7280',
                weight: 2,
                opacity: 1,
                color: '#000000',
                fillOpacity: 0.3
              }
            }

            const geoJsonName = getRegionName(feature.properties)
            const normalizedName = normalizeRegionName(geoJsonName)
            const regionInfo = regionData[normalizedName]

            let fillColor = '#6b7280'
            if (regionInfo) {
              // âœ… FIXED: Use conflict_risk_level for conflict-risk indicator
              if (selectedIndicator === 'conflict-proneness') {
                fillColor = getRiskColor(regionInfo.proneness_level)
              } else if (selectedIndicator === 'conflict-risk') {
                fillColor = getRiskColor(regionInfo.conflict_risk_level)
              } else if (selectedIndicator === 'climate-risk') {
                fillColor = getRiskColor(regionInfo.climate_risk_level)
              } else if (selectedIndicator === 'combined-risk') {
                const avgScore = (parseFloat(String(regionInfo.proneness_score)) + parseFloat(String(regionInfo.climate_risk_score))) / 2
                fillColor = getRiskColor(undefined, avgScore)
              }
            }

            const style = {
              fillColor,
              weight: 2,
              opacity: 1,
              color: '#000000',
              fillOpacity: regionInfo ? 0.8 : 0.3
            }

            console.log(`ðŸŽ¨ [STYLE] ${geoJsonName} â†’ ${normalizedName} â†’ ${fillColor}`)
            return style
          },
          onEachFeature: (feature, layer) => {
            const geoJsonName = getRegionName(feature.properties)
            const normalizedName = normalizeRegionName(geoJsonName)
            const regionInfo = regionData[normalizedName]

            const popupContent = getPopupContent(geoJsonName, regionInfo, selectedIndicator)

            ;(layer as L.Path).bindPopup(popupContent, { className: 'brutalist-popup' })

            ;(layer as L.Path).on({
              mouseover: (e) => {
                const target = e.target as L.Path
                target.setStyle({ weight: 3, fillOpacity: 1 })
                target.bringToFront()
              },
              mouseout: (e) => {
                const target = e.target as L.Path
                let fillColor = '#6b7280'
                if (regionInfo) {
                  if (selectedIndicator === 'conflict-proneness') {
                    fillColor = getRiskColor(regionInfo.proneness_level)
                  } else if (selectedIndicator === 'conflict-risk') {
                    fillColor = getRiskColor(regionInfo.conflict_risk_level)
                  } else if (selectedIndicator === 'climate-risk') {
                    fillColor = getRiskColor(regionInfo.climate_risk_level)
                  } else if (selectedIndicator === 'combined-risk') {
                    const avgScore = (parseFloat(String(regionInfo.proneness_score)) + parseFloat(String(regionInfo.climate_risk_score))) / 2
                    fillColor = getRiskColor(undefined, avgScore)
                  }
                }
                target.setStyle({
                  fillColor,
                  weight: 2,
                  fillOpacity: regionInfo ? 0.8 : 0.3
                })
              },
              click: () => (layer as L.Path).openPopup()
            })
          }
        }).addTo(mapRef.current!)

        geoJsonLayerRef.current = geoJsonLayer
        console.log('âœ… [GEOJSON] Layer added to map successfully')
      })
      .catch(err => {
        console.error('âŒ [GEOJSON] Error:', err)
        setError(`GeoJSON failed: ${err.message}`)
      })
  }, [mapReady, regionData, selectedIndicator])

  // âœ… Calculate stats based on indicator
  const calculateStats = useCallback(() => {
    const statsMap: Record<string, number> = {}
    Object.values(regionData).forEach(region => {
      let level = ''
      if (selectedIndicator === 'conflict-proneness') {
        level = region.proneness_level
      } else if (selectedIndicator === 'conflict-risk') {
        level = region.conflict_risk_level  // âœ… NEW
      } else if (selectedIndicator === 'climate-risk') {
        level = region.climate_risk_level
      } else if (selectedIndicator === 'combined-risk') {
        const score = (parseFloat(String(region.proneness_score)) + parseFloat(String(region.climate_risk_score))) / 2
        if (score >= 7.5) level = 'EXTREME'
        else if (score >= 6) level = 'VERY HIGH'
        else if (score >= 4.5) level = 'HIGH'
        else if (score >= 3) level = 'MODERATE'
        else level = 'LOW'
      }
      statsMap[level] = (statsMap[level] || 0) + 1
    })
    return statsMap
  }, [selectedIndicator, regionData])

  // âœ… Update stats when indicator or data changes
  useEffect(() => {
    setStats(calculateStats())
  }, [calculateStats])

  // âœ… Update colors when indicator changes
  useEffect(() => {
    console.log('ðŸŽ¨ [COLOR UPDATE] Trigger...')
    console.log('ðŸŽ¨ GeoJSON layer exists:', !!geoJsonLayerRef.current)
    console.log('ðŸŽ¨ Backend data count:', Object.keys(regionData).length)
    console.log('ðŸŽ¨ Selected indicator:', selectedIndicator)

    if (!geoJsonLayerRef.current || Object.keys(regionData).length === 0) {
      console.log('âš ï¸ [COLOR UPDATE] Skipping: no layer or no data')
      return
    }

    console.log(`ðŸŽ¨ [COLOR UPDATE] Switching to ${selectedIndicator}`)

    geoJsonLayerRef.current.eachLayer((layer: any) => {
      if (layer.feature) {
        const geoJsonName = getRegionName(layer.feature.properties)
        const normalizedName = normalizeRegionName(geoJsonName)
        const regionInfo = regionData[normalizedName]

        let fillColor = '#6b7280'

        if (regionInfo) {
          if (selectedIndicator === 'conflict-proneness') {
            fillColor = getRiskColor(regionInfo.proneness_level)
            console.log(`  ðŸ“Œ ${geoJsonName}: ${regionInfo.proneness_level} â†’ ${fillColor}`)
          } else if (selectedIndicator === 'conflict-risk') {
            fillColor = getRiskColor(regionInfo.conflict_risk_level)  // âœ… NEW
            console.log(`  ðŸ“Œ ${geoJsonName}: ${regionInfo.conflict_risk_level} â†’ ${fillColor}`)
          } else if (selectedIndicator === 'climate-risk') {
            fillColor = getRiskColor(regionInfo.climate_risk_level)
            console.log(`  ðŸ“Œ ${geoJsonName}: ${regionInfo.climate_risk_level} â†’ ${fillColor}`)
          } else if (selectedIndicator === 'combined-risk') {
            const avgScore = (parseFloat(String(regionInfo.proneness_score)) + parseFloat(String(regionInfo.climate_risk_score))) / 2
            fillColor = getRiskColor(undefined, avgScore)
            console.log(`  ðŸ“Œ ${geoJsonName}: combined = ${avgScore} â†’ ${fillColor}`)
          }
        }

        layer.setStyle({
          fillColor,
          weight: 2,
          opacity: 1,
          color: '#000000',
          fillOpacity: regionInfo ? 0.8 : 0.3
        })

        ;(layer as L.Path).setPopupContent(getPopupContent(geoJsonName, regionInfo, selectedIndicator))
      }
    })

    console.log(`âœ… [COLOR UPDATE] Complete!`)
  }, [selectedIndicator, regionData])

  if (loading) {
    return (
      <div className="flex items-center justify-center h-full bg-slate-900">
        <div className="text-white font-mono">
          <div className="text-4xl mb-4">ðŸ—ºï¸</div>
          <div className="text-xl font-bold">LOADING...</div>
        </div>
      </div>
    )
  }

  if (error) {
    return (
      <div className="flex items-center justify-center h-full bg-slate-900">
        <div className="text-red-400 font-mono max-w-md text-center">
          <div className="text-xl font-bold mb-2">ERROR</div>
          <div className="text-sm mb-4">{error}</div>
          <div className="text-xs text-gray-400">Check browser console (F12) for details</div>
        </div>
      </div>
    )
  }

  return (
    <div className="relative h-full">
      <div ref={mapContainerRef} className="absolute inset-0" />

      {/* âœ… REGION COUNT (Top-Left) */}
      <div className="absolute top-4 left-4 z-[1000] bg-white border-2 border-black px-4 py-2 shadow-[4px_4px_0_0_#000] font-mono">
        <div className="font-bold text-sm">{Object.keys(regionData).length} REGIONS</div>
        {Object.keys(stats).length > 0 && (
          <div className="text-xs mt-2 space-y-1">
            {Object.entries(stats).map(([cat, count]) => (
              <div key={cat} className="flex items-center gap-2">
                <div className="w-3 h-3 border border-black" style={{ backgroundColor: getRiskColor(cat) }} />
                <span>{cat}: {count}</span>
              </div>
            ))}
          </div>
        )}
      </div>

      {/* âœ… INDICATOR SELECTOR (Top-Right) */}
      <div className="absolute top-4 right-4 z-[1000] bg-white border-2 border-black p-4 shadow-[4px_4px_0_0_#000] font-mono">
        <div className="font-bold text-sm mb-3 uppercase border-b-2 border-black pb-2">SELECT INDICATOR</div>
        <select
          value={selectedIndicator}
          onChange={(e) => setSelectedIndicator(e.target.value as RiskIndicator)}
          className="w-full px-3 py-2 border-2 border-black rounded text-sm font-bold focus:outline-none"
        >
          <option value="conflict-proneness">âš ï¸ CONFLICT PRONENESS</option>
          <option value="conflict-risk">ðŸ”´ CONFLICT RISK</option>
          <option value="climate-risk">ðŸŸ¡ CLIMATE RISK</option>
          <option value="combined-risk">ðŸŸ£ COMBINED RISK</option>
        </select>
      </div>

      {/* âœ… RISK LEVELS LEGEND (Bottom-Right) */}
      <div className="absolute bottom-6 right-6 z-[1000] bg-white border-2 border-black p-4 shadow-[4px_4px_0_0_#000] font-mono">
        <h4 className="font-bold text-sm mb-3 uppercase border-b-2 border-black pb-2">RISK LEVELS</h4>
        <div className="space-y-2.5">
          {['EXTREME', 'VERY HIGH', 'HIGH', 'MODERATE', 'LOW'].map(level => (
            <div key={level} className="flex items-center gap-3">
              <div className="w-6 h-6 border-2 border-black" style={{ backgroundColor: getRiskColor(level) }}></div>
              <span className="text-xs font-bold uppercase">{level} {stats[level] ? `(${stats[level]})` : ''}</span>
            </div>
          ))}
        </div>
      </div>

      {!backendAvailable && (
        <div className="absolute top-4 right-4 z-[1000] bg-yellow-400 border-2 border-black p-3 font-mono text-xs max-w-xs shadow-[4px_4px_0_0_#000]">
          <div className="font-bold mb-1">âš  BACKEND OFFLINE</div>
          <div>Start backend on port 8000</div>
        </div>
      )}
    </div>
  )
}

// âœ… Helper function: Generate popup content
function getPopupContent(
  regionName: string,
  regionInfo: RegionData | undefined,
  indicator: RiskIndicator
): string {
  if (!regionInfo) {
    return `<div style="font-family: 'Courier New', monospace; min-width: 220px;">
      <h3 style="margin: 0 0 8px 0; font-size: 14px; font-weight: 700; text-transform: uppercase; border-bottom: 2px solid #000; padding-bottom: 6px;">
        ${regionName}
      </h3>
      <div style="color: #999; font-size: 12px;">NO DATA - Check backend</div>
    </div>`
  }

  let content = `<div style="font-family: 'Courier New', monospace; min-width: 240px;">
    <h3 style="margin: 0 0 8px 0; font-size: 14px; font-weight: 700; text-transform: uppercase; border-bottom: 2px solid #000; padding-bottom: 6px;">
      ${regionName}
    </h3>
    <div style="font-size: 12px;">`

  if (indicator === 'conflict-proneness') {
    const color = getRiskColor(regionInfo.proneness_level)
    content += `
      <div style="margin: 6px 0; padding: 4px; background: ${color}22;">
        <strong>CONFLICT PRONENESS:</strong> <span style="color: ${color};">${regionInfo.proneness_level}</span>
      </div>
      <div style="margin: 6px 0; padding: 4px;">
        <strong>SCORE:</strong> ${regionInfo.proneness_score.toFixed(1)}/10
      </div>
      <div style="margin: 6px 0; padding: 4px;">
        <strong>EVENTS:</strong> ${regionInfo.incidents}
      </div>
      <div style="margin: 6px 0; padding: 4px;">
        <strong>FATALITIES:</strong> ${regionInfo.fatalities}
      </div>
    `
  } else if (indicator === 'conflict-risk') {  // âœ… NEW
    const color = getRiskColor(regionInfo.conflict_risk_level)
    content += `
      <div style="margin: 6px 0; padding: 4px; background: ${color}22;">
        <strong>CONFLICT RISK:</strong> <span style="color: ${color};">${regionInfo.conflict_risk_level}</span>
      </div>
      <div style="margin: 6px 0; padding: 4px;">
        <strong>SCORE:</strong> ${regionInfo.conflict_risk_score.toFixed(1)}/10
      </div>
      <div style="margin: 6px 0; padding: 4px;">
        <strong>EVENTS:</strong> ${regionInfo.incidents}
      </div>
      <div style="margin: 6px 0; padding: 4px;">
        <strong>FATALITIES:</strong> ${regionInfo.fatalities}
      </div>
    `
  } else if (indicator === 'climate-risk') {
    const color = getRiskColor(regionInfo.climate_risk_level)
    content += `
      <div style="margin: 6px 0; padding: 4px; background: ${color}22;">
        <strong>CLIMATE RISK:</strong> <span style="color: ${color};">${regionInfo.climate_risk_level}</span>
      </div>
      <div style="margin: 6px 0; padding: 4px;">
        <strong>SCORE:</strong> ${regionInfo.climate_risk_score.toFixed(1)}/10
      </div>
    `
  } else if (indicator === 'combined-risk') {
    const avgScore = (regionInfo.proneness_score + regionInfo.climate_risk_score) / 2
    const color = getRiskColor(undefined, avgScore)
    const level = avgScore >= 7.5 ? 'EXTREME'
      : avgScore >= 6 ? 'VERY HIGH'
      : avgScore >= 4.5 ? 'HIGH'
      : avgScore >= 3 ? 'MODERATE' : 'LOW'
    content += `
      <div style="margin: 6px 0; padding: 4px; background: ${color}22;">
        <strong>COMBINED RISK:</strong> <span style="color: ${color};">${level}</span>
      </div>
      <div style="margin: 6px 0; padding: 4px;">
        <strong>SCORE:</strong> ${avgScore.toFixed(1)}/10
      </div>
      <div style="margin: 6px 0; padding: 4px;">
        <strong>CONFLICT:</strong> ${regionInfo.proneness_score.toFixed(1)} | <strong>CLIMATE:</strong> ${regionInfo.climate_risk_score.toFixed(1)}
      </div>
    `
  }

  content += `
    </div>
  </div>`

  return content
}

### ./frontend/src/components/map/SudanMap.tsx.old ###
'use client'

import React, { useEffect, useState, useRef } from 'react'
import L from 'leaflet'
import 'leaflet/dist/leaflet.css'

interface SudanMapProps {
  backendAvailable: boolean
  indicator: string
}

interface RegionData {
  name: string
  riskLevel: string
  riskScore: number
  incidents: number
  fatalities: number
  climateRiskLevel: string
  climateRiskScore: number
  combinedRiskScore: number
}

type RiskIndicator = 'conflict-risk' | 'climate-risk' | 'conflict-proneness' | 'combined-risk'

const SUDAN_CENTER: [number, number] = [15.5007, 32.5599]
const BACKEND_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:8000'

const getRegionName = (properties: any): string => {
  return properties.shapeName || properties.ADM1_EN || properties.name || 'Unknown'
}

const getRiskColor = (level: string, riskScore?: number): string => {
  const normalized = level.toString().toUpperCase().trim()
  
  // For combined risk, use score-based coloring
  if (riskScore !== undefined) {
    if (riskScore >= 7.5) return '#8B0000'
    if (riskScore >= 6) return '#DC143C'
    if (riskScore >= 4.5) return '#FF6347'
    if (riskScore >= 3) return '#FFA500'
    if (riskScore >= 1.5) return '#FFD700'
    return '#00A86B'
  }

  const colorMap: Record<string, string> = {
    'EXTREME': '#8B0000',
    'VERY HIGH': '#DC143C',
    'HIGH': '#FF6347',
    'SEVERE': '#FF4500',
    'ALERT': '#FFA500',
    'MODERATE': '#FFD700',
    'WARNING': '#FFFF00',
    'WATCH': '#90EE90',
    'LOW': '#00A86B',
    'NORMAL': '#90EE90',
  }
  return colorMap[normalized] || '#6b7280'
}

const normalizeRegionName = (name: string): string => {
  const nameMap: Record<string, string> = {
    'Abyei PCA': 'Abyei',
    'Gezira': 'Al Jazirah'
  }
  return nameMap[name] || name
}

export default function SudanMap({ backendAvailable, indicator: initialIndicator }: SudanMapProps) {
  const mapRef = useRef<L.Map | null>(null)
  const mapContainerRef = useRef<HTMLDivElement>(null)
  const geoJsonLayerRef = useRef<L.GeoJSON | null>(null)

  const [regionData, setRegionData] = useState<Record<string, RegionData>>({})
  const [loading, setLoading] = useState(true)
  const [stats, setStats] = useState<Record<string, number>>({})
  const [error, setError] = useState<string | null>(null)
  const [mapReady, setMapReady] = useState(false)
  const [selectedIndicator, setSelectedIndicator] = useState<RiskIndicator>('conflict-risk')

  // âœ… Fetch backend data
  useEffect(() => {
    const fetchData = async () => {
      console.log('ðŸ”µ [DATA FETCH] Starting...')
      console.log('ðŸ”µ Backend available:', backendAvailable)
      console.log('ðŸ”µ Backend URL:', BACKEND_URL)

      if (!backendAvailable) {
        console.log('âš ï¸ [DATA FETCH] Backend unavailable, skipping')
        setLoading(false)
        return
      }

      try {
        console.log(`ðŸ”µ [DATA FETCH] Fetching from ${BACKEND_URL}/api/conflict-proneness`)
        const response = await fetch(`${BACKEND_URL}/api/conflict-proneness`)

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`)
        }

        const data = await response.json()
        console.log('âœ… [DATA FETCH] Success! Received data:', data)

        // âœ… Handle both array and dict formats
        let regionsArray = Array.isArray(data) ? data : Object.values(data)

        if (!regionsArray || regionsArray.length === 0) {
          throw new Error('No region data received')
        }

        const regionMap: Record<string, RegionData> = {}

        regionsArray.forEach((region: any) => {
          const conflictLevel = (region.level || region.risk_level || 'UNKNOWN').toString().toUpperCase().trim()
          const climateLevel = (region.climate_risk_level || 'UNKNOWN').toString().toUpperCase().trim()
          const stateName = region.region
          const events = parseInt(region.events || 0)
          const fatalities = parseInt(region.fatalities || 0)
          const conflictScore = parseFloat(region.risk_score || 0)
          const climateScore = parseFloat(region.climate_risk_score || 0)
          const combinedScore = (conflictScore + climateScore) / 2

          regionMap[stateName] = {
            name: stateName,
            riskLevel: conflictLevel,
            riskScore: conflictScore,
            climateRiskLevel: climateLevel,
            climateRiskScore: climateScore,
            combinedRiskScore: combinedScore,
            incidents: events,
            fatalities
          }
        })

        console.log('âœ… [DATA FETCH] Processed regions:', Object.keys(regionMap).length)
        setRegionData(regionMap)
      } catch (err: any) {
        console.error('âŒ [DATA FETCH] Error:', err)
        setError(`Backend error: ${err.message}`)
      } finally {
        setLoading(false)
      }
    }

    fetchData()
  }, [backendAvailable, initialIndicator])

  // âœ… Initialize map
  useEffect(() => {
    const timer = setTimeout(() => {
      console.log('ðŸ—ºï¸ [MAP INIT] Starting...')

      if (!mapContainerRef.current) {
        console.error('âŒ [MAP INIT] Container ref is null')
        setError('Map container failed to load')
        return
      }

      if (mapRef.current) {
        console.log('âš ï¸ [MAP INIT] Map already exists')
        return
      }

      console.log('ðŸ—ºï¸ [MAP INIT] Creating Leaflet map...')
      const map = L.map(mapContainerRef.current, {
        center: SUDAN_CENTER,
        zoom: 6,
        zoomControl: true,
        scrollWheelZoom: true,
      })

      L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_nolabels/{z}/{x}/{y}{r}.png', {
        attribution: 'Â© OpenStreetMap Â© CARTO',
        subdomains: 'abcd',
        maxZoom: 19
      }).addTo(map)

      mapRef.current = map
      setMapReady(true)
      console.log('âœ… [MAP INIT] Map created successfully')
    }, 100)

    return () => {
      clearTimeout(timer)
      if (mapRef.current) {
        console.log('ðŸ—ºï¸ [MAP CLEANUP] Removing map')
        mapRef.current.remove()
        mapRef.current = null
        setMapReady(false)
      }
    }
  }, [])

  // âœ… Load GeoJSON
  useEffect(() => {
    console.log('ðŸ“ [GEOJSON] Loading trigger...')
    console.log('ðŸ“ Map ready:', mapReady)
    console.log('ðŸ“ GeoJSON layer exists:', !!geoJsonLayerRef.current)

    if (!mapReady || geoJsonLayerRef.current) {
      console.log('âš ï¸ [GEOJSON] Skipping: map not ready or layer already exists')
      return
    }

    console.log('ðŸ“ [GEOJSON] Fetching /data/sudan-states.geojson...')

    fetch('/data/sudan-states.geojson')
      .then(res => {
        console.log('ðŸ“ [GEOJSON] Response status:', res.status, res.statusText)
        if (!res.ok) throw new Error(`HTTP ${res.status}`)
        return res.json()
      })
      .then(geojsonData => {
        console.log('âœ… [GEOJSON] Loaded successfully')
        console.log('ðŸ“ [GEOJSON] Features count:', geojsonData.features?.length)
        console.log('ðŸ“ [GEOJSON] Backend data keys:', Object.keys(regionData).length)

        const geoJsonLayer = L.geoJSON(geojsonData, {
          style: (feature) => {
            if (!feature || !feature.properties) {
              return {
                fillColor: '#6b7280',
                weight: 2,
                opacity: 1,
                color: '#000000',
                fillOpacity: 0.3
              }
            }

            const geoJsonName = getRegionName(feature.properties)
            const normalizedName = normalizeRegionName(geoJsonName)
            const regionInfo = regionData[normalizedName]
            
            let fillColor = '#6b7280'
            if (regionInfo) {
              if (selectedIndicator === 'conflict-risk' || selectedIndicator === 'conflict-proneness') {
                fillColor = getRiskColor(regionInfo.riskLevel)
              } else if (selectedIndicator === 'climate-risk') {
                fillColor = getRiskColor(regionInfo.climateRiskLevel)
              } else {
                fillColor = getRiskColor('', regionInfo.combinedRiskScore)
              }
            }

            const style = {
              fillColor,
              weight: 2,
              opacity: 1,
              color: '#000000',
              fillOpacity: regionInfo ? 0.8 : 0.3
            }

            console.log(`ðŸŽ¨ [STYLE] ${geoJsonName} â†’ ${normalizedName} â†’ ${fillColor}`)
            return style
          },
          onEachFeature: (feature, layer) => {
            const geoJsonName = getRegionName(feature.properties)
            const normalizedName = normalizeRegionName(geoJsonName)
            const regionInfo = regionData[normalizedName]

            const popupContent = getPopupContent(geoJsonName, regionInfo, selectedIndicator)

            ;(layer as L.Path).bindPopup(popupContent, { className: 'brutalist-popup' })

            ;(layer as L.Path).on({
              mouseover: (e) => {
                const target = e.target as L.Path
                target.setStyle({ weight: 3, fillOpacity: 1 })
                target.bringToFront()
              },
              mouseout: (e) => {
                const target = e.target as L.Path
                let fillColor = '#6b7280'
                if (regionInfo) {
                  if (selectedIndicator === 'conflict-risk' || selectedIndicator === 'conflict-proneness') {
                    fillColor = getRiskColor(regionInfo.riskLevel)
                  } else if (selectedIndicator === 'climate-risk') {
                    fillColor = getRiskColor(regionInfo.climateRiskLevel)
                  } else {
                    fillColor = getRiskColor('', regionInfo.combinedRiskScore)
                  }
                }
                target.setStyle({
                  fillColor,
                  weight: 2,
                  fillOpacity: regionInfo ? 0.8 : 0.3
                })
              },
              click: () => (layer as L.Path).openPopup()
            })
          }
        }).addTo(mapRef.current!)

        geoJsonLayerRef.current = geoJsonLayer
        console.log('âœ… [GEOJSON] Layer added to map successfully')
      })
      .catch(err => {
        console.error('âŒ [GEOJSON] Error:', err)
        setError(`GeoJSON failed: ${err.message}`)
      })
  }, [mapReady, regionData, selectedIndicator])

  // âœ… Update colors when indicator changes
  useEffect(() => {
    console.log('ðŸŽ¨ [COLOR UPDATE] Trigger...')
    console.log('ðŸŽ¨ GeoJSON layer exists:', !!geoJsonLayerRef.current)
    console.log('ðŸŽ¨ Backend data count:', Object.keys(regionData).length)

    if (!geoJsonLayerRef.current || Object.keys(regionData).length === 0) {
      console.log('âš ï¸ [COLOR UPDATE] Skipping: no layer or no data')
      return
    }

    console.log(`ðŸŽ¨ [COLOR UPDATE] Switching to ${selectedIndicator}`)

    geoJsonLayerRef.current.eachLayer((layer: any) => {
      if (layer.feature) {
        const geoJsonName = getRegionName(layer.feature.properties)
        const normalizedName = normalizeRegionName(geoJsonName)
        const regionInfo = regionData[normalizedName]

        let fillColor = '#6b7280'
        if (regionInfo) {
          if (selectedIndicator === 'conflict-risk' || selectedIndicator === 'conflict-proneness') {
            fillColor = getRiskColor(regionInfo.riskLevel)
          } else if (selectedIndicator === 'climate-risk') {
            fillColor = getRiskColor(regionInfo.climateRiskLevel)
          } else {
            fillColor = getRiskColor('', regionInfo.combinedRiskScore)
          }
        }

        layer.setStyle({
          fillColor,
          weight: 2,
          opacity: 1,
          color: '#000000',
          fillOpacity: regionInfo ? 0.8 : 0.3
        })

        ;(layer as L.Path).setPopupContent(getPopupContent(geoJsonName, regionInfo, selectedIndicator))
      }
    })

    console.log(`âœ… [COLOR UPDATE] Complete!`)
  }, [selectedIndicator, regionData])

  // âœ… Calculate stats based on indicator
  const calculateStats = () => {
    const stats: Record<string, number> = {}
    Object.values(regionData).forEach(region => {
      let level = ''
      if (selectedIndicator === 'conflict-risk' || selectedIndicator === 'conflict-proneness') {
        level = region.riskLevel
      } else if (selectedIndicator === 'climate-risk') {
        level = region.climateRiskLevel
      } else {
        const score = region.combinedRiskScore
        if (score >= 7.5) level = 'EXTREME'
        else if (score >= 6) level = 'VERY HIGH'
        else if (score >= 4.5) level = 'HIGH'
        else if (score >= 3) level = 'MODERATE'
        else level = 'LOW'
      }
      stats[level] = (stats[level] || 0) + 1
    })
    return stats
  }

  if (loading) {
    return (
      <div className="flex items-center justify-center h-full bg-slate-900">
        <div className="text-white font-mono">
          <div className="text-4xl mb-4">ðŸ—ºï¸</div>
          <div className="text-xl font-bold">LOADING...</div>
        </div>
      </div>
    )
  }

  if (error) {
    return (
      <div className="flex items-center justify-center h-full bg-slate-900">
        <div className="text-red-400 font-mono max-w-md text-center">
          <div className="text-xl font-bold mb-2">ERROR</div>
          <div className="text-sm mb-4">{error}</div>
          <div className="text-xs text-gray-400">Check browser console (F12) for details</div>
        </div>
      </div>
    )
  }

  const currentStats = calculateStats()

  return (
    <div className="relative h-full">
      <div ref={mapContainerRef} className="absolute inset-0" />

      {/* âœ… REGION COUNT (Top-Left) */}
      <div className="absolute top-4 left-4 z-[1000] bg-white border-2 border-black px-4 py-2 shadow-[4px_4px_0_0_#000] font-mono">
        <div className="font-bold text-sm">{Object.keys(regionData).length} REGIONS</div>
        {Object.keys(currentStats).length > 0 && (
          <div className="text-xs mt-2 space-y-1">
            {Object.entries(currentStats).map(([cat, count]) => (
              <div key={cat} className="flex items-center gap-2">
                <div className="w-3 h-3 border border-black" style={{ backgroundColor: getRiskColor(cat) }} />
                <span>{cat}: {count}</span>
              </div>
            ))}
          </div>
        )}
      </div>

      {/* âœ… INDICATOR SELECTOR (Top-Right) with 4 options */}
      <div className="absolute top-4 right-4 z-[1000] bg-white border-2 border-black p-4 shadow-[4px_4px_0_0_#000] font-mono">
        <div className="font-bold text-sm mb-3 uppercase border-b-2 border-black pb-2">SELECT INDICATOR</div>
        <select
          value={selectedIndicator}
          onChange={(e) => setSelectedIndicator(e.target.value as RiskIndicator)}
          className="w-full px-3 py-2 border-2 border-black rounded text-sm font-bold focus:outline-none"
        >
          <option value="conflict-risk">ðŸ”´ CONFLICT RISK</option>
          <option value="climate-risk">ðŸŸ¡ CLIMATE RISK</option>
          <option value="conflict-proneness">âš ï¸ CONFLICT PRONENESS</option>
          <option value="combined-risk">ðŸŸ£ COMBINED RISK</option>
        </select>
      </div>

      {/* âœ… RISK LEVELS LEGEND (Bottom-Right) */}
      <div className="absolute bottom-6 right-6 z-[1000] bg-white border-2 border-black p-4 shadow-[4px_4px_0_0_#000] font-mono">
        <h4 className="font-bold text-sm mb-3 uppercase border-b-2 border-black pb-2">RISK LEVELS</h4>
        <div className="space-y-2.5">
          {['EXTREME', 'VERY HIGH', 'HIGH', 'MODERATE', 'LOW'].map(level => (
            <div key={level} className="flex items-center gap-3">
              <div className="w-6 h-6 border-2 border-black" style={{ backgroundColor: getRiskColor(level) }}></div>
              <span className="text-xs font-bold uppercase">{level} {currentStats[level] ? `(${currentStats[level]})` : ''}</span>
            </div>
          ))}
        </div>
      </div>

      {!backendAvailable && (
        <div className="absolute top-4 right-4 z-[1000] bg-yellow-400 border-2 border-black p-3 font-mono text-xs max-w-xs shadow-[4px_4px_0_0_#000]">
          <div className="font-bold mb-1">âš  BACKEND OFFLINE</div>
          <div>Start backend on port 8000</div>
        </div>
      )}
    </div>
  )
}

// âœ… Helper function: Generate popup content
function getPopupContent(
  regionName: string,
  regionInfo: RegionData | undefined,
  indicator: RiskIndicator
): string {
  if (!regionInfo) {
    return `<div style="font-family: 'Courier New', monospace; min-width: 220px;">
      <h3 style="margin: 0 0 8px 0; font-size: 14px; font-weight: 700; text-transform: uppercase; border-bottom: 2px solid #000; padding-bottom: 6px;">
        ${regionName}
      </h3>
      <div style="color: #999; font-size: 12px;">NO DATA - Check backend</div>
    </div>`
  }

  let content = `<div style="font-family: 'Courier New', monospace; min-width: 240px;">
    <h3 style="margin: 0 0 8px 0; font-size: 14px; font-weight: 700; text-transform: uppercase; border-bottom: 2px solid #000; padding-bottom: 6px;">
      ${regionName}
    </h3>
    <div style="font-size: 12px;">`

  if (indicator === 'conflict-risk') {
    const color = getRiskColor(regionInfo.riskLevel)
    content += `
      <div style="margin: 6px 0; padding: 4px; background: ${color}22;">
        <strong>CONFLICT RISK:</strong> <span style="color: ${color};">${regionInfo.riskLevel}</span>
      </div>
      <div style="margin: 6px 0; padding: 4px;">
        <strong>SCORE:</strong> ${regionInfo.riskScore.toFixed(1)}/10
      </div>
      <div style="margin: 6px 0; padding: 4px;">
        <strong>EVENTS:</strong> ${regionInfo.incidents}
      </div>
      <div style="margin: 6px 0; padding: 4px;">
        <strong>DEATHS:</strong> ${regionInfo.fatalities}
      </div>
    `
  } else if (indicator === 'climate-risk') {
    const color = getRiskColor(regionInfo.climateRiskLevel)
    content += `
      <div style="margin: 6px 0; padding: 4px; background: ${color}22;">
        <strong>CLIMATE RISK:</strong> <span style="color: ${color};">${regionInfo.climateRiskLevel}</span>
      </div>
      <div style="margin: 6px 0; padding: 4px;">
        <strong>SCORE:</strong> ${regionInfo.climateRiskScore.toFixed(1)}/10
      </div>
      <div style="margin: 6px 0; padding: 4px;">
        <strong>CONFLICT RISK:</strong> ${regionInfo.riskLevel}
      </div>
    `
  } else if (indicator === 'conflict-proneness') {
    const color = getRiskColor(regionInfo.riskLevel)
    content += `
      <div style="margin: 6px 0; padding: 4px; background: ${color}22;">
        <strong>CONFLICT PRONENESS:</strong> <span style="color: ${color};">${regionInfo.riskLevel}</span>
      </div>
      <div style="margin: 6px 0; padding: 4px;">
        <strong>SCORE:</strong> ${regionInfo.riskScore.toFixed(1)}/10
      </div>
      <div style="margin: 6px 0; padding: 4px;">
        <strong>EVENTS (6M):</strong> ${regionInfo.incidents}
      </div>
      <div style="margin: 6px 0; padding: 4px;">
        <strong>FATALITIES:</strong> ${regionInfo.fatalities}
      </div>
    `
  } else {
    const color = getRiskColor('', regionInfo.combinedRiskScore)
    const level = regionInfo.combinedRiskScore >= 7.5 ? 'EXTREME'
      : regionInfo.combinedRiskScore >= 6 ? 'VERY HIGH'
      : regionInfo.combinedRiskScore >= 4.5 ? 'HIGH'
      : regionInfo.combinedRiskScore >= 3 ? 'MODERATE' : 'LOW'
    content += `
      <div style="margin: 6px 0; padding: 4px; background: ${color}22;">
        <strong>COMBINED RISK:</strong> <span style="color: ${color};">${level}</span>
      </div>
      <div style="margin: 6px 0; padding: 4px;">
        <strong>SCORE:</strong> ${regionInfo.combinedRiskScore.toFixed(1)}/10
      </div>
      <div style="margin: 6px 0; padding: 4px;">
        <strong>CONFLICT:</strong> ${regionInfo.riskScore.toFixed(1)} | <strong>CLIMATE:</strong> ${regionInfo.climateRiskScore.toFixed(1)}
      </div>
    `
  }

  content += `
    </div>
  </div>`

  return content
}

### ./frontend/src/lib/api.ts ###
// src/lib/api.ts
const API_BASE_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:8000';

// âœ… Match backend response exactly
interface AnalyticsResponse {
  summary: {
    total_regions: number;
    avg_conflict_proneness: number;
    avg_climate_risk: number;
    total_events: number;
    total_fatalities: number;
    highest_risk_region: string;
    high_proneness_count: number;
  };
  indicator_averages: {
    avg_incidents: number;
    avg_causes_pct: number;
    avg_actors: number;
    avg_trend: number;
  };
  distribution: {
    EXTREME: number;
    VERY_HIGH: number;
    HIGH: number;
    MODERATE: number;
    LOW: number;
  };
  risk_distribution: {
    climate: Record<string, number>;
    conflict: Record<string, number>;
  };
  top_regions: Array<{
    region: string;
    climate_risk_score: number;
    political_risk_score: number;
    cdi_category: string;
    risk_category: string;
    events_6m: number;
    fatalities_6m: number;
  }>;
  regional_data: Array<{
    region: string;
    climate_risk_score: number;
    political_risk_score: number;
    events_6m: number;
    fatalities_6m: number;
  }>;
}

// âœ… FIXED: Added conflict_risk_score and conflict_risk_level
interface Region {
  region: string;
  climate_risk_score: number;
  cdi_category: string;
  political_risk_score: number;
  risk_category: string;
  conflict_risk_score: number;        // âœ… NEW
  conflict_risk_level: string;        // âœ… NEW
  bivariate_category: string;
  events_6m: number;
  fatalities_6m: number;
  trend: string;
}

interface RegionsResponse {
  regions: Region[];
  total_count: number;
  risk_summary: {
    climate: Record<string, number>;
    conflict: Record<string, number>;
  };
}

interface DashboardStats {
  summary: {
    conflict_events: number;
    states_analyzed: number;
    risk_assessments: number;
    data_confidence: number;
  };
  quick_insights: {
    highest_risk_state: string;
    active_alerts: number;
    alert_breakdown: {
      high: number;
      very_high: number;
      extreme: number;
    };
    trend: {
      direction: string;
      percentage: number;
    };
  };
  risk_distribution: {
    climate: Record<string, number>;
    conflict: Record<string, number>;
  };
  metrics: {
    total_events: number;
    total_fatalities: number;
    avg_climate_risk: number;
    avg_conflict_proneness: number;
  };
}

class CRAMAPIService {
  private async fetchWithTimeout<T>(url: string, timeout = 10000): Promise<T> {
    const controller = new AbortController();
    const id = setTimeout(() => controller.abort(), timeout);

    try {
      const response = await fetch(url, {
        signal: controller.signal,
        cache: 'no-store',
      });
      clearTimeout(id);

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      return await response.json();
    } catch (error) {
      clearTimeout(id);
      if (error instanceof Error && error.name === 'AbortError') {
        throw new Error('Request timeout');
      }
      throw error;
    }
  }

  async getAnalytics(): Promise<AnalyticsResponse> {
    return this.fetchWithTimeout(`${API_BASE_URL}/api/analytics`);
  }

  async getRegions(): Promise<RegionsResponse> {
    return this.fetchWithTimeout(`${API_BASE_URL}/api/regions`);
  }

  async getDashboardStats(): Promise<DashboardStats> {
    return this.fetchWithTimeout(`${API_BASE_URL}/api/dashboard`);
  }
}

export const cramAPI = new CRAMAPIService();
export type { AnalyticsResponse, Region, RegionsResponse, DashboardStats };

### ./frontend/src/lib/api.ts.old ###
// src/lib/api.ts
const API_BASE_URL = process.env.NEXT_PUBLIC_BACKEND_URL || 'http://localhost:8000';

// âœ… Match backend response exactly
interface AnalyticsResponse {
  summary: {
    total_regions: number;
    avg_conflict_proneness: number;  // Fixed: was avg_conflict_risk
    avg_climate_risk: number;
    total_events: number;
    total_fatalities: number;
    highest_risk_region: string;
    high_proneness_count: number;
  };
  indicator_averages: {
    avg_incidents: number;
    avg_causes_pct: number;
    avg_actors: number;
    avg_trend: number;
  };
  distribution: {
    EXTREME: number;
    VERY_HIGH: number;
    HIGH: number;
    MODERATE: number;
    LOW: number;
  };
  risk_distribution: {
    climate: Record<string, number>;
    conflict: Record<string, number>;
  };
  top_regions: Array<{
    region: string;
    climate_risk_score: number;
    political_risk_score: number;
    cdi_category: string;
    risk_category: string;
    events_6m: number;
    fatalities_6m: number;
  }>;
  regional_data: Array<{
    region: string;
    climate_risk_score: number;
    political_risk_score: number;
    events_6m: number;
    fatalities_6m: number;
  }>;
}

interface Region {
  region: string;
  climate_risk_score: number;
  cdi_category: string;
  political_risk_score: number;
  risk_category: string;
  bivariate_category: string;
  events_6m: number;
  fatalities_6m: number;
  trend: string;
}

interface RegionsResponse {
  regions: Region[];
  total_count: number;
  risk_summary: {
    climate: Record<string, number>;
    conflict: Record<string, number>;
  };
}

interface DashboardStats {
  summary: {
    conflict_events: number;
    states_analyzed: number;
    risk_assessments: number;
    data_confidence: number;
  };
  quick_insights: {
    highest_risk_state: string;
    active_alerts: number;
    alert_breakdown: {
      high: number;
      very_high: number;
      extreme: number;
    };
    trend: {
      direction: string;
      percentage: number;
    };
  };
  risk_distribution: {
    climate: Record<string, number>;
    conflict: Record<string, number>;
  };
  metrics: {
    total_events: number;
    total_fatalities: number;
    avg_climate_risk: number;
    avg_conflict_proneness: number;  // Fixed: was avg_conflict_risk
  };
}

class CRAMAPIService {
  private async fetchWithTimeout<T>(url: string, timeout = 10000): Promise<T> {
    const controller = new AbortController();
    const id = setTimeout(() => controller.abort(), timeout);

    try {
      const response = await fetch(url, {
        signal: controller.signal,
        cache: 'no-store',
      });
      clearTimeout(id);

      if (!response.ok) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }

      return await response.json();
    } catch (error) {
      clearTimeout(id);
      if (error instanceof Error && error.name === 'AbortError') {
        throw new Error('Request timeout');
      }
      throw error;
    }
  }

  async getAnalytics(): Promise<AnalyticsResponse> {
    return this.fetchWithTimeout(`${API_BASE_URL}/api/analytics`);
  }

  async getRegions(): Promise<RegionsResponse> {
    return this.fetchWithTimeout(`${API_BASE_URL}/api/regions`);
  }

  async getDashboardStats(): Promise<DashboardStats> {
    return this.fetchWithTimeout(`${API_BASE_URL}/api/dashboard`);
  }
}

export const cramAPI = new CRAMAPIService();
export type { AnalyticsResponse, Region, RegionsResponse, DashboardStats };

### ./frontend/src/middleware.ts ###
import { clerkMiddleware, createRouteMatcher } from "@clerk/nextjs/server";

const isPublicRoute = createRouteMatcher([
  '/',
  '/sign-in(.*)',
  '/sign-up(.*)',
]);

export default clerkMiddleware(async (auth, req) => {
  if (!isPublicRoute(req)) {
    await auth.protect();
  }
});

export const config = {
  matcher: [
    '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
    '/(api|trpc)(.*)',
  ],
};

### ./frontend/src/services/api.ts ###
import axios, { AxiosInstance } from 'axios';

const API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:8000';

const apiClient: AxiosInstance = axios.create({
  baseURL: API_BASE_URL,
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Conflict Proneness API
export const conflictPronenessAPI = {
  // Get all regions with conflict proneness scores
  getRegions: async () => {
    const response = await apiClient.get('/api/alerts/conflict-proneness');
    return response.data;
  },

  // Get all alerts sorted by proneness
  getAlerts: async (severity: string = 'ALL', limit: number = 100) => {
    const response = await apiClient.get('/api/alerts', {
      params: { severity, limit },
    });
    return response.data;
  },

  // Get dashboard statistics
  getDashboardStats: async () => {
    const response = await apiClient.get('/api/alerts/dashboard-stats');
    return response.data;
  },

  // Get full dashboard overview
  getDashboard: async () => {
    const response = await apiClient.get('/api/dashboard');
    return response.data;
  },
};

export default apiClient;

### ./frontend/src/utils/regionNameMapping.ts ###
export const regionNameMapping: Record<string, string> = {
  'Abyei PCA': 'Abyei',
  'Gezira': 'Al Jazirah',  // â† THE KEY FIX!
  'Blue Nile': 'Blue Nile',
  'Central Darfur': 'Central Darfur',
  'East Darfur': 'East Darfur',
  'Gedaref': 'Gedaref',
  'Kassala': 'Kassala',
  'Khartoum': 'Khartoum',
  'North Darfur': 'North Darfur',
  'North Kordofan': 'North Kordofan',
  'Northern': 'Northern',
  'Red Sea': 'Red Sea',
  'River Nile': 'River Nile',
  'Sennar': 'Sennar',
  'South Darfur': 'South Darfur',
  'South Kordofan': 'South Kordofan',
  'West Darfur': 'West Darfur',
  'West Kordofan': 'West Kordofan',
  'White Nile': 'White Nile',
}

export function normalizeRegionName(geoJsonName: string): string {
  return regionNameMapping[geoJsonName] || geoJsonName
}

### ./frontend/tailwind.config.js ###
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      colors: {
        background: 'var(--background)',
        foreground: 'var(--foreground)',
        surface: 'var(--surface)',
        border: 'var(--border)',

        // Brand colors - UPDATED
        'brand-orange': '#F37420',  // Conflict Risk / Primary brand
        'brand-teal': '#049787',    // Climate Risk / Secondary brand

        // Risk colors - UPDATED to use brand colors
        'conflict': '#F37420',
        'climate': '#049787',
        'risk-low': '#22c55e',
        'risk-medium': '#fbbf24',
        'risk-high': '#F37420',
        'risk-severe': '#dc2626',
      },

      // Use Inter font - UPDATED
      fontFamily: {
        sans: ['var(--font-inter)', 'Inter', '-apple-system', 'BlinkMacSystemFont', 'Segoe UI', 'Roboto', 'sans-serif'],
        mono: ['"Courier New"', 'monospace'],
      },

      // Keep sharp borders (no changes)
      borderRadius: {
        'none': '0',
        'DEFAULT': '0',
        'sm': '0',
        'md': '0',
        'lg': '0',
        'xl': '0',
        '2xl': '0',
        '3xl': '0',
        'full': '0',
      },

      // Standard borders (no changes)
      borderWidth: {
        'DEFAULT': '1px',
        '0': '0',
        '2': '2px',
        '3': '3px',
        '4': '4px',
      },

      // Letter spacing for uppercase text (no changes)
      letterSpacing: {
        tighter: '-0.05em',
        tight: '-0.025em',
        normal: '0',
        wide: '0.025em',
        wider: '0.05em',
        widest: '0.1em',
      },
    },
  },
  plugins: [],
}

### ./frontend/tsconfig.json ###
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": [
        "./src/*"
      ]
    }
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx",
    ".next/types/**/*.ts",
    ".next/dev/types/**/*.ts",
    "**/*.mts"
  ],
  "exclude": [
    "node_modules"
  ]
}

### ./output.txt ###

### ./scripts/calculate_conflict_proneness.py ###
"""
âœ… CONFLICT PRONENESS v2 - ALL 4 INDICATORS (FIXED)
1. INCIDENTS (35%) - event frequency
2. CAUSES (30%) - % of political/communal/resource
3. ACTORS (20%) - organizational complexity
4. TREND (15%) - recent change
"""

import pandas as pd
import numpy as np
from pathlib import Path

PROJECT_ROOT = Path(__file__).parent.parent
DATA_DIR = PROJECT_ROOT / "data" / "processed"

ACLED_FILE = DATA_DIR / "acled_with_causes.csv"
CLIMATE_FILE = DATA_DIR / "climate_risk_cdi_v2_real.csv"
OUTPUT_FILE = DATA_DIR / "conflict_proneness_v2.csv"

WEIGHTS = {
    'incidents': 0.35,
    'causes': 0.30,
    'actors': 0.20,
    'trend': 0.15,
    'climate': 0.25,
}

def count_unique_actors(state_data):
    """Count unique actor combinations (organizations involved)"""
    actors = set()
    
    # Try ACTOR field
    if 'ACTOR1' in state_data.columns:
        actors.update(state_data['ACTOR1'].dropna().unique())
    if 'ACTOR2' in state_data.columns:
        actors.update(state_data['ACTOR2'].dropna().unique())
    
    # Fallback: use SUB_EVENT_TYPE as proxy for actor differentiation
    if len(actors) <= 1:
        sub_events = state_data['SUB_EVENT_TYPE'].dropna().unique()
        return max(len(sub_events), 1)
    
    return max(len(actors), 1)

def calculate_all_4_indicators(df_acled):
    """Calculate all 4 sub-indicators per state"""
    indicators_by_state = {}
    
    for admin1 in df_acled['ADMIN1'].unique():
        state_data = df_acled[df_acled['ADMIN1'] == admin1]
        
        # INDICATOR 1: INCIDENTS
        total_events = len(state_data)
        
        # INDICATOR 2: CAUSES (% of classified high-risk events)
        high_risk_events = state_data['cause_class'].notna().sum()
        causes_pct = (high_risk_events / max(total_events, 1)) * 100
        
        # INDICATOR 3: ACTORS (unique organizations/groups)
        num_actors = count_unique_actors(state_data)
        
        # INDICATOR 4: TREND (6-month comparison)
        if 'event_date' in state_data.columns:
            state_data_sorted = state_data.sort_values('event_date')
            mid_point = len(state_data_sorted) // 2
            first_half = mid_point
            second_half = len(state_data_sorted) - mid_point
            trend_delta = second_half - first_half
        else:
            trend_delta = 0
        
        fatalities = state_data['FATALITIES'].sum() if 'FATALITIES' in state_data.columns else 0
        
        indicators_by_state[admin1] = {
            'incidents': total_events,
            'causes_pct': causes_pct,
            'actors': num_actors,
            'trend_delta': trend_delta,
            'high_risk_events': high_risk_events,
            'fatalities': int(fatalities),
            'fatality_rate': fatalities / max(total_events, 1)
        }
    
    return indicators_by_state


def normalize_to_10(values):
    """Normalize to 0-10 scale"""
    if len(values) == 0 or values.max() == values.min():
        return np.ones_like(values) * 5.0
    return 10.0 * (values - values.min()) / (values.max() - values.min())


def calculate_proneness_score(incidents, causes, actors, trend, climate):
    """Weighted CP score combining all 4 indicators"""
    score = (
        WEIGHTS['incidents'] * incidents +
        WEIGHTS['causes'] * causes +
        WEIGHTS['actors'] * actors +
        WEIGHTS['trend'] * trend +
        WEIGHTS['climate'] * climate
    )
    return round(min(10.0, max(0.0, score)), 2)


def main():
    print("=" * 70)
    print("âœ… CONFLICT PRONENESS v2 - ALL 4 INDICATORS (FIXED ACTORS)")
    print("=" * 70)

    print(f"\nðŸ“¥ Loading ACLED data from: {ACLED_FILE}")
    df_acled = pd.read_csv(ACLED_FILE)
    df_acled['event_date'] = pd.to_datetime(df_acled['event_date'])
    print(f"   Events: {len(df_acled):,}")

    print(f"\nðŸ“¥ Loading climate data from: {CLIMATE_FILE}")
    df_climate = pd.read_csv(CLIMATE_FILE)
    print(f"   States: {len(df_climate):,}")

    print("\nðŸ”„ Calculating 4 indicators...")
    indicators_by_state = calculate_all_4_indicators(df_acled)
    print(f"   âœ… Calculated for {len(indicators_by_state)} states")

    print("\nðŸ”„ Computing Conflict Proneness scores...")
    results = []
    
    for _, climate_row in df_climate.iterrows():
        admin1_name = str(climate_row.get('ADM1_NAME', '')).strip()
        
        ind = indicators_by_state.get(admin1_name, {
            'incidents': 0, 'causes_pct': 0, 'actors': 1, 'trend_delta': 0,
            'high_risk_events': 0, 'fatalities': 0, 'fatality_rate': 0.0
        })
        
        results.append({
            'ADM1_NAME': admin1_name,
            'region': admin1_name,
            'incidents': ind['incidents'],
            'causes_pct': ind['causes_pct'],
            'num_actors': ind['actors'],
            'trend_delta': ind['trend_delta'],
            'high_risk_events': ind['high_risk_events'],
            'fatalities': ind['fatalities'],
            'fatality_rate': ind['fatality_rate'],
            'climate_risk_score': float(climate_row.get('climate_risk_score', 0)),
            'cdi_category': climate_row.get('cdi_category', 'UNKNOWN'),
            '_incidents_norm': 0,
            '_causes_norm': 0,
            '_actors_norm': 0,
            '_trend_norm': 0,
            '_climate_norm': 0,
        })
    
    df_results = pd.DataFrame(results)
    
    # Normalize
    print("   Normalizing components...")
    df_results['_incidents_norm'] = normalize_to_10(df_results['incidents'].values.astype(float))
    df_results['_causes_norm'] = normalize_to_10(df_results['causes_pct'].values.astype(float))
    df_results['_actors_norm'] = normalize_to_10(df_results['num_actors'].values.astype(float))
    trend_vals = df_results['trend_delta'].values + abs(df_results['trend_delta'].values.min())
    df_results['_trend_norm'] = normalize_to_10(trend_vals.astype(float))
    df_results['_climate_norm'] = normalize_to_10(df_results['climate_risk_score'].values.astype(float))
    
    # Calculate CP
    print("   Computing weighted scores...")
    df_results['conflict_proneness'] = df_results.apply(
        lambda row: calculate_proneness_score(
            row['_incidents_norm'], row['_causes_norm'], row['_actors_norm'],
            row['_trend_norm'], row['_climate_norm']
        ),
        axis=1
    )
    
    def get_level(score):
        if score >= 8: return "EXTREME"
        elif score >= 6: return "VERY HIGH"
        elif score >= 4: return "HIGH"
        elif score >= 2: return "MODERATE"
        else: return "LOW"
    
    df_results['proneness_level'] = df_results['conflict_proneness'].apply(get_level)
    df_results = df_results.sort_values('conflict_proneness', ascending=False)
    
    # Display
    print("\nðŸ“‹ TOP 10 Regions (ALL 4 Indicators):")
    print(f"   {'Region':<20} {'CP':>8} {'Level':>12} {'Inc':>6} {'Cause%':>8} {'Act':>4} {'Trend':>6}")
    print("   " + "-" * 75)
    
    for _, row in df_results.head(10).iterrows():
        print(f"   {row['ADM1_NAME']:<20} {row['conflict_proneness']:>8.1f} "
              f"{row['proneness_level']:>12} {row['incidents']:>6} "
              f"{row['causes_pct']:>7.1f}% {row['num_actors']:>4} {row['trend_delta']:>+6}")
    
    print("\nðŸ“Š Summary:")
    print(f"   Mean CP: {df_results['conflict_proneness'].mean():.2f}")
    print(f"   Total Fatalities: {df_results['fatalities'].sum():,}")
    
    # Save
    print(f"\nðŸ’¾ Saving to: {OUTPUT_FILE}")
    DATA_DIR.mkdir(parents=True, exist_ok=True)
    
    output_cols = [
        'ADM1_NAME', 'region', 'conflict_proneness', 'proneness_level',
        'incidents', 'causes_pct', 'num_actors', 'trend_delta', 'high_risk_events',
        'fatalities', 'fatality_rate', 'climate_risk_score', 'cdi_category'
    ]
    df_results[output_cols].to_csv(OUTPUT_FILE, index=False)
    print(f"   âœ… Saved {len(df_results)} regions")
    print("\n" + "=" * 70)

if __name__ == "__main__":
    main()

### ./scripts/calculate_conflict_risk_simple.py ###
"""
âœ… CONFLICT RISK - Simple Incident Count
Uses SAME data source as CP v2 (acled_with_causes.csv)
"""

import pandas as pd
import numpy as np
from pathlib import Path

PROJECT_ROOT = Path(__file__).parent.parent
DATA_DIR = PROJECT_ROOT / "data" / "processed"

ACLED_FILE = DATA_DIR / "acled_with_causes.csv"
OUTPUT_FILE = DATA_DIR / "conflict_risk_simple.csv"

def normalize_to_10(values):
    """Normalize to 0-10 scale"""
    if len(values) == 0 or values.max() == values.min():
        return np.ones_like(values) * 5.0
    return 10.0 * (values - values.min()) / (values.max() - values.min())

def get_level(score):
    """Convert score to risk level"""
    if score >= 8: return "EXTREME"
    elif score >= 6: return "VERY HIGH"
    elif score >= 4: return "HIGH"
    elif score >= 2: return "MODERATE"
    else: return "LOW"

def main():
    print("=" * 70)
    print("âœ… CONFLICT RISK - INCIDENT FREQUENCY (same ACLED as CP v2)")
    print("=" * 70)

    print(f"\nðŸ“¥ Loading ACLED (processed): {ACLED_FILE}")
    df_acled = pd.read_csv(ACLED_FILE)
    print(f"   Total events: {len(df_acled):,}")

    print("\nðŸ”„ Computing Conflict Risk by state...")

    # âœ… FIXED: Iterate over ACLED states (not climate data)
    results = []
    for admin1 in sorted(df_acled['ADMIN1'].unique()):
        state_data = df_acled[df_acled['ADMIN1'] == admin1]
        
        incidents = len(state_data)
        fatalities = int(state_data['FATALITIES'].sum())
        
        print(f"   {admin1:<20} {incidents:>6} incidents, {fatalities:>6} fatalities")

        results.append({
            'region': admin1,
            'incidents': incidents,
            'fatalities': fatalities,
        })

    df_results = pd.DataFrame(results)
    
    print(f"\n   Total states: {len(df_results)}")

    # Normalize to 0-10
    print("\nðŸ”„ Normalizing scores...")
    incidents_norm = normalize_to_10(df_results['incidents'].values.astype(float))
    fatalities_norm = normalize_to_10(df_results['fatalities'].values.astype(float))

    # Weighted combination: 70% incidents, 30% fatalities
    df_results['conflict_risk_score'] = (0.7 * incidents_norm + 0.3 * fatalities_norm).round(2)
    df_results['conflict_risk_level'] = df_results['conflict_risk_score'].apply(get_level)
    df_results = df_results.sort_values('conflict_risk_score', ascending=False)

    print(f"\nðŸ“‹ TOP 10 by Conflict Risk:")
    print(f"   {'Region':<20} {'Score':>8} {'Level':>12} {'Incidents':>10} {'Fatalities':>10}")
    print("   " + "-" * 65)
    
    for _, row in df_results.head(10).iterrows():
        print(f"   {row['region']:<20} {row['conflict_risk_score']:>8.1f} "
              f"{row['conflict_risk_level']:>12} {row['incidents']:>10} {row['fatalities']:>10}")

    print(f"\nðŸ“Š Summary:")
    print(f"   Mean Risk Score: {df_results['conflict_risk_score'].mean():.2f}")
    print(f"   States analyzed: {len(df_results)}")
    print(f"   Total incidents: {df_results['incidents'].sum():,}")
    print(f"   Total fatalities: {df_results['fatalities'].sum():,}")
    
    print(f"\nðŸ’¾ Saving to: {OUTPUT_FILE}")
    DATA_DIR.mkdir(parents=True, exist_ok=True)
    
    output_cols = ['region', 'conflict_risk_score', 'conflict_risk_level', 'incidents', 'fatalities']
    df_results[output_cols].to_csv(OUTPUT_FILE, index=False)
    print(f"   âœ… Saved {len(df_results)} regions")
    
    print("\n" + "=" * 70)

if __name__ == "__main__":
    main()

### ./scripts/classify_causes.py ###
"""
âœ… ACLED Event Classification - Political, Communal, Resource
For Conflict Proneness calculation (part of 4-indicator model)
"""

import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from pathlib import Path

PROJECT_ROOT = Path(__file__).parent.parent
DATA_DIR = PROJECT_ROOT / "data" / "processed"
ACLED_FILE = PROJECT_ROOT / "data" / "raw" / "Africa_aggregated_data_up_to-2025-10-18.xlsx"
OUTPUT_FILE = DATA_DIR / "acled_with_causes.csv"

END_DATE = datetime(2025, 10, 31)
START_DATE = END_DATE - timedelta(days=365)

CAUSE_MAP = {
    "Armed clash": "political", "Attack": "political",
    "Mob violence": "communal", "Violent demonstration": "communal",
    "Excessive force against protesters": "communal",
    "Looting/property destruction": None, "Peaceful protest": None,
    "Agreement": "exclude", "Arrests": "exclude",
}

RESOURCE_KEYWORDS = ["land", "pasture", "water", "grazing", "livestock", "cattle", "herder", "farmer", "crop"]

def classify_cause(row):
    sub_event = row.get('SUB_EVENT_TYPE', '')
    event_type = row.get('EVENT_TYPE', '')
    disorder_type = str(row.get('DISORDER_TYPE', '')).lower()
    notes = str(row.get('NOTES', '')).lower()
    
    cause = CAUSE_MAP.get(sub_event)
    if cause == "exclude": return None
    if cause: return cause
    
    combined_text = disorder_type + " " + notes
    if any(kw in combined_text for kw in RESOURCE_KEYWORDS): return "resource"
    if event_type == "Protests": return "communal" if any(kw in combined_text for kw in RESOURCE_KEYWORDS) else "communal"
    if event_type == "Violence against civilians": return "political"
    return None

def main():
    print("=" * 70)
    print("âœ… CLASSIFY CAUSES")
    print("=" * 70)

    df = pd.read_excel(ACLED_FILE)
    print(f"\nðŸ“¥ Loaded: {len(df):,} events")

    df_sudan = df[df['COUNTRY'].str.lower() == 'sudan'].copy()
    print(f"ðŸ” Sudan: {len(df_sudan):,} events")

    df_sudan['event_date'] = pd.to_datetime(df_sudan['WEEK'])
    df_filtered = df_sudan[
        (df_sudan['event_date'] >= START_DATE) &
        (df_sudan['event_date'] <= END_DATE)
    ].copy()
    print(f"ðŸ“… Filtered ({START_DATE.date()} to {END_DATE.date()}): {len(df_filtered):,} events")

    df_filtered['cause_class'] = df_filtered.apply(classify_cause, axis=1)

    print("\nðŸ“Š Classification:")
    for cause, count in df_filtered['cause_class'].value_counts(dropna=False).items():
        label = cause if pd.notna(cause) else "Not classified"
        print(f"   {label}: {count:,}")

    DATA_DIR.mkdir(parents=True, exist_ok=True)
    df_filtered.to_csv(OUTPUT_FILE, index=False)
    print(f"\nðŸ’¾ Saved to: {OUTPUT_FILE}")
    print("=" * 70)

if __name__ == "__main__":
    main()

### ./scripts/gdelt/analyze_goldstein_trends.py ###
# scripts/gdelt/analyze_goldstein_trends.py
"""
Analyze Goldstein Scale trends to detect escalation
Uses the CSV file generated by fetch_sudan_events.py
"""
import pandas as pd
import numpy as np
from datetime import datetime
import os
import glob

def load_latest_gdelt_data():
    """Load the most recent GDELT Sudan events CSV"""
    gdelt_files = glob.glob('data/gdelt/sudan_events_*.csv')

    if not gdelt_files:
        raise FileNotFoundError("No GDELT data found. Run fetch_sudan_events.py first!")

    # Get most recent file
    latest_file = max(gdelt_files, key=os.path.getctime)
    print(f"ðŸ“‚ Loading: {latest_file}")

    df = pd.read_csv(latest_file)
    df['date'] = pd.to_datetime(df['date'])

    return df

def calculate_escalation_risk(df):
    """
    Calculate escalation risk scores by location
    Based on Goldstein trends, event frequency, and media attention
    """
    print("\nðŸ” Analyzing escalation patterns...\n")

    # Clean location names (some have duplicates due to spelling)
    df['location_clean'] = df['location'].str.strip()

    # Group by location
    location_stats = []

    for location in df['location_clean'].unique():
        loc_data = df[df['location_clean'] == location].sort_values('date')

        if len(loc_data) < 2:
            continue

        # Calculate metrics
        avg_goldstein = loc_data['goldstein'].mean()
        min_goldstein = loc_data['goldstein'].min()
        event_count = len(loc_data)
        media_mentions = loc_data['num_mentions'].sum()

        # Goldstein trend (negative = escalating)
        goldstein_trend = loc_data['goldstein'].diff().mean()

        # Recent vs older (split data in half)
        split_point = len(loc_data) // 2
        recent_avg = loc_data.iloc[split_point:]['goldstein'].mean()
        older_avg = loc_data.iloc[:split_point]['goldstein'].mean()
        change = recent_avg - older_avg

        # Escalation Risk Score (0-10)
        # Higher = more dangerous
        risk_score = (
            max(0, -avg_goldstein) * 0.4 +        # Negative Goldstein = conflict
            max(0, -goldstein_trend) * 0.3 +      # Declining trend = escalation
            min(10, event_count / 5) * 0.2 +      # More events = more attention
            max(0, -change) * 0.1                 # Getting worse over time
        )

        # Classify risk level
        if risk_score >= 7:
            risk_level = "CRITICAL"
        elif risk_score >= 5:
            risk_level = "HIGH"
        elif risk_score >= 3:
            risk_level = "MODERATE"
        else:
            risk_level = "LOW"

        location_stats.append({
            'location': location,
            'escalation_risk': min(10, risk_score),
            'risk_level': risk_level,
            'avg_goldstein': avg_goldstein,
            'goldstein_trend': goldstein_trend,
            'event_count': event_count,
            'media_mentions': media_mentions,
            'recent_change': change,
            'first_seen': loc_data['date'].min(),
            'last_seen': loc_data['date'].max()
        })

    risk_df = pd.DataFrame(location_stats).sort_values('escalation_risk', ascending=False)

    return risk_df

def generate_hourly_timeline(df):
    """Generate hourly Goldstein timeline for charts (FIXED)"""
    # Floor timestamps to nearest hour
    df['hour'] = df['date'].dt.floor('H')
    
    # Create complete 24-hour range
    end_time = pd.Timestamp.now().floor('H')
    start_time = end_time - pd.Timedelta(hours=24)
    all_hours = pd.date_range(start=start_time, end=end_time, freq='H')
    
    # Group by hour and aggregate
    hourly = df[df['hour'] >= start_time].groupby('hour').agg({
        'goldstein': 'mean',
        'event_code': 'count',
        'num_mentions': 'sum'
    }).reset_index()
    
    # Merge with complete hour range to fill gaps
    hourly_complete = pd.DataFrame({'hour': all_hours})
    hourly_complete = hourly_complete.merge(hourly, on='hour', how='left')
    
    # Fill missing hours with 0
    hourly_complete['goldstein'] = hourly_complete['goldstein'].fillna(0)
    hourly_complete['event_code'] = hourly_complete['event_code'].fillna(0).astype(int)
    hourly_complete['num_mentions'] = hourly_complete['num_mentions'].fillna(0).astype(int)
    
    # Rename columns
    hourly_complete.columns = ['timestamp', 'avg_goldstein', 'event_count', 'mentions']
    
    return hourly_complete

def main():
    print("=" * 70)
    print("GOLDSTEIN SCALE TREND ANALYSIS")
    print("=" * 70)

    # Load data
    df = load_latest_gdelt_data()
    print(f"âœ… Loaded {len(df)} events")
    print(f"   Date range: {df['date'].min()} â†’ {df['date'].max()}\n")

    # Calculate escalation risks
    risk_df = calculate_escalation_risk(df)

    # Save results
    os.makedirs('data/processed', exist_ok=True)
    risk_file = f'data/processed/goldstein_escalation_risk_{datetime.now().strftime("%Y%m%d")}.csv'
    risk_df.to_csv(risk_file, index=False)

    # Display results
    print("=" * 70)
    print("ðŸš¨ ESCALATION RISK RANKING (Top 10)")
    print("=" * 70)

    for i, row in risk_df.head(10).iterrows():
        print(f"\n{i+1}. {row['location']}")
        print(f"   Risk Score:      {row['escalation_risk']:.1f}/10 [{row['risk_level']}]")
        print(f"   Avg Goldstein:   {row['avg_goldstein']:.2f} (negative = conflict)")
        print(f"   Trend:           {row['goldstein_trend']:.2f} (negative = worsening)")
        print(f"   Events:          {row['event_count']} events")
        print(f"   Media mentions:  {row['media_mentions']}")
        print(f"   Recent change:   {row['recent_change']:.2f}")

    # Generate hourly timeline
    timeline = generate_hourly_timeline(df)
    timeline_file = f'data/processed/goldstein_hourly_timeline_{datetime.now().strftime("%Y%m%d")}.csv'
    timeline.to_csv(timeline_file, index=False)

    print("\n" + "=" * 70)
    print("ðŸ“Š KEY INSIGHTS")
    print("=" * 70)

    critical = risk_df[risk_df['risk_level'] == 'CRITICAL']
    high = risk_df[risk_df['risk_level'] == 'HIGH']

    print(f"Critical risk locations:  {len(critical)}")
    print(f"High risk locations:      {len(high)}")
    print(f"Total locations tracked:  {len(risk_df)}")
    print(f"\nHourly timeline points:   {len(timeline)} hours")  # NEW: Show hour count

    print(f"\nðŸ’¾ Files saved:")
    print(f"   â€¢ {risk_file}")
    print(f"   â€¢ {timeline_file}")

    print("\n" + "=" * 70)
    print("âœ… ANALYSIS COMPLETE")
    print("=" * 70)

    return risk_df, timeline

if __name__ == '__main__':
    risk_df, timeline = main()

### ./scripts/gdelt/fetch_sudan_events.py ###
# scripts/gdelt/fetch_sudan_events.py
"""
Fetch Sudan events from GDELT 2.0 with Goldstein Scale
PROVEN TO WORK: Uses 'SU' country code
DEFAULT: Fetches last 7 days for better trend analysis
"""
import pandas as pd
import requests
import zipfile
from io import BytesIO
from datetime import datetime
import os

def fetch_sudan_from_file(url):
    """Download and filter one GDELT file for Sudan"""
    try:
        response = requests.get(url, timeout=30)
        content = BytesIO(response.content)
        
        with zipfile.ZipFile(content) as z:
            csv_file = z.namelist()[0]
            with z.open(csv_file) as f:
                # Read with column 53 = ActionGeo_CountryCode
                df = pd.read_csv(
                    f,
                    sep='\t',
                    header=None,
                    low_memory=False,
                    on_bad_lines='skip'
                )
        
        # Filter for Sudan (column 53 = 'SU')
        sudan = df[df[53] == 'SU'].copy()
        
        if sudan.empty:
            return pd.DataFrame()
        
        # Extract key columns
        result = pd.DataFrame({
            'date': sudan[1],  # SQLDATE
            'event_code': sudan[26],  # EventCode
            'goldstein': sudan[30],  # GoldsteinScale
            'num_mentions': sudan[31],  # NumMentions
            'avg_tone': sudan[33],  # AvgTone
            'actor1': sudan[6],  # Actor1Name
            'actor2': sudan[16],  # Actor2Name
            'location': sudan[52],  # ActionGeo_Fullname
            'latitude': sudan[55],  # ActionGeo_Lat
            'longitude': sudan[56],  # ActionGeo_Long
            'source_url': sudan[58]  # SOURCEURL
        })
        
        return result
    
    except Exception as e:
        return pd.DataFrame()

def fetch_sudan_events(hours=168):  # 7 days = 168 hours
    """
    Fetch recent Sudan events
    Default: last 7 days (168 hours) for better trend analysis
    """
    
    days = hours // 24
    print(f"\nðŸ‡¸ðŸ‡© FETCHING SUDAN EVENTS (Last {days} days / {hours} hours)\n")
    print("=" * 70)
    
    # Get masterfilelist (takes ~10 seconds, large file)
    print("ðŸ“¡ Downloading GDELT masterfilelist (this may take 10-15 seconds)...")
    masterlist_url = "http://data.gdeltproject.org/gdeltv2/masterfilelist.txt"
    response = requests.get(masterlist_url)
    
    lines = response.text.strip().split('\n')
    export_urls = [line.split()[2] for line in lines if '.export.CSV.zip' in line]
    
    # Reverse to get newest first
    export_urls = list(reversed(export_urls))
    
    # Calculate number of files (4 per hour = 15-minute intervals)
    num_files = min(hours * 4, len(export_urls))
    file_urls = export_urls[:num_files]
    
    print(f"âœ… Found {len(export_urls):,} total files in GDELT")
    print(f"ðŸ“¥ Processing {num_files} most recent files ({days} days)...")
    print("   This will take ~5-10 minutes for 7 days of data...")
    print("=" * 70)
    
    all_events = []
    processed = 0
    
    for i, url in enumerate(file_urls, 1):
        filename = url.split('/')[-1][:15]
        
        events = fetch_sudan_from_file(url)
        
        if not events.empty:
            all_events.append(events)
            print(f"[{i:3d}/{num_files}] {filename} âœ… {len(events):2d} events")
        elif i % 20 == 0:  # Show progress every 20 files
            print(f"[{i:3d}/{num_files}] ... ({i/num_files*100:.0f}% complete)")
        
        processed += 1
        
        # Milestone updates
        if processed in [num_files//4, num_files//2, 3*num_files//4]:
            total_so_far = sum(len(e) for e in all_events)
            print(f"\n  ðŸ“Š Progress: {processed}/{num_files} files | {total_so_far} Sudan events so far...\n")
    
    print("=" * 70)
    
    if not all_events:
        print("\nâŒ No Sudan events found")
        print("   Try different date range or check GDELT availability")
        return pd.DataFrame()
    
    # Combine
    combined = pd.concat(all_events, ignore_index=True)
    combined['date'] = pd.to_datetime(combined['date'], format='%Y%m%d')
    
    # Deduplicate
    original_count = len(combined)
    combined = combined.drop_duplicates(subset=['date', 'event_code', 'location'])
    deduped = original_count - len(combined)
    
    # Save
    os.makedirs('data/gdelt', exist_ok=True)
    output_file = f'data/gdelt/sudan_events_{datetime.now().strftime("%Y%m%d_%H%M")}.csv'
    combined.to_csv(output_file, index=False)
    
    # Summary
    print(f"\nðŸ“Š SUMMARY")
    print("=" * 70)
    print(f"Total events:       {len(combined):,} (removed {deduped} duplicates)")
    print(f"Date range:         {combined['date'].min().date()} â†’ {combined['date'].max().date()}")
    print(f"Days covered:       {(combined['date'].max() - combined['date'].min()).days} days")
    print(f"Avg Goldstein:      {combined['goldstein'].mean():.2f} (negative = conflict)")
    print(f"Median Goldstein:   {combined['goldstein'].median():.2f}")
    print(f"Media mentions:     {combined['num_mentions'].sum():,}")
    print(f"Unique locations:   {combined['location'].nunique()}")
    print(f"ðŸ’¾ Saved to:         {output_file}")
    
    print(f"\nðŸŒ TOP 10 LOCATIONS (by event count):")
    location_counts = combined['location'].value_counts().head(10)
    for loc, count in location_counts.items():
        avg_gold = combined[combined['location'] == loc]['goldstein'].mean()
        print(f"  {loc[:50]:<50} {count:>3} events (avg Goldstein: {avg_gold:>5.1f})")
    
    print(f"\nðŸš¨ MOST ESCALATORY EVENTS (Goldstein â‰¤ -5):")
    escalatory = combined[combined['goldstein'] <= -5].sort_values('goldstein').head(10)
    
    if len(escalatory) > 0:
        for i, (_, e) in enumerate(escalatory.iterrows(), 1):
            print(f"  {i}. {e['location']}: Goldstein {e['goldstein']:.1f} (Event {e['event_code']})")
            print(f"     {e['date'].date()}, Mentions: {e['num_mentions']}")
    else:
        print("  No extreme escalatory events (Goldstein â‰¤ -5) in this period")
    
    # Event type breakdown
    print(f"\nðŸ“ˆ EVENT TYPE BREAKDOWN (CAMEO Codes):")
    event_types = combined.groupby('event_code').agg({
        'goldstein': ['count', 'mean']
    }).sort_values(('goldstein', 'count'), ascending=False).head(5)
    event_types.columns = ['Count', 'Avg Goldstein']
    print(event_types.to_string())
    
    print("\n" + "=" * 70)
    print("âœ… GDELT INTEGRATION COMPLETE!")
    print("=" * 70)
    
    return combined

if __name__ == '__main__':
    # Fetch last 7 days (672 files) - optimal for trend analysis
    events = fetch_sudan_events(hours=168)
    
    if not events.empty:
        print("\nðŸ“‹ NEXT STEPS:")
        print("  1. Run: python scripts/gdelt/analyze_goldstein_trends.py")
        print("  2. Integrate with CRAM backend API")
        print("  3. Build dashboard visualization")
        print("\n  For real-time updates, run this script every 6-12 hours")

### ./scripts/gdelt/test_data.py ###
# scripts/gdelt/diagnose_sudan_coverage.py
"""
Diagnose Sudan coverage in GDELT to find the right approach
"""
import pandas as pd
import requests
import zipfile
from io import BytesIO
from datetime import datetime, timedelta

def test_single_recent_file():
    """
    Download ONE recent file and inspect all country codes
    """
    print("ðŸ” DIAGNOSTIC: Testing one recent GDELT file...\n")
    
    # Get masterfilelist
    masterlist_url = "http://data.gdeltproject.org/gdeltv2/masterfilelist.txt"
    response = requests.get(masterlist_url)
    
    # Get URLs
    lines = response.text.strip().split('\n')
    export_urls = [line.split()[2] for line in lines if '.export.CSV.zip' in line]
    
    # REVERSE to get newest
    export_urls = list(reversed(export_urls))
    
    # Test the MOST RECENT file
    test_url = export_urls[0]
    filename = test_url.split('/')[-1]
    
    print(f"ðŸ“¥ Testing file: {filename}")
    print(f"    URL: {test_url}\n")
    
    try:
        # Download
        response = requests.get(test_url, timeout=30)
        content = BytesIO(response.content)
        
        # Unzip
        with zipfile.ZipFile(content) as z:
            csv_file = z.namelist()[0]
            with z.open(csv_file) as f:
                # Read with ALL columns
                df = pd.read_csv(
                    f,
                    sep='\t',
                    header=None,
                    low_memory=False
                )
        
        print(f"âœ… File loaded: {len(df)} total events\n")
        
        # GDELT 2.0 column 53 = ActionGeo_CountryCode
        if len(df.columns) > 53:
            country_col = df.iloc[:, 53]  # Column 53 (0-indexed)
            
            print("ðŸŒ Top 20 countries in this file:")
            print(country_col.value_counts().head(20))
            
            # Check for Sudan variants
            print("\nðŸ‡¸ðŸ‡© Checking Sudan variants:")
            sudan_variants = ['SU', 'SD', 'SDN', 'SUDAN']
            for variant in sudan_variants:
                count = (country_col == variant).sum()
                if count > 0:
                    print(f"   âœ… '{variant}': {count} events")
                else:
                    print(f"   âŒ '{variant}': 0 events")
            
            # Show sample Sudan events if any
            sudan_mask = country_col.isin(sudan_variants)
            if sudan_mask.sum() > 0:
                print(f"\nðŸ“° Sample Sudan event:")
                sample = df[sudan_mask].iloc[0]
                print(f"   Date: {sample[1]}")  # Col 1 = SQLDATE
                print(f"   Event Code: {sample[26]}")  # Col 26 = EventCode
                print(f"   Goldstein: {sample[30]}")  # Col 30 = GoldsteinScale
                print(f"   Location: {sample[52]}")  # Col 52 = ActionGeo_Fullname
            
        else:
            print(f"âš ï¸ File has only {len(df.columns)} columns (expected 60+)")
        
        return True
    
    except Exception as e:
        print(f"âŒ Error: {e}")
        return False

def scan_historical_coverage(days_back=30):
    """
    Scan last N days to find when Sudan events exist
    """
    print(f"\n\nðŸ” SCANNING LAST {days_back} DAYS FOR SUDAN COVERAGE...\n")
    
    masterlist_url = "http://data.gdeltproject.org/gdeltv2/masterfilelist.txt"
    response = requests.get(masterlist_url)
    
    lines = response.text.strip().split('\n')
    export_urls = [line.split()[2] for line in lines if '.export.CSV.zip' in line]
    export_urls = list(reversed(export_urls))
    
    # Sample every 24 files (6 hours)
    sample_urls = export_urls[::24][:days_back*4]  # 4 samples per day
    
    sudan_found = []
    
    for url in sample_urls:
        filename = url.split('/')[-1]
        date_str = filename[:8]
        
        try:
            response = requests.get(url, timeout=20)
            content = BytesIO(response.content)
            
            with zipfile.ZipFile(content) as z:
                csv_file = z.namelist()[0]
                with z.open(csv_file) as f:
                    df = pd.read_csv(f, sep='\t', header=None, low_memory=False, usecols=[53])
            
            sudan_count = (df[53] == 'SU').sum() + (df[53] == 'SD').sum()
            
            if sudan_count > 0:
                print(f"âœ… {date_str}: {sudan_count} Sudan events")
                sudan_found.append((date_str, sudan_count))
            else:
                print(f"âš« {date_str}: No Sudan events")
        
        except Exception as e:
            print(f"âš ï¸ {date_str}: Error - {str(e)[:50]}")
    
    if sudan_found:
        print(f"\nâœ… Found Sudan events in {len(sudan_found)} time periods!")
        print("   Use these dates for historical data collection")
    else:
        print(f"\nâŒ No Sudan events found in last {days_back} days")
        print("   This suggests:")
        print("   â€¢ Sudan country code might have changed")
        print("   â€¢ Limited international media coverage")
        print("   â€¢ Need to check ACLED instead")

if __name__ == '__main__':
    print("=" * 60)
    print("GDELT SUDAN COVERAGE DIAGNOSTIC")
    print("=" * 60)
    
    # Test 1: Check one recent file in detail
    test_single_recent_file()
    
    # Test 2: Scan last 7 days
    scan_historical_coverage(days_back=7)
    
    print("\n" + "=" * 60)
    print("DIAGNOSTIC COMPLETE")
    print("=" * 60)

